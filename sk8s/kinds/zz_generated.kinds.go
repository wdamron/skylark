// Copyright 2018 West Damron. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package kinds

// Code generated by sk8s/gen. DO NOT EDIT

import (
	"reflect"

	"github.com/google/skylark"
	"github.com/google/skylark/sk8s/util"
	"github.com/google/skylark/syntax"

	v1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

type AWSElasticBlockStoreVolumeSource struct {
	V *v1.AWSElasticBlockStoreVolumeSource
}

var (
	_ boxed = (*AWSElasticBlockStoreVolumeSource)(nil)

	AWSElasticBlockStoreVolumeSource_fields = map[string]util.FieldSpec{}
	AWSElasticBlockStoreVolumeSource_inline = map[string]util.FieldSpec{}
	AWSElasticBlockStoreVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.AWSElasticBlockStoreVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.AWSElasticBlockStoreVolumeSource:
			return AWSElasticBlockStoreVolumeSource{V: v}
		case v1.AWSElasticBlockStoreVolumeSource:
			return AWSElasticBlockStoreVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	AWSElasticBlockStoreVolumeSource_attrs = setFieldTypes(t, AWSElasticBlockStoreVolumeSource_fields, AWSElasticBlockStoreVolumeSource_inline)
	Library["AWSElasticBlockStoreVolumeSource"] = skylark.NewBuiltin("AWSElasticBlockStoreVolumeSource", createAWSElasticBlockStoreVolumeSource)
}

func createAWSElasticBlockStoreVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for AWSElasticBlockStoreVolumeSource
}
func (t AWSElasticBlockStoreVolumeSource) UnderlyingKind() interface{} { return t.V }
func (t AWSElasticBlockStoreVolumeSource) Package() util.Package       { return util.V1 }
func (t AWSElasticBlockStoreVolumeSource) Type() string {
	return "k8s_v1_AWSElasticBlockStoreVolumeSource"
}
func (t AWSElasticBlockStoreVolumeSource) String() string        { return t.V.String() }
func (t AWSElasticBlockStoreVolumeSource) Freeze()               {} // TODO
func (t AWSElasticBlockStoreVolumeSource) Truth() skylark.Bool   { return skylark.True }
func (t AWSElasticBlockStoreVolumeSource) Hash() (uint32, error) { return 0, unhashable(t.Type()) }
func (t AWSElasticBlockStoreVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*AWSElasticBlockStoreVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t AWSElasticBlockStoreVolumeSource) AttrNames() []string {
	return AWSElasticBlockStoreVolumeSource_attrs
}
func (t AWSElasticBlockStoreVolumeSource) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, AWSElasticBlockStoreVolumeSource_fields, AWSElasticBlockStoreVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type Affinity struct {
	V *v1.Affinity
}

var (
	_ boxed = (*Affinity)(nil)

	Affinity_fields = map[string]util.FieldSpec{}
	Affinity_inline = map[string]util.FieldSpec{}
	Affinity_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.Affinity)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.Affinity:
			return Affinity{V: v}
		case v1.Affinity:
			return Affinity{V: &v}
		default:
			return skylark.None
		}
	}
	Affinity_attrs = setFieldTypes(t, Affinity_fields, Affinity_inline)
	Library["Affinity"] = skylark.NewBuiltin("Affinity", createAffinity)
}

func createAffinity(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for Affinity
}
func (t Affinity) UnderlyingKind() interface{} { return t.V }
func (t Affinity) Package() util.Package       { return util.V1 }
func (t Affinity) Type() string                { return "k8s_v1_Affinity" }
func (t Affinity) String() string              { return t.V.String() }
func (t Affinity) Freeze()                     {} // TODO
func (t Affinity) Truth() skylark.Bool         { return skylark.True }
func (t Affinity) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t Affinity) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*Affinity)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t Affinity) AttrNames() []string { return Affinity_attrs }
func (t Affinity) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, Affinity_fields, Affinity_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type AttachedVolume struct {
	V *v1.AttachedVolume
}

var (
	_ boxed = (*AttachedVolume)(nil)

	AttachedVolume_fields = map[string]util.FieldSpec{}
	AttachedVolume_inline = map[string]util.FieldSpec{}
	AttachedVolume_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.AttachedVolume)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.AttachedVolume:
			return AttachedVolume{V: v}
		case v1.AttachedVolume:
			return AttachedVolume{V: &v}
		default:
			return skylark.None
		}
	}
	AttachedVolume_attrs = setFieldTypes(t, AttachedVolume_fields, AttachedVolume_inline)
	Library["AttachedVolume"] = skylark.NewBuiltin("AttachedVolume", createAttachedVolume)
}

func createAttachedVolume(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for AttachedVolume
}
func (t AttachedVolume) UnderlyingKind() interface{} { return t.V }
func (t AttachedVolume) Package() util.Package       { return util.V1 }
func (t AttachedVolume) Type() string                { return "k8s_v1_AttachedVolume" }
func (t AttachedVolume) String() string              { return t.V.String() }
func (t AttachedVolume) Freeze()                     {} // TODO
func (t AttachedVolume) Truth() skylark.Bool         { return skylark.True }
func (t AttachedVolume) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t AttachedVolume) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*AttachedVolume)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t AttachedVolume) AttrNames() []string { return AttachedVolume_attrs }
func (t AttachedVolume) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, AttachedVolume_fields, AttachedVolume_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type AvoidPods struct {
	V *v1.AvoidPods
}

var (
	_ boxed = (*AvoidPods)(nil)

	AvoidPods_fields = map[string]util.FieldSpec{}
	AvoidPods_inline = map[string]util.FieldSpec{}
	AvoidPods_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.AvoidPods)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.AvoidPods:
			return AvoidPods{V: v}
		case v1.AvoidPods:
			return AvoidPods{V: &v}
		default:
			return skylark.None
		}
	}
	AvoidPods_attrs = setFieldTypes(t, AvoidPods_fields, AvoidPods_inline)
	Library["AvoidPods"] = skylark.NewBuiltin("AvoidPods", createAvoidPods)
}

func createAvoidPods(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for AvoidPods
}
func (t AvoidPods) UnderlyingKind() interface{} { return t.V }
func (t AvoidPods) Package() util.Package       { return util.V1 }
func (t AvoidPods) Type() string                { return "k8s_v1_AvoidPods" }
func (t AvoidPods) String() string              { return t.V.String() }
func (t AvoidPods) Freeze()                     {} // TODO
func (t AvoidPods) Truth() skylark.Bool         { return skylark.True }
func (t AvoidPods) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t AvoidPods) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*AvoidPods)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t AvoidPods) AttrNames() []string { return AvoidPods_attrs }
func (t AvoidPods) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, AvoidPods_fields, AvoidPods_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type AzureDiskVolumeSource struct {
	V *v1.AzureDiskVolumeSource
}

var (
	_ boxed = (*AzureDiskVolumeSource)(nil)

	AzureDiskVolumeSource_fields = map[string]util.FieldSpec{}
	AzureDiskVolumeSource_inline = map[string]util.FieldSpec{}
	AzureDiskVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.AzureDiskVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.AzureDiskVolumeSource:
			return AzureDiskVolumeSource{V: v}
		case v1.AzureDiskVolumeSource:
			return AzureDiskVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	AzureDiskVolumeSource_attrs = setFieldTypes(t, AzureDiskVolumeSource_fields, AzureDiskVolumeSource_inline)
	Library["AzureDiskVolumeSource"] = skylark.NewBuiltin("AzureDiskVolumeSource", createAzureDiskVolumeSource)
}

func createAzureDiskVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for AzureDiskVolumeSource
}
func (t AzureDiskVolumeSource) UnderlyingKind() interface{} { return t.V }
func (t AzureDiskVolumeSource) Package() util.Package       { return util.V1 }
func (t AzureDiskVolumeSource) Type() string                { return "k8s_v1_AzureDiskVolumeSource" }
func (t AzureDiskVolumeSource) String() string              { return t.V.String() }
func (t AzureDiskVolumeSource) Freeze()                     {} // TODO
func (t AzureDiskVolumeSource) Truth() skylark.Bool         { return skylark.True }
func (t AzureDiskVolumeSource) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t AzureDiskVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*AzureDiskVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t AzureDiskVolumeSource) AttrNames() []string { return AzureDiskVolumeSource_attrs }
func (t AzureDiskVolumeSource) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, AzureDiskVolumeSource_fields, AzureDiskVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type AzureFilePersistentVolumeSource struct {
	V *v1.AzureFilePersistentVolumeSource
}

var (
	_ boxed = (*AzureFilePersistentVolumeSource)(nil)

	AzureFilePersistentVolumeSource_fields = map[string]util.FieldSpec{}
	AzureFilePersistentVolumeSource_inline = map[string]util.FieldSpec{}
	AzureFilePersistentVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.AzureFilePersistentVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.AzureFilePersistentVolumeSource:
			return AzureFilePersistentVolumeSource{V: v}
		case v1.AzureFilePersistentVolumeSource:
			return AzureFilePersistentVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	AzureFilePersistentVolumeSource_attrs = setFieldTypes(t, AzureFilePersistentVolumeSource_fields, AzureFilePersistentVolumeSource_inline)
	Library["AzureFilePersistentVolumeSource"] = skylark.NewBuiltin("AzureFilePersistentVolumeSource", createAzureFilePersistentVolumeSource)
}

func createAzureFilePersistentVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for AzureFilePersistentVolumeSource
}
func (t AzureFilePersistentVolumeSource) UnderlyingKind() interface{} { return t.V }
func (t AzureFilePersistentVolumeSource) Package() util.Package       { return util.V1 }
func (t AzureFilePersistentVolumeSource) Type() string {
	return "k8s_v1_AzureFilePersistentVolumeSource"
}
func (t AzureFilePersistentVolumeSource) String() string        { return t.V.String() }
func (t AzureFilePersistentVolumeSource) Freeze()               {} // TODO
func (t AzureFilePersistentVolumeSource) Truth() skylark.Bool   { return skylark.True }
func (t AzureFilePersistentVolumeSource) Hash() (uint32, error) { return 0, unhashable(t.Type()) }
func (t AzureFilePersistentVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*AzureFilePersistentVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t AzureFilePersistentVolumeSource) AttrNames() []string {
	return AzureFilePersistentVolumeSource_attrs
}
func (t AzureFilePersistentVolumeSource) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, AzureFilePersistentVolumeSource_fields, AzureFilePersistentVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type AzureFileVolumeSource struct {
	V *v1.AzureFileVolumeSource
}

var (
	_ boxed = (*AzureFileVolumeSource)(nil)

	AzureFileVolumeSource_fields = map[string]util.FieldSpec{}
	AzureFileVolumeSource_inline = map[string]util.FieldSpec{}
	AzureFileVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.AzureFileVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.AzureFileVolumeSource:
			return AzureFileVolumeSource{V: v}
		case v1.AzureFileVolumeSource:
			return AzureFileVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	AzureFileVolumeSource_attrs = setFieldTypes(t, AzureFileVolumeSource_fields, AzureFileVolumeSource_inline)
	Library["AzureFileVolumeSource"] = skylark.NewBuiltin("AzureFileVolumeSource", createAzureFileVolumeSource)
}

func createAzureFileVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for AzureFileVolumeSource
}
func (t AzureFileVolumeSource) UnderlyingKind() interface{} { return t.V }
func (t AzureFileVolumeSource) Package() util.Package       { return util.V1 }
func (t AzureFileVolumeSource) Type() string                { return "k8s_v1_AzureFileVolumeSource" }
func (t AzureFileVolumeSource) String() string              { return t.V.String() }
func (t AzureFileVolumeSource) Freeze()                     {} // TODO
func (t AzureFileVolumeSource) Truth() skylark.Bool         { return skylark.True }
func (t AzureFileVolumeSource) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t AzureFileVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*AzureFileVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t AzureFileVolumeSource) AttrNames() []string { return AzureFileVolumeSource_attrs }
func (t AzureFileVolumeSource) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, AzureFileVolumeSource_fields, AzureFileVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type Binding struct {
	V *v1.Binding
}

var (
	_ boxed = (*Binding)(nil)

	Binding_fields = map[string]util.FieldSpec{}
	Binding_inline = map[string]util.FieldSpec{}
	Binding_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.Binding)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.Binding:
			return Binding{V: v}
		case v1.Binding:
			return Binding{V: &v}
		default:
			return skylark.None
		}
	}
	Binding_attrs = setFieldTypes(t, Binding_fields, Binding_inline)
	Library["Binding"] = skylark.NewBuiltin("Binding", createBinding)
}

func createBinding(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for Binding
}
func (t Binding) UnderlyingKind() interface{} { return t.V }
func (t Binding) Package() util.Package       { return util.V1 }
func (t Binding) Type() string                { return "k8s_v1_Binding" }
func (t Binding) String() string              { return t.V.String() }
func (t Binding) Freeze()                     {} // TODO
func (t Binding) Truth() skylark.Bool         { return skylark.True }
func (t Binding) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t Binding) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*Binding)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t Binding) AttrNames() []string { return Binding_attrs }
func (t Binding) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, Binding_fields, Binding_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type CSIPersistentVolumeSource struct {
	V *v1.CSIPersistentVolumeSource
}

var (
	_ boxed = (*CSIPersistentVolumeSource)(nil)

	CSIPersistentVolumeSource_fields = map[string]util.FieldSpec{}
	CSIPersistentVolumeSource_inline = map[string]util.FieldSpec{}
	CSIPersistentVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.CSIPersistentVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.CSIPersistentVolumeSource:
			return CSIPersistentVolumeSource{V: v}
		case v1.CSIPersistentVolumeSource:
			return CSIPersistentVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	CSIPersistentVolumeSource_attrs = setFieldTypes(t, CSIPersistentVolumeSource_fields, CSIPersistentVolumeSource_inline)
	Library["CSIPersistentVolumeSource"] = skylark.NewBuiltin("CSIPersistentVolumeSource", createCSIPersistentVolumeSource)
}

func createCSIPersistentVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for CSIPersistentVolumeSource
}
func (t CSIPersistentVolumeSource) UnderlyingKind() interface{} { return t.V }
func (t CSIPersistentVolumeSource) Package() util.Package       { return util.V1 }
func (t CSIPersistentVolumeSource) Type() string                { return "k8s_v1_CSIPersistentVolumeSource" }
func (t CSIPersistentVolumeSource) String() string              { return t.V.String() }
func (t CSIPersistentVolumeSource) Freeze()                     {} // TODO
func (t CSIPersistentVolumeSource) Truth() skylark.Bool         { return skylark.True }
func (t CSIPersistentVolumeSource) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t CSIPersistentVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*CSIPersistentVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t CSIPersistentVolumeSource) AttrNames() []string { return CSIPersistentVolumeSource_attrs }
func (t CSIPersistentVolumeSource) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, CSIPersistentVolumeSource_fields, CSIPersistentVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type Capabilities struct {
	V *v1.Capabilities
}

var (
	_ boxed = (*Capabilities)(nil)

	Capabilities_fields = map[string]util.FieldSpec{}
	Capabilities_inline = map[string]util.FieldSpec{}
	Capabilities_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.Capabilities)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.Capabilities:
			return Capabilities{V: v}
		case v1.Capabilities:
			return Capabilities{V: &v}
		default:
			return skylark.None
		}
	}
	Capabilities_attrs = setFieldTypes(t, Capabilities_fields, Capabilities_inline)
	Library["Capabilities"] = skylark.NewBuiltin("Capabilities", createCapabilities)
}

func createCapabilities(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for Capabilities
}
func (t Capabilities) UnderlyingKind() interface{} { return t.V }
func (t Capabilities) Package() util.Package       { return util.V1 }
func (t Capabilities) Type() string                { return "k8s_v1_Capabilities" }
func (t Capabilities) String() string              { return t.V.String() }
func (t Capabilities) Freeze()                     {} // TODO
func (t Capabilities) Truth() skylark.Bool         { return skylark.True }
func (t Capabilities) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t Capabilities) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*Capabilities)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t Capabilities) AttrNames() []string { return Capabilities_attrs }
func (t Capabilities) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, Capabilities_fields, Capabilities_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type CephFSPersistentVolumeSource struct {
	V *v1.CephFSPersistentVolumeSource
}

var (
	_ boxed = (*CephFSPersistentVolumeSource)(nil)

	CephFSPersistentVolumeSource_fields = map[string]util.FieldSpec{}
	CephFSPersistentVolumeSource_inline = map[string]util.FieldSpec{}
	CephFSPersistentVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.CephFSPersistentVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.CephFSPersistentVolumeSource:
			return CephFSPersistentVolumeSource{V: v}
		case v1.CephFSPersistentVolumeSource:
			return CephFSPersistentVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	CephFSPersistentVolumeSource_attrs = setFieldTypes(t, CephFSPersistentVolumeSource_fields, CephFSPersistentVolumeSource_inline)
	Library["CephFSPersistentVolumeSource"] = skylark.NewBuiltin("CephFSPersistentVolumeSource", createCephFSPersistentVolumeSource)
}

func createCephFSPersistentVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for CephFSPersistentVolumeSource
}
func (t CephFSPersistentVolumeSource) UnderlyingKind() interface{} { return t.V }
func (t CephFSPersistentVolumeSource) Package() util.Package       { return util.V1 }
func (t CephFSPersistentVolumeSource) Type() string                { return "k8s_v1_CephFSPersistentVolumeSource" }
func (t CephFSPersistentVolumeSource) String() string              { return t.V.String() }
func (t CephFSPersistentVolumeSource) Freeze()                     {} // TODO
func (t CephFSPersistentVolumeSource) Truth() skylark.Bool         { return skylark.True }
func (t CephFSPersistentVolumeSource) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t CephFSPersistentVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*CephFSPersistentVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t CephFSPersistentVolumeSource) AttrNames() []string { return CephFSPersistentVolumeSource_attrs }
func (t CephFSPersistentVolumeSource) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, CephFSPersistentVolumeSource_fields, CephFSPersistentVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type CephFSVolumeSource struct {
	V *v1.CephFSVolumeSource
}

var (
	_ boxed = (*CephFSVolumeSource)(nil)

	CephFSVolumeSource_fields = map[string]util.FieldSpec{}
	CephFSVolumeSource_inline = map[string]util.FieldSpec{}
	CephFSVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.CephFSVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.CephFSVolumeSource:
			return CephFSVolumeSource{V: v}
		case v1.CephFSVolumeSource:
			return CephFSVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	CephFSVolumeSource_attrs = setFieldTypes(t, CephFSVolumeSource_fields, CephFSVolumeSource_inline)
	Library["CephFSVolumeSource"] = skylark.NewBuiltin("CephFSVolumeSource", createCephFSVolumeSource)
}

func createCephFSVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for CephFSVolumeSource
}
func (t CephFSVolumeSource) UnderlyingKind() interface{} { return t.V }
func (t CephFSVolumeSource) Package() util.Package       { return util.V1 }
func (t CephFSVolumeSource) Type() string                { return "k8s_v1_CephFSVolumeSource" }
func (t CephFSVolumeSource) String() string              { return t.V.String() }
func (t CephFSVolumeSource) Freeze()                     {} // TODO
func (t CephFSVolumeSource) Truth() skylark.Bool         { return skylark.True }
func (t CephFSVolumeSource) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t CephFSVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*CephFSVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t CephFSVolumeSource) AttrNames() []string { return CephFSVolumeSource_attrs }
func (t CephFSVolumeSource) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, CephFSVolumeSource_fields, CephFSVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type CinderPersistentVolumeSource struct {
	V *v1.CinderPersistentVolumeSource
}

var (
	_ boxed = (*CinderPersistentVolumeSource)(nil)

	CinderPersistentVolumeSource_fields = map[string]util.FieldSpec{}
	CinderPersistentVolumeSource_inline = map[string]util.FieldSpec{}
	CinderPersistentVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.CinderPersistentVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.CinderPersistentVolumeSource:
			return CinderPersistentVolumeSource{V: v}
		case v1.CinderPersistentVolumeSource:
			return CinderPersistentVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	CinderPersistentVolumeSource_attrs = setFieldTypes(t, CinderPersistentVolumeSource_fields, CinderPersistentVolumeSource_inline)
	Library["CinderPersistentVolumeSource"] = skylark.NewBuiltin("CinderPersistentVolumeSource", createCinderPersistentVolumeSource)
}

func createCinderPersistentVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for CinderPersistentVolumeSource
}
func (t CinderPersistentVolumeSource) UnderlyingKind() interface{} { return t.V }
func (t CinderPersistentVolumeSource) Package() util.Package       { return util.V1 }
func (t CinderPersistentVolumeSource) Type() string                { return "k8s_v1_CinderPersistentVolumeSource" }
func (t CinderPersistentVolumeSource) String() string              { return t.V.String() }
func (t CinderPersistentVolumeSource) Freeze()                     {} // TODO
func (t CinderPersistentVolumeSource) Truth() skylark.Bool         { return skylark.True }
func (t CinderPersistentVolumeSource) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t CinderPersistentVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*CinderPersistentVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t CinderPersistentVolumeSource) AttrNames() []string { return CinderPersistentVolumeSource_attrs }
func (t CinderPersistentVolumeSource) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, CinderPersistentVolumeSource_fields, CinderPersistentVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type CinderVolumeSource struct {
	V *v1.CinderVolumeSource
}

var (
	_ boxed = (*CinderVolumeSource)(nil)

	CinderVolumeSource_fields = map[string]util.FieldSpec{}
	CinderVolumeSource_inline = map[string]util.FieldSpec{}
	CinderVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.CinderVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.CinderVolumeSource:
			return CinderVolumeSource{V: v}
		case v1.CinderVolumeSource:
			return CinderVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	CinderVolumeSource_attrs = setFieldTypes(t, CinderVolumeSource_fields, CinderVolumeSource_inline)
	Library["CinderVolumeSource"] = skylark.NewBuiltin("CinderVolumeSource", createCinderVolumeSource)
}

func createCinderVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for CinderVolumeSource
}
func (t CinderVolumeSource) UnderlyingKind() interface{} { return t.V }
func (t CinderVolumeSource) Package() util.Package       { return util.V1 }
func (t CinderVolumeSource) Type() string                { return "k8s_v1_CinderVolumeSource" }
func (t CinderVolumeSource) String() string              { return t.V.String() }
func (t CinderVolumeSource) Freeze()                     {} // TODO
func (t CinderVolumeSource) Truth() skylark.Bool         { return skylark.True }
func (t CinderVolumeSource) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t CinderVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*CinderVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t CinderVolumeSource) AttrNames() []string { return CinderVolumeSource_attrs }
func (t CinderVolumeSource) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, CinderVolumeSource_fields, CinderVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type ClientIPConfig struct {
	V *v1.ClientIPConfig
}

var (
	_ boxed = (*ClientIPConfig)(nil)

	ClientIPConfig_fields = map[string]util.FieldSpec{}
	ClientIPConfig_inline = map[string]util.FieldSpec{}
	ClientIPConfig_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.ClientIPConfig)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.ClientIPConfig:
			return ClientIPConfig{V: v}
		case v1.ClientIPConfig:
			return ClientIPConfig{V: &v}
		default:
			return skylark.None
		}
	}
	ClientIPConfig_attrs = setFieldTypes(t, ClientIPConfig_fields, ClientIPConfig_inline)
	Library["ClientIPConfig"] = skylark.NewBuiltin("ClientIPConfig", createClientIPConfig)
}

func createClientIPConfig(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for ClientIPConfig
}
func (t ClientIPConfig) UnderlyingKind() interface{} { return t.V }
func (t ClientIPConfig) Package() util.Package       { return util.V1 }
func (t ClientIPConfig) Type() string                { return "k8s_v1_ClientIPConfig" }
func (t ClientIPConfig) String() string              { return t.V.String() }
func (t ClientIPConfig) Freeze()                     {} // TODO
func (t ClientIPConfig) Truth() skylark.Bool         { return skylark.True }
func (t ClientIPConfig) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t ClientIPConfig) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ClientIPConfig)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ClientIPConfig) AttrNames() []string { return ClientIPConfig_attrs }
func (t ClientIPConfig) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, ClientIPConfig_fields, ClientIPConfig_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type ComponentCondition struct {
	V *v1.ComponentCondition
}

var (
	_ boxed = (*ComponentCondition)(nil)

	ComponentCondition_fields = map[string]util.FieldSpec{}
	ComponentCondition_inline = map[string]util.FieldSpec{}
	ComponentCondition_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.ComponentCondition)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.ComponentCondition:
			return ComponentCondition{V: v}
		case v1.ComponentCondition:
			return ComponentCondition{V: &v}
		default:
			return skylark.None
		}
	}
	ComponentCondition_attrs = setFieldTypes(t, ComponentCondition_fields, ComponentCondition_inline)
	Library["ComponentCondition"] = skylark.NewBuiltin("ComponentCondition", createComponentCondition)
}

func createComponentCondition(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for ComponentCondition
}
func (t ComponentCondition) UnderlyingKind() interface{} { return t.V }
func (t ComponentCondition) Package() util.Package       { return util.V1 }
func (t ComponentCondition) Type() string                { return "k8s_v1_ComponentCondition" }
func (t ComponentCondition) String() string              { return t.V.String() }
func (t ComponentCondition) Freeze()                     {} // TODO
func (t ComponentCondition) Truth() skylark.Bool         { return skylark.True }
func (t ComponentCondition) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t ComponentCondition) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ComponentCondition)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ComponentCondition) AttrNames() []string { return ComponentCondition_attrs }
func (t ComponentCondition) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, ComponentCondition_fields, ComponentCondition_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type ComponentStatus struct {
	V *v1.ComponentStatus
}

var (
	_ boxed = (*ComponentStatus)(nil)

	ComponentStatus_fields = map[string]util.FieldSpec{}
	ComponentStatus_inline = map[string]util.FieldSpec{}
	ComponentStatus_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.ComponentStatus)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.ComponentStatus:
			return ComponentStatus{V: v}
		case v1.ComponentStatus:
			return ComponentStatus{V: &v}
		default:
			return skylark.None
		}
	}
	ComponentStatus_attrs = setFieldTypes(t, ComponentStatus_fields, ComponentStatus_inline)
	Library["ComponentStatus"] = skylark.NewBuiltin("ComponentStatus", createComponentStatus)
}

func createComponentStatus(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for ComponentStatus
}
func (t ComponentStatus) UnderlyingKind() interface{} { return t.V }
func (t ComponentStatus) Package() util.Package       { return util.V1 }
func (t ComponentStatus) Type() string                { return "k8s_v1_ComponentStatus" }
func (t ComponentStatus) String() string              { return t.V.String() }
func (t ComponentStatus) Freeze()                     {} // TODO
func (t ComponentStatus) Truth() skylark.Bool         { return skylark.True }
func (t ComponentStatus) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t ComponentStatus) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ComponentStatus)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ComponentStatus) AttrNames() []string { return ComponentStatus_attrs }
func (t ComponentStatus) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, ComponentStatus_fields, ComponentStatus_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type ComponentStatusList struct {
	V *v1.ComponentStatusList
}

var (
	_ boxed = (*ComponentStatusList)(nil)

	ComponentStatusList_fields = map[string]util.FieldSpec{}
	ComponentStatusList_inline = map[string]util.FieldSpec{}
	ComponentStatusList_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.ComponentStatusList)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.ComponentStatusList:
			return ComponentStatusList{V: v}
		case v1.ComponentStatusList:
			return ComponentStatusList{V: &v}
		default:
			return skylark.None
		}
	}
	ComponentStatusList_attrs = setFieldTypes(t, ComponentStatusList_fields, ComponentStatusList_inline)
	Library["ComponentStatusList"] = skylark.NewBuiltin("ComponentStatusList", createComponentStatusList)
}

func createComponentStatusList(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for ComponentStatusList
}
func (t ComponentStatusList) UnderlyingKind() interface{} { return t.V }
func (t ComponentStatusList) Package() util.Package       { return util.V1 }
func (t ComponentStatusList) Type() string                { return "k8s_v1_ComponentStatusList" }
func (t ComponentStatusList) String() string              { return t.V.String() }
func (t ComponentStatusList) Freeze()                     {} // TODO
func (t ComponentStatusList) Truth() skylark.Bool         { return skylark.True }
func (t ComponentStatusList) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t ComponentStatusList) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ComponentStatusList)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ComponentStatusList) AttrNames() []string { return ComponentStatusList_attrs }
func (t ComponentStatusList) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, ComponentStatusList_fields, ComponentStatusList_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type ConfigMap struct {
	V *v1.ConfigMap
}

var (
	_ boxed = (*ConfigMap)(nil)

	ConfigMap_fields = map[string]util.FieldSpec{}
	ConfigMap_inline = map[string]util.FieldSpec{}
	ConfigMap_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.ConfigMap)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.ConfigMap:
			return ConfigMap{V: v}
		case v1.ConfigMap:
			return ConfigMap{V: &v}
		default:
			return skylark.None
		}
	}
	ConfigMap_attrs = setFieldTypes(t, ConfigMap_fields, ConfigMap_inline)
	Library["ConfigMap"] = skylark.NewBuiltin("ConfigMap", createConfigMap)
}

func createConfigMap(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for ConfigMap
}
func (t ConfigMap) UnderlyingKind() interface{} { return t.V }
func (t ConfigMap) Package() util.Package       { return util.V1 }
func (t ConfigMap) Type() string                { return "k8s_v1_ConfigMap" }
func (t ConfigMap) String() string              { return t.V.String() }
func (t ConfigMap) Freeze()                     {} // TODO
func (t ConfigMap) Truth() skylark.Bool         { return skylark.True }
func (t ConfigMap) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t ConfigMap) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ConfigMap)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ConfigMap) AttrNames() []string { return ConfigMap_attrs }
func (t ConfigMap) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, ConfigMap_fields, ConfigMap_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type ConfigMapEnvSource struct {
	V *v1.ConfigMapEnvSource
}

var (
	_ boxed = (*ConfigMapEnvSource)(nil)

	ConfigMapEnvSource_fields = map[string]util.FieldSpec{}
	ConfigMapEnvSource_inline = map[string]util.FieldSpec{}
	ConfigMapEnvSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.ConfigMapEnvSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.ConfigMapEnvSource:
			return ConfigMapEnvSource{V: v}
		case v1.ConfigMapEnvSource:
			return ConfigMapEnvSource{V: &v}
		default:
			return skylark.None
		}
	}
	ConfigMapEnvSource_attrs = setFieldTypes(t, ConfigMapEnvSource_fields, ConfigMapEnvSource_inline)
	Library["ConfigMapEnvSource"] = skylark.NewBuiltin("ConfigMapEnvSource", createConfigMapEnvSource)
}

func createConfigMapEnvSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for ConfigMapEnvSource
}
func (t ConfigMapEnvSource) UnderlyingKind() interface{} { return t.V }
func (t ConfigMapEnvSource) Package() util.Package       { return util.V1 }
func (t ConfigMapEnvSource) Type() string                { return "k8s_v1_ConfigMapEnvSource" }
func (t ConfigMapEnvSource) String() string              { return t.V.String() }
func (t ConfigMapEnvSource) Freeze()                     {} // TODO
func (t ConfigMapEnvSource) Truth() skylark.Bool         { return skylark.True }
func (t ConfigMapEnvSource) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t ConfigMapEnvSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ConfigMapEnvSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ConfigMapEnvSource) AttrNames() []string { return ConfigMapEnvSource_attrs }
func (t ConfigMapEnvSource) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, ConfigMapEnvSource_fields, ConfigMapEnvSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type ConfigMapKeySelector struct {
	V *v1.ConfigMapKeySelector
}

var (
	_ boxed = (*ConfigMapKeySelector)(nil)

	ConfigMapKeySelector_fields = map[string]util.FieldSpec{}
	ConfigMapKeySelector_inline = map[string]util.FieldSpec{}
	ConfigMapKeySelector_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.ConfigMapKeySelector)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.ConfigMapKeySelector:
			return ConfigMapKeySelector{V: v}
		case v1.ConfigMapKeySelector:
			return ConfigMapKeySelector{V: &v}
		default:
			return skylark.None
		}
	}
	ConfigMapKeySelector_attrs = setFieldTypes(t, ConfigMapKeySelector_fields, ConfigMapKeySelector_inline)
	Library["ConfigMapKeySelector"] = skylark.NewBuiltin("ConfigMapKeySelector", createConfigMapKeySelector)
}

func createConfigMapKeySelector(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for ConfigMapKeySelector
}
func (t ConfigMapKeySelector) UnderlyingKind() interface{} { return t.V }
func (t ConfigMapKeySelector) Package() util.Package       { return util.V1 }
func (t ConfigMapKeySelector) Type() string                { return "k8s_v1_ConfigMapKeySelector" }
func (t ConfigMapKeySelector) String() string              { return t.V.String() }
func (t ConfigMapKeySelector) Freeze()                     {} // TODO
func (t ConfigMapKeySelector) Truth() skylark.Bool         { return skylark.True }
func (t ConfigMapKeySelector) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t ConfigMapKeySelector) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ConfigMapKeySelector)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ConfigMapKeySelector) AttrNames() []string { return ConfigMapKeySelector_attrs }
func (t ConfigMapKeySelector) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, ConfigMapKeySelector_fields, ConfigMapKeySelector_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type ConfigMapList struct {
	V *v1.ConfigMapList
}

var (
	_ boxed = (*ConfigMapList)(nil)

	ConfigMapList_fields = map[string]util.FieldSpec{}
	ConfigMapList_inline = map[string]util.FieldSpec{}
	ConfigMapList_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.ConfigMapList)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.ConfigMapList:
			return ConfigMapList{V: v}
		case v1.ConfigMapList:
			return ConfigMapList{V: &v}
		default:
			return skylark.None
		}
	}
	ConfigMapList_attrs = setFieldTypes(t, ConfigMapList_fields, ConfigMapList_inline)
	Library["ConfigMapList"] = skylark.NewBuiltin("ConfigMapList", createConfigMapList)
}

func createConfigMapList(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for ConfigMapList
}
func (t ConfigMapList) UnderlyingKind() interface{} { return t.V }
func (t ConfigMapList) Package() util.Package       { return util.V1 }
func (t ConfigMapList) Type() string                { return "k8s_v1_ConfigMapList" }
func (t ConfigMapList) String() string              { return t.V.String() }
func (t ConfigMapList) Freeze()                     {} // TODO
func (t ConfigMapList) Truth() skylark.Bool         { return skylark.True }
func (t ConfigMapList) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t ConfigMapList) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ConfigMapList)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ConfigMapList) AttrNames() []string { return ConfigMapList_attrs }
func (t ConfigMapList) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, ConfigMapList_fields, ConfigMapList_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type ConfigMapNodeConfigSource struct {
	V *v1.ConfigMapNodeConfigSource
}

var (
	_ boxed = (*ConfigMapNodeConfigSource)(nil)

	ConfigMapNodeConfigSource_fields = map[string]util.FieldSpec{}
	ConfigMapNodeConfigSource_inline = map[string]util.FieldSpec{}
	ConfigMapNodeConfigSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.ConfigMapNodeConfigSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.ConfigMapNodeConfigSource:
			return ConfigMapNodeConfigSource{V: v}
		case v1.ConfigMapNodeConfigSource:
			return ConfigMapNodeConfigSource{V: &v}
		default:
			return skylark.None
		}
	}
	ConfigMapNodeConfigSource_attrs = setFieldTypes(t, ConfigMapNodeConfigSource_fields, ConfigMapNodeConfigSource_inline)
	Library["ConfigMapNodeConfigSource"] = skylark.NewBuiltin("ConfigMapNodeConfigSource", createConfigMapNodeConfigSource)
}

func createConfigMapNodeConfigSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for ConfigMapNodeConfigSource
}
func (t ConfigMapNodeConfigSource) UnderlyingKind() interface{} { return t.V }
func (t ConfigMapNodeConfigSource) Package() util.Package       { return util.V1 }
func (t ConfigMapNodeConfigSource) Type() string                { return "k8s_v1_ConfigMapNodeConfigSource" }
func (t ConfigMapNodeConfigSource) String() string              { return t.V.String() }
func (t ConfigMapNodeConfigSource) Freeze()                     {} // TODO
func (t ConfigMapNodeConfigSource) Truth() skylark.Bool         { return skylark.True }
func (t ConfigMapNodeConfigSource) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t ConfigMapNodeConfigSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ConfigMapNodeConfigSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ConfigMapNodeConfigSource) AttrNames() []string { return ConfigMapNodeConfigSource_attrs }
func (t ConfigMapNodeConfigSource) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, ConfigMapNodeConfigSource_fields, ConfigMapNodeConfigSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type ConfigMapProjection struct {
	V *v1.ConfigMapProjection
}

var (
	_ boxed = (*ConfigMapProjection)(nil)

	ConfigMapProjection_fields = map[string]util.FieldSpec{}
	ConfigMapProjection_inline = map[string]util.FieldSpec{}
	ConfigMapProjection_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.ConfigMapProjection)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.ConfigMapProjection:
			return ConfigMapProjection{V: v}
		case v1.ConfigMapProjection:
			return ConfigMapProjection{V: &v}
		default:
			return skylark.None
		}
	}
	ConfigMapProjection_attrs = setFieldTypes(t, ConfigMapProjection_fields, ConfigMapProjection_inline)
	Library["ConfigMapProjection"] = skylark.NewBuiltin("ConfigMapProjection", createConfigMapProjection)
}

func createConfigMapProjection(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for ConfigMapProjection
}
func (t ConfigMapProjection) UnderlyingKind() interface{} { return t.V }
func (t ConfigMapProjection) Package() util.Package       { return util.V1 }
func (t ConfigMapProjection) Type() string                { return "k8s_v1_ConfigMapProjection" }
func (t ConfigMapProjection) String() string              { return t.V.String() }
func (t ConfigMapProjection) Freeze()                     {} // TODO
func (t ConfigMapProjection) Truth() skylark.Bool         { return skylark.True }
func (t ConfigMapProjection) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t ConfigMapProjection) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ConfigMapProjection)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ConfigMapProjection) AttrNames() []string { return ConfigMapProjection_attrs }
func (t ConfigMapProjection) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, ConfigMapProjection_fields, ConfigMapProjection_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type ConfigMapVolumeSource struct {
	V *v1.ConfigMapVolumeSource
}

var (
	_ boxed = (*ConfigMapVolumeSource)(nil)

	ConfigMapVolumeSource_fields = map[string]util.FieldSpec{}
	ConfigMapVolumeSource_inline = map[string]util.FieldSpec{}
	ConfigMapVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.ConfigMapVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.ConfigMapVolumeSource:
			return ConfigMapVolumeSource{V: v}
		case v1.ConfigMapVolumeSource:
			return ConfigMapVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	ConfigMapVolumeSource_attrs = setFieldTypes(t, ConfigMapVolumeSource_fields, ConfigMapVolumeSource_inline)
	Library["ConfigMapVolumeSource"] = skylark.NewBuiltin("ConfigMapVolumeSource", createConfigMapVolumeSource)
}

func createConfigMapVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for ConfigMapVolumeSource
}
func (t ConfigMapVolumeSource) UnderlyingKind() interface{} { return t.V }
func (t ConfigMapVolumeSource) Package() util.Package       { return util.V1 }
func (t ConfigMapVolumeSource) Type() string                { return "k8s_v1_ConfigMapVolumeSource" }
func (t ConfigMapVolumeSource) String() string              { return t.V.String() }
func (t ConfigMapVolumeSource) Freeze()                     {} // TODO
func (t ConfigMapVolumeSource) Truth() skylark.Bool         { return skylark.True }
func (t ConfigMapVolumeSource) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t ConfigMapVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ConfigMapVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ConfigMapVolumeSource) AttrNames() []string { return ConfigMapVolumeSource_attrs }
func (t ConfigMapVolumeSource) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, ConfigMapVolumeSource_fields, ConfigMapVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type Container struct {
	V *v1.Container
}

var (
	_ boxed = (*Container)(nil)

	Container_fields = map[string]util.FieldSpec{}
	Container_inline = map[string]util.FieldSpec{}
	Container_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.Container)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.Container:
			return Container{V: v}
		case v1.Container:
			return Container{V: &v}
		default:
			return skylark.None
		}
	}
	Container_attrs = setFieldTypes(t, Container_fields, Container_inline)
	Library["Container"] = skylark.NewBuiltin("Container", createContainer)
}

func createContainer(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for Container
}
func (t Container) UnderlyingKind() interface{} { return t.V }
func (t Container) Package() util.Package       { return util.V1 }
func (t Container) Type() string                { return "k8s_v1_Container" }
func (t Container) String() string              { return t.V.String() }
func (t Container) Freeze()                     {} // TODO
func (t Container) Truth() skylark.Bool         { return skylark.True }
func (t Container) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t Container) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*Container)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t Container) AttrNames() []string { return Container_attrs }
func (t Container) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, Container_fields, Container_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type ContainerImage struct {
	V *v1.ContainerImage
}

var (
	_ boxed = (*ContainerImage)(nil)

	ContainerImage_fields = map[string]util.FieldSpec{}
	ContainerImage_inline = map[string]util.FieldSpec{}
	ContainerImage_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.ContainerImage)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.ContainerImage:
			return ContainerImage{V: v}
		case v1.ContainerImage:
			return ContainerImage{V: &v}
		default:
			return skylark.None
		}
	}
	ContainerImage_attrs = setFieldTypes(t, ContainerImage_fields, ContainerImage_inline)
	Library["ContainerImage"] = skylark.NewBuiltin("ContainerImage", createContainerImage)
}

func createContainerImage(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for ContainerImage
}
func (t ContainerImage) UnderlyingKind() interface{} { return t.V }
func (t ContainerImage) Package() util.Package       { return util.V1 }
func (t ContainerImage) Type() string                { return "k8s_v1_ContainerImage" }
func (t ContainerImage) String() string              { return t.V.String() }
func (t ContainerImage) Freeze()                     {} // TODO
func (t ContainerImage) Truth() skylark.Bool         { return skylark.True }
func (t ContainerImage) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t ContainerImage) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ContainerImage)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ContainerImage) AttrNames() []string { return ContainerImage_attrs }
func (t ContainerImage) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, ContainerImage_fields, ContainerImage_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type ContainerPort struct {
	V *v1.ContainerPort
}

var (
	_ boxed = (*ContainerPort)(nil)

	ContainerPort_fields = map[string]util.FieldSpec{}
	ContainerPort_inline = map[string]util.FieldSpec{}
	ContainerPort_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.ContainerPort)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.ContainerPort:
			return ContainerPort{V: v}
		case v1.ContainerPort:
			return ContainerPort{V: &v}
		default:
			return skylark.None
		}
	}
	ContainerPort_attrs = setFieldTypes(t, ContainerPort_fields, ContainerPort_inline)
	Library["ContainerPort"] = skylark.NewBuiltin("ContainerPort", createContainerPort)
}

func createContainerPort(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for ContainerPort
}
func (t ContainerPort) UnderlyingKind() interface{} { return t.V }
func (t ContainerPort) Package() util.Package       { return util.V1 }
func (t ContainerPort) Type() string                { return "k8s_v1_ContainerPort" }
func (t ContainerPort) String() string              { return t.V.String() }
func (t ContainerPort) Freeze()                     {} // TODO
func (t ContainerPort) Truth() skylark.Bool         { return skylark.True }
func (t ContainerPort) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t ContainerPort) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ContainerPort)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ContainerPort) AttrNames() []string { return ContainerPort_attrs }
func (t ContainerPort) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, ContainerPort_fields, ContainerPort_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type ContainerState struct {
	V *v1.ContainerState
}

var (
	_ boxed = (*ContainerState)(nil)

	ContainerState_fields = map[string]util.FieldSpec{}
	ContainerState_inline = map[string]util.FieldSpec{}
	ContainerState_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.ContainerState)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.ContainerState:
			return ContainerState{V: v}
		case v1.ContainerState:
			return ContainerState{V: &v}
		default:
			return skylark.None
		}
	}
	ContainerState_attrs = setFieldTypes(t, ContainerState_fields, ContainerState_inline)
	Library["ContainerState"] = skylark.NewBuiltin("ContainerState", createContainerState)
}

func createContainerState(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for ContainerState
}
func (t ContainerState) UnderlyingKind() interface{} { return t.V }
func (t ContainerState) Package() util.Package       { return util.V1 }
func (t ContainerState) Type() string                { return "k8s_v1_ContainerState" }
func (t ContainerState) String() string              { return t.V.String() }
func (t ContainerState) Freeze()                     {} // TODO
func (t ContainerState) Truth() skylark.Bool         { return skylark.True }
func (t ContainerState) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t ContainerState) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ContainerState)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ContainerState) AttrNames() []string { return ContainerState_attrs }
func (t ContainerState) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, ContainerState_fields, ContainerState_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type ContainerStateRunning struct {
	V *v1.ContainerStateRunning
}

var (
	_ boxed = (*ContainerStateRunning)(nil)

	ContainerStateRunning_fields = map[string]util.FieldSpec{}
	ContainerStateRunning_inline = map[string]util.FieldSpec{}
	ContainerStateRunning_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.ContainerStateRunning)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.ContainerStateRunning:
			return ContainerStateRunning{V: v}
		case v1.ContainerStateRunning:
			return ContainerStateRunning{V: &v}
		default:
			return skylark.None
		}
	}
	ContainerStateRunning_attrs = setFieldTypes(t, ContainerStateRunning_fields, ContainerStateRunning_inline)
	Library["ContainerStateRunning"] = skylark.NewBuiltin("ContainerStateRunning", createContainerStateRunning)
}

func createContainerStateRunning(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for ContainerStateRunning
}
func (t ContainerStateRunning) UnderlyingKind() interface{} { return t.V }
func (t ContainerStateRunning) Package() util.Package       { return util.V1 }
func (t ContainerStateRunning) Type() string                { return "k8s_v1_ContainerStateRunning" }
func (t ContainerStateRunning) String() string              { return t.V.String() }
func (t ContainerStateRunning) Freeze()                     {} // TODO
func (t ContainerStateRunning) Truth() skylark.Bool         { return skylark.True }
func (t ContainerStateRunning) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t ContainerStateRunning) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ContainerStateRunning)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ContainerStateRunning) AttrNames() []string { return ContainerStateRunning_attrs }
func (t ContainerStateRunning) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, ContainerStateRunning_fields, ContainerStateRunning_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type ContainerStateTerminated struct {
	V *v1.ContainerStateTerminated
}

var (
	_ boxed = (*ContainerStateTerminated)(nil)

	ContainerStateTerminated_fields = map[string]util.FieldSpec{}
	ContainerStateTerminated_inline = map[string]util.FieldSpec{}
	ContainerStateTerminated_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.ContainerStateTerminated)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.ContainerStateTerminated:
			return ContainerStateTerminated{V: v}
		case v1.ContainerStateTerminated:
			return ContainerStateTerminated{V: &v}
		default:
			return skylark.None
		}
	}
	ContainerStateTerminated_attrs = setFieldTypes(t, ContainerStateTerminated_fields, ContainerStateTerminated_inline)
	Library["ContainerStateTerminated"] = skylark.NewBuiltin("ContainerStateTerminated", createContainerStateTerminated)
}

func createContainerStateTerminated(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for ContainerStateTerminated
}
func (t ContainerStateTerminated) UnderlyingKind() interface{} { return t.V }
func (t ContainerStateTerminated) Package() util.Package       { return util.V1 }
func (t ContainerStateTerminated) Type() string                { return "k8s_v1_ContainerStateTerminated" }
func (t ContainerStateTerminated) String() string              { return t.V.String() }
func (t ContainerStateTerminated) Freeze()                     {} // TODO
func (t ContainerStateTerminated) Truth() skylark.Bool         { return skylark.True }
func (t ContainerStateTerminated) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t ContainerStateTerminated) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ContainerStateTerminated)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ContainerStateTerminated) AttrNames() []string { return ContainerStateTerminated_attrs }
func (t ContainerStateTerminated) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, ContainerStateTerminated_fields, ContainerStateTerminated_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type ContainerStateWaiting struct {
	V *v1.ContainerStateWaiting
}

var (
	_ boxed = (*ContainerStateWaiting)(nil)

	ContainerStateWaiting_fields = map[string]util.FieldSpec{}
	ContainerStateWaiting_inline = map[string]util.FieldSpec{}
	ContainerStateWaiting_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.ContainerStateWaiting)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.ContainerStateWaiting:
			return ContainerStateWaiting{V: v}
		case v1.ContainerStateWaiting:
			return ContainerStateWaiting{V: &v}
		default:
			return skylark.None
		}
	}
	ContainerStateWaiting_attrs = setFieldTypes(t, ContainerStateWaiting_fields, ContainerStateWaiting_inline)
	Library["ContainerStateWaiting"] = skylark.NewBuiltin("ContainerStateWaiting", createContainerStateWaiting)
}

func createContainerStateWaiting(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for ContainerStateWaiting
}
func (t ContainerStateWaiting) UnderlyingKind() interface{} { return t.V }
func (t ContainerStateWaiting) Package() util.Package       { return util.V1 }
func (t ContainerStateWaiting) Type() string                { return "k8s_v1_ContainerStateWaiting" }
func (t ContainerStateWaiting) String() string              { return t.V.String() }
func (t ContainerStateWaiting) Freeze()                     {} // TODO
func (t ContainerStateWaiting) Truth() skylark.Bool         { return skylark.True }
func (t ContainerStateWaiting) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t ContainerStateWaiting) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ContainerStateWaiting)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ContainerStateWaiting) AttrNames() []string { return ContainerStateWaiting_attrs }
func (t ContainerStateWaiting) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, ContainerStateWaiting_fields, ContainerStateWaiting_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type ContainerStatus struct {
	V *v1.ContainerStatus
}

var (
	_ boxed = (*ContainerStatus)(nil)

	ContainerStatus_fields = map[string]util.FieldSpec{}
	ContainerStatus_inline = map[string]util.FieldSpec{}
	ContainerStatus_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.ContainerStatus)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.ContainerStatus:
			return ContainerStatus{V: v}
		case v1.ContainerStatus:
			return ContainerStatus{V: &v}
		default:
			return skylark.None
		}
	}
	ContainerStatus_attrs = setFieldTypes(t, ContainerStatus_fields, ContainerStatus_inline)
	Library["ContainerStatus"] = skylark.NewBuiltin("ContainerStatus", createContainerStatus)
}

func createContainerStatus(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for ContainerStatus
}
func (t ContainerStatus) UnderlyingKind() interface{} { return t.V }
func (t ContainerStatus) Package() util.Package       { return util.V1 }
func (t ContainerStatus) Type() string                { return "k8s_v1_ContainerStatus" }
func (t ContainerStatus) String() string              { return t.V.String() }
func (t ContainerStatus) Freeze()                     {} // TODO
func (t ContainerStatus) Truth() skylark.Bool         { return skylark.True }
func (t ContainerStatus) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t ContainerStatus) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ContainerStatus)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ContainerStatus) AttrNames() []string { return ContainerStatus_attrs }
func (t ContainerStatus) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, ContainerStatus_fields, ContainerStatus_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type DaemonEndpoint struct {
	V *v1.DaemonEndpoint
}

var (
	_ boxed = (*DaemonEndpoint)(nil)

	DaemonEndpoint_fields = map[string]util.FieldSpec{}
	DaemonEndpoint_inline = map[string]util.FieldSpec{}
	DaemonEndpoint_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.DaemonEndpoint)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.DaemonEndpoint:
			return DaemonEndpoint{V: v}
		case v1.DaemonEndpoint:
			return DaemonEndpoint{V: &v}
		default:
			return skylark.None
		}
	}
	DaemonEndpoint_attrs = setFieldTypes(t, DaemonEndpoint_fields, DaemonEndpoint_inline)
	Library["DaemonEndpoint"] = skylark.NewBuiltin("DaemonEndpoint", createDaemonEndpoint)
}

func createDaemonEndpoint(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for DaemonEndpoint
}
func (t DaemonEndpoint) UnderlyingKind() interface{} { return t.V }
func (t DaemonEndpoint) Package() util.Package       { return util.V1 }
func (t DaemonEndpoint) Type() string                { return "k8s_v1_DaemonEndpoint" }
func (t DaemonEndpoint) String() string              { return t.V.String() }
func (t DaemonEndpoint) Freeze()                     {} // TODO
func (t DaemonEndpoint) Truth() skylark.Bool         { return skylark.True }
func (t DaemonEndpoint) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t DaemonEndpoint) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*DaemonEndpoint)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t DaemonEndpoint) AttrNames() []string { return DaemonEndpoint_attrs }
func (t DaemonEndpoint) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, DaemonEndpoint_fields, DaemonEndpoint_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type DownwardAPIProjection struct {
	V *v1.DownwardAPIProjection
}

var (
	_ boxed = (*DownwardAPIProjection)(nil)

	DownwardAPIProjection_fields = map[string]util.FieldSpec{}
	DownwardAPIProjection_inline = map[string]util.FieldSpec{}
	DownwardAPIProjection_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.DownwardAPIProjection)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.DownwardAPIProjection:
			return DownwardAPIProjection{V: v}
		case v1.DownwardAPIProjection:
			return DownwardAPIProjection{V: &v}
		default:
			return skylark.None
		}
	}
	DownwardAPIProjection_attrs = setFieldTypes(t, DownwardAPIProjection_fields, DownwardAPIProjection_inline)
	Library["DownwardAPIProjection"] = skylark.NewBuiltin("DownwardAPIProjection", createDownwardAPIProjection)
}

func createDownwardAPIProjection(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for DownwardAPIProjection
}
func (t DownwardAPIProjection) UnderlyingKind() interface{} { return t.V }
func (t DownwardAPIProjection) Package() util.Package       { return util.V1 }
func (t DownwardAPIProjection) Type() string                { return "k8s_v1_DownwardAPIProjection" }
func (t DownwardAPIProjection) String() string              { return t.V.String() }
func (t DownwardAPIProjection) Freeze()                     {} // TODO
func (t DownwardAPIProjection) Truth() skylark.Bool         { return skylark.True }
func (t DownwardAPIProjection) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t DownwardAPIProjection) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*DownwardAPIProjection)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t DownwardAPIProjection) AttrNames() []string { return DownwardAPIProjection_attrs }
func (t DownwardAPIProjection) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, DownwardAPIProjection_fields, DownwardAPIProjection_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type DownwardAPIVolumeFile struct {
	V *v1.DownwardAPIVolumeFile
}

var (
	_ boxed = (*DownwardAPIVolumeFile)(nil)

	DownwardAPIVolumeFile_fields = map[string]util.FieldSpec{}
	DownwardAPIVolumeFile_inline = map[string]util.FieldSpec{}
	DownwardAPIVolumeFile_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.DownwardAPIVolumeFile)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.DownwardAPIVolumeFile:
			return DownwardAPIVolumeFile{V: v}
		case v1.DownwardAPIVolumeFile:
			return DownwardAPIVolumeFile{V: &v}
		default:
			return skylark.None
		}
	}
	DownwardAPIVolumeFile_attrs = setFieldTypes(t, DownwardAPIVolumeFile_fields, DownwardAPIVolumeFile_inline)
	Library["DownwardAPIVolumeFile"] = skylark.NewBuiltin("DownwardAPIVolumeFile", createDownwardAPIVolumeFile)
}

func createDownwardAPIVolumeFile(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for DownwardAPIVolumeFile
}
func (t DownwardAPIVolumeFile) UnderlyingKind() interface{} { return t.V }
func (t DownwardAPIVolumeFile) Package() util.Package       { return util.V1 }
func (t DownwardAPIVolumeFile) Type() string                { return "k8s_v1_DownwardAPIVolumeFile" }
func (t DownwardAPIVolumeFile) String() string              { return t.V.String() }
func (t DownwardAPIVolumeFile) Freeze()                     {} // TODO
func (t DownwardAPIVolumeFile) Truth() skylark.Bool         { return skylark.True }
func (t DownwardAPIVolumeFile) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t DownwardAPIVolumeFile) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*DownwardAPIVolumeFile)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t DownwardAPIVolumeFile) AttrNames() []string { return DownwardAPIVolumeFile_attrs }
func (t DownwardAPIVolumeFile) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, DownwardAPIVolumeFile_fields, DownwardAPIVolumeFile_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type DownwardAPIVolumeSource struct {
	V *v1.DownwardAPIVolumeSource
}

var (
	_ boxed = (*DownwardAPIVolumeSource)(nil)

	DownwardAPIVolumeSource_fields = map[string]util.FieldSpec{}
	DownwardAPIVolumeSource_inline = map[string]util.FieldSpec{}
	DownwardAPIVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.DownwardAPIVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.DownwardAPIVolumeSource:
			return DownwardAPIVolumeSource{V: v}
		case v1.DownwardAPIVolumeSource:
			return DownwardAPIVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	DownwardAPIVolumeSource_attrs = setFieldTypes(t, DownwardAPIVolumeSource_fields, DownwardAPIVolumeSource_inline)
	Library["DownwardAPIVolumeSource"] = skylark.NewBuiltin("DownwardAPIVolumeSource", createDownwardAPIVolumeSource)
}

func createDownwardAPIVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for DownwardAPIVolumeSource
}
func (t DownwardAPIVolumeSource) UnderlyingKind() interface{} { return t.V }
func (t DownwardAPIVolumeSource) Package() util.Package       { return util.V1 }
func (t DownwardAPIVolumeSource) Type() string                { return "k8s_v1_DownwardAPIVolumeSource" }
func (t DownwardAPIVolumeSource) String() string              { return t.V.String() }
func (t DownwardAPIVolumeSource) Freeze()                     {} // TODO
func (t DownwardAPIVolumeSource) Truth() skylark.Bool         { return skylark.True }
func (t DownwardAPIVolumeSource) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t DownwardAPIVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*DownwardAPIVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t DownwardAPIVolumeSource) AttrNames() []string { return DownwardAPIVolumeSource_attrs }
func (t DownwardAPIVolumeSource) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, DownwardAPIVolumeSource_fields, DownwardAPIVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type EmptyDirVolumeSource struct {
	V *v1.EmptyDirVolumeSource
}

var (
	_ boxed = (*EmptyDirVolumeSource)(nil)

	EmptyDirVolumeSource_fields = map[string]util.FieldSpec{}
	EmptyDirVolumeSource_inline = map[string]util.FieldSpec{}
	EmptyDirVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.EmptyDirVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.EmptyDirVolumeSource:
			return EmptyDirVolumeSource{V: v}
		case v1.EmptyDirVolumeSource:
			return EmptyDirVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	EmptyDirVolumeSource_attrs = setFieldTypes(t, EmptyDirVolumeSource_fields, EmptyDirVolumeSource_inline)
	Library["EmptyDirVolumeSource"] = skylark.NewBuiltin("EmptyDirVolumeSource", createEmptyDirVolumeSource)
}

func createEmptyDirVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for EmptyDirVolumeSource
}
func (t EmptyDirVolumeSource) UnderlyingKind() interface{} { return t.V }
func (t EmptyDirVolumeSource) Package() util.Package       { return util.V1 }
func (t EmptyDirVolumeSource) Type() string                { return "k8s_v1_EmptyDirVolumeSource" }
func (t EmptyDirVolumeSource) String() string              { return t.V.String() }
func (t EmptyDirVolumeSource) Freeze()                     {} // TODO
func (t EmptyDirVolumeSource) Truth() skylark.Bool         { return skylark.True }
func (t EmptyDirVolumeSource) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t EmptyDirVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*EmptyDirVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t EmptyDirVolumeSource) AttrNames() []string { return EmptyDirVolumeSource_attrs }
func (t EmptyDirVolumeSource) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, EmptyDirVolumeSource_fields, EmptyDirVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type EndpointAddress struct {
	V *v1.EndpointAddress
}

var (
	_ boxed = (*EndpointAddress)(nil)

	EndpointAddress_fields = map[string]util.FieldSpec{}
	EndpointAddress_inline = map[string]util.FieldSpec{}
	EndpointAddress_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.EndpointAddress)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.EndpointAddress:
			return EndpointAddress{V: v}
		case v1.EndpointAddress:
			return EndpointAddress{V: &v}
		default:
			return skylark.None
		}
	}
	EndpointAddress_attrs = setFieldTypes(t, EndpointAddress_fields, EndpointAddress_inline)
	Library["EndpointAddress"] = skylark.NewBuiltin("EndpointAddress", createEndpointAddress)
}

func createEndpointAddress(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for EndpointAddress
}
func (t EndpointAddress) UnderlyingKind() interface{} { return t.V }
func (t EndpointAddress) Package() util.Package       { return util.V1 }
func (t EndpointAddress) Type() string                { return "k8s_v1_EndpointAddress" }
func (t EndpointAddress) String() string              { return t.V.String() }
func (t EndpointAddress) Freeze()                     {} // TODO
func (t EndpointAddress) Truth() skylark.Bool         { return skylark.True }
func (t EndpointAddress) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t EndpointAddress) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*EndpointAddress)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t EndpointAddress) AttrNames() []string { return EndpointAddress_attrs }
func (t EndpointAddress) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, EndpointAddress_fields, EndpointAddress_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type EndpointPort struct {
	V *v1.EndpointPort
}

var (
	_ boxed = (*EndpointPort)(nil)

	EndpointPort_fields = map[string]util.FieldSpec{}
	EndpointPort_inline = map[string]util.FieldSpec{}
	EndpointPort_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.EndpointPort)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.EndpointPort:
			return EndpointPort{V: v}
		case v1.EndpointPort:
			return EndpointPort{V: &v}
		default:
			return skylark.None
		}
	}
	EndpointPort_attrs = setFieldTypes(t, EndpointPort_fields, EndpointPort_inline)
	Library["EndpointPort"] = skylark.NewBuiltin("EndpointPort", createEndpointPort)
}

func createEndpointPort(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for EndpointPort
}
func (t EndpointPort) UnderlyingKind() interface{} { return t.V }
func (t EndpointPort) Package() util.Package       { return util.V1 }
func (t EndpointPort) Type() string                { return "k8s_v1_EndpointPort" }
func (t EndpointPort) String() string              { return t.V.String() }
func (t EndpointPort) Freeze()                     {} // TODO
func (t EndpointPort) Truth() skylark.Bool         { return skylark.True }
func (t EndpointPort) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t EndpointPort) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*EndpointPort)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t EndpointPort) AttrNames() []string { return EndpointPort_attrs }
func (t EndpointPort) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, EndpointPort_fields, EndpointPort_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type EndpointSubset struct {
	V *v1.EndpointSubset
}

var (
	_ boxed = (*EndpointSubset)(nil)

	EndpointSubset_fields = map[string]util.FieldSpec{}
	EndpointSubset_inline = map[string]util.FieldSpec{}
	EndpointSubset_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.EndpointSubset)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.EndpointSubset:
			return EndpointSubset{V: v}
		case v1.EndpointSubset:
			return EndpointSubset{V: &v}
		default:
			return skylark.None
		}
	}
	EndpointSubset_attrs = setFieldTypes(t, EndpointSubset_fields, EndpointSubset_inline)
	Library["EndpointSubset"] = skylark.NewBuiltin("EndpointSubset", createEndpointSubset)
}

func createEndpointSubset(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for EndpointSubset
}
func (t EndpointSubset) UnderlyingKind() interface{} { return t.V }
func (t EndpointSubset) Package() util.Package       { return util.V1 }
func (t EndpointSubset) Type() string                { return "k8s_v1_EndpointSubset" }
func (t EndpointSubset) String() string              { return t.V.String() }
func (t EndpointSubset) Freeze()                     {} // TODO
func (t EndpointSubset) Truth() skylark.Bool         { return skylark.True }
func (t EndpointSubset) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t EndpointSubset) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*EndpointSubset)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t EndpointSubset) AttrNames() []string { return EndpointSubset_attrs }
func (t EndpointSubset) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, EndpointSubset_fields, EndpointSubset_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type Endpoints struct {
	V *v1.Endpoints
}

var (
	_ boxed = (*Endpoints)(nil)

	Endpoints_fields = map[string]util.FieldSpec{}
	Endpoints_inline = map[string]util.FieldSpec{}
	Endpoints_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.Endpoints)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.Endpoints:
			return Endpoints{V: v}
		case v1.Endpoints:
			return Endpoints{V: &v}
		default:
			return skylark.None
		}
	}
	Endpoints_attrs = setFieldTypes(t, Endpoints_fields, Endpoints_inline)
	Library["Endpoints"] = skylark.NewBuiltin("Endpoints", createEndpoints)
}

func createEndpoints(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for Endpoints
}
func (t Endpoints) UnderlyingKind() interface{} { return t.V }
func (t Endpoints) Package() util.Package       { return util.V1 }
func (t Endpoints) Type() string                { return "k8s_v1_Endpoints" }
func (t Endpoints) String() string              { return t.V.String() }
func (t Endpoints) Freeze()                     {} // TODO
func (t Endpoints) Truth() skylark.Bool         { return skylark.True }
func (t Endpoints) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t Endpoints) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*Endpoints)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t Endpoints) AttrNames() []string { return Endpoints_attrs }
func (t Endpoints) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, Endpoints_fields, Endpoints_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type EndpointsList struct {
	V *v1.EndpointsList
}

var (
	_ boxed = (*EndpointsList)(nil)

	EndpointsList_fields = map[string]util.FieldSpec{}
	EndpointsList_inline = map[string]util.FieldSpec{}
	EndpointsList_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.EndpointsList)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.EndpointsList:
			return EndpointsList{V: v}
		case v1.EndpointsList:
			return EndpointsList{V: &v}
		default:
			return skylark.None
		}
	}
	EndpointsList_attrs = setFieldTypes(t, EndpointsList_fields, EndpointsList_inline)
	Library["EndpointsList"] = skylark.NewBuiltin("EndpointsList", createEndpointsList)
}

func createEndpointsList(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for EndpointsList
}
func (t EndpointsList) UnderlyingKind() interface{} { return t.V }
func (t EndpointsList) Package() util.Package       { return util.V1 }
func (t EndpointsList) Type() string                { return "k8s_v1_EndpointsList" }
func (t EndpointsList) String() string              { return t.V.String() }
func (t EndpointsList) Freeze()                     {} // TODO
func (t EndpointsList) Truth() skylark.Bool         { return skylark.True }
func (t EndpointsList) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t EndpointsList) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*EndpointsList)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t EndpointsList) AttrNames() []string { return EndpointsList_attrs }
func (t EndpointsList) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, EndpointsList_fields, EndpointsList_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type EnvFromSource struct {
	V *v1.EnvFromSource
}

var (
	_ boxed = (*EnvFromSource)(nil)

	EnvFromSource_fields = map[string]util.FieldSpec{}
	EnvFromSource_inline = map[string]util.FieldSpec{}
	EnvFromSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.EnvFromSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.EnvFromSource:
			return EnvFromSource{V: v}
		case v1.EnvFromSource:
			return EnvFromSource{V: &v}
		default:
			return skylark.None
		}
	}
	EnvFromSource_attrs = setFieldTypes(t, EnvFromSource_fields, EnvFromSource_inline)
	Library["EnvFromSource"] = skylark.NewBuiltin("EnvFromSource", createEnvFromSource)
}

func createEnvFromSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for EnvFromSource
}
func (t EnvFromSource) UnderlyingKind() interface{} { return t.V }
func (t EnvFromSource) Package() util.Package       { return util.V1 }
func (t EnvFromSource) Type() string                { return "k8s_v1_EnvFromSource" }
func (t EnvFromSource) String() string              { return t.V.String() }
func (t EnvFromSource) Freeze()                     {} // TODO
func (t EnvFromSource) Truth() skylark.Bool         { return skylark.True }
func (t EnvFromSource) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t EnvFromSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*EnvFromSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t EnvFromSource) AttrNames() []string { return EnvFromSource_attrs }
func (t EnvFromSource) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, EnvFromSource_fields, EnvFromSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type EnvVar struct {
	V *v1.EnvVar
}

var (
	_ boxed = (*EnvVar)(nil)

	EnvVar_fields = map[string]util.FieldSpec{}
	EnvVar_inline = map[string]util.FieldSpec{}
	EnvVar_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.EnvVar)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.EnvVar:
			return EnvVar{V: v}
		case v1.EnvVar:
			return EnvVar{V: &v}
		default:
			return skylark.None
		}
	}
	EnvVar_attrs = setFieldTypes(t, EnvVar_fields, EnvVar_inline)
	Library["EnvVar"] = skylark.NewBuiltin("EnvVar", createEnvVar)
}

func createEnvVar(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for EnvVar
}
func (t EnvVar) UnderlyingKind() interface{} { return t.V }
func (t EnvVar) Package() util.Package       { return util.V1 }
func (t EnvVar) Type() string                { return "k8s_v1_EnvVar" }
func (t EnvVar) String() string              { return t.V.String() }
func (t EnvVar) Freeze()                     {} // TODO
func (t EnvVar) Truth() skylark.Bool         { return skylark.True }
func (t EnvVar) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t EnvVar) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*EnvVar)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t EnvVar) AttrNames() []string { return EnvVar_attrs }
func (t EnvVar) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, EnvVar_fields, EnvVar_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type EnvVarSource struct {
	V *v1.EnvVarSource
}

var (
	_ boxed = (*EnvVarSource)(nil)

	EnvVarSource_fields = map[string]util.FieldSpec{}
	EnvVarSource_inline = map[string]util.FieldSpec{}
	EnvVarSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.EnvVarSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.EnvVarSource:
			return EnvVarSource{V: v}
		case v1.EnvVarSource:
			return EnvVarSource{V: &v}
		default:
			return skylark.None
		}
	}
	EnvVarSource_attrs = setFieldTypes(t, EnvVarSource_fields, EnvVarSource_inline)
	Library["EnvVarSource"] = skylark.NewBuiltin("EnvVarSource", createEnvVarSource)
}

func createEnvVarSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for EnvVarSource
}
func (t EnvVarSource) UnderlyingKind() interface{} { return t.V }
func (t EnvVarSource) Package() util.Package       { return util.V1 }
func (t EnvVarSource) Type() string                { return "k8s_v1_EnvVarSource" }
func (t EnvVarSource) String() string              { return t.V.String() }
func (t EnvVarSource) Freeze()                     {} // TODO
func (t EnvVarSource) Truth() skylark.Bool         { return skylark.True }
func (t EnvVarSource) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t EnvVarSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*EnvVarSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t EnvVarSource) AttrNames() []string { return EnvVarSource_attrs }
func (t EnvVarSource) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, EnvVarSource_fields, EnvVarSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type Event struct {
	V *v1.Event
}

var (
	_ boxed = (*Event)(nil)

	Event_fields = map[string]util.FieldSpec{}
	Event_inline = map[string]util.FieldSpec{}
	Event_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.Event)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.Event:
			return Event{V: v}
		case v1.Event:
			return Event{V: &v}
		default:
			return skylark.None
		}
	}
	Event_attrs = setFieldTypes(t, Event_fields, Event_inline)
	Library["Event"] = skylark.NewBuiltin("Event", createEvent)
}

func createEvent(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for Event
}
func (t Event) UnderlyingKind() interface{} { return t.V }
func (t Event) Package() util.Package       { return util.V1 }
func (t Event) Type() string                { return "k8s_v1_Event" }
func (t Event) String() string              { return t.V.String() }
func (t Event) Freeze()                     {} // TODO
func (t Event) Truth() skylark.Bool         { return skylark.True }
func (t Event) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t Event) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*Event)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t Event) AttrNames() []string { return Event_attrs }
func (t Event) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, Event_fields, Event_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type EventList struct {
	V *v1.EventList
}

var (
	_ boxed = (*EventList)(nil)

	EventList_fields = map[string]util.FieldSpec{}
	EventList_inline = map[string]util.FieldSpec{}
	EventList_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.EventList)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.EventList:
			return EventList{V: v}
		case v1.EventList:
			return EventList{V: &v}
		default:
			return skylark.None
		}
	}
	EventList_attrs = setFieldTypes(t, EventList_fields, EventList_inline)
	Library["EventList"] = skylark.NewBuiltin("EventList", createEventList)
}

func createEventList(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for EventList
}
func (t EventList) UnderlyingKind() interface{} { return t.V }
func (t EventList) Package() util.Package       { return util.V1 }
func (t EventList) Type() string                { return "k8s_v1_EventList" }
func (t EventList) String() string              { return t.V.String() }
func (t EventList) Freeze()                     {} // TODO
func (t EventList) Truth() skylark.Bool         { return skylark.True }
func (t EventList) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t EventList) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*EventList)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t EventList) AttrNames() []string { return EventList_attrs }
func (t EventList) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, EventList_fields, EventList_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type EventSeries struct {
	V *v1.EventSeries
}

var (
	_ boxed = (*EventSeries)(nil)

	EventSeries_fields = map[string]util.FieldSpec{}
	EventSeries_inline = map[string]util.FieldSpec{}
	EventSeries_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.EventSeries)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.EventSeries:
			return EventSeries{V: v}
		case v1.EventSeries:
			return EventSeries{V: &v}
		default:
			return skylark.None
		}
	}
	EventSeries_attrs = setFieldTypes(t, EventSeries_fields, EventSeries_inline)
	Library["EventSeries"] = skylark.NewBuiltin("EventSeries", createEventSeries)
}

func createEventSeries(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for EventSeries
}
func (t EventSeries) UnderlyingKind() interface{} { return t.V }
func (t EventSeries) Package() util.Package       { return util.V1 }
func (t EventSeries) Type() string                { return "k8s_v1_EventSeries" }
func (t EventSeries) String() string              { return t.V.String() }
func (t EventSeries) Freeze()                     {} // TODO
func (t EventSeries) Truth() skylark.Bool         { return skylark.True }
func (t EventSeries) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t EventSeries) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*EventSeries)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t EventSeries) AttrNames() []string { return EventSeries_attrs }
func (t EventSeries) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, EventSeries_fields, EventSeries_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type EventSource struct {
	V *v1.EventSource
}

var (
	_ boxed = (*EventSource)(nil)

	EventSource_fields = map[string]util.FieldSpec{}
	EventSource_inline = map[string]util.FieldSpec{}
	EventSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.EventSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.EventSource:
			return EventSource{V: v}
		case v1.EventSource:
			return EventSource{V: &v}
		default:
			return skylark.None
		}
	}
	EventSource_attrs = setFieldTypes(t, EventSource_fields, EventSource_inline)
	Library["EventSource"] = skylark.NewBuiltin("EventSource", createEventSource)
}

func createEventSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for EventSource
}
func (t EventSource) UnderlyingKind() interface{} { return t.V }
func (t EventSource) Package() util.Package       { return util.V1 }
func (t EventSource) Type() string                { return "k8s_v1_EventSource" }
func (t EventSource) String() string              { return t.V.String() }
func (t EventSource) Freeze()                     {} // TODO
func (t EventSource) Truth() skylark.Bool         { return skylark.True }
func (t EventSource) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t EventSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*EventSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t EventSource) AttrNames() []string { return EventSource_attrs }
func (t EventSource) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, EventSource_fields, EventSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type ExecAction struct {
	V *v1.ExecAction
}

var (
	_ boxed = (*ExecAction)(nil)

	ExecAction_fields = map[string]util.FieldSpec{}
	ExecAction_inline = map[string]util.FieldSpec{}
	ExecAction_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.ExecAction)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.ExecAction:
			return ExecAction{V: v}
		case v1.ExecAction:
			return ExecAction{V: &v}
		default:
			return skylark.None
		}
	}
	ExecAction_attrs = setFieldTypes(t, ExecAction_fields, ExecAction_inline)
	Library["ExecAction"] = skylark.NewBuiltin("ExecAction", createExecAction)
}

func createExecAction(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for ExecAction
}
func (t ExecAction) UnderlyingKind() interface{} { return t.V }
func (t ExecAction) Package() util.Package       { return util.V1 }
func (t ExecAction) Type() string                { return "k8s_v1_ExecAction" }
func (t ExecAction) String() string              { return t.V.String() }
func (t ExecAction) Freeze()                     {} // TODO
func (t ExecAction) Truth() skylark.Bool         { return skylark.True }
func (t ExecAction) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t ExecAction) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ExecAction)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ExecAction) AttrNames() []string { return ExecAction_attrs }
func (t ExecAction) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, ExecAction_fields, ExecAction_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type FCVolumeSource struct {
	V *v1.FCVolumeSource
}

var (
	_ boxed = (*FCVolumeSource)(nil)

	FCVolumeSource_fields = map[string]util.FieldSpec{}
	FCVolumeSource_inline = map[string]util.FieldSpec{}
	FCVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.FCVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.FCVolumeSource:
			return FCVolumeSource{V: v}
		case v1.FCVolumeSource:
			return FCVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	FCVolumeSource_attrs = setFieldTypes(t, FCVolumeSource_fields, FCVolumeSource_inline)
	Library["FCVolumeSource"] = skylark.NewBuiltin("FCVolumeSource", createFCVolumeSource)
}

func createFCVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for FCVolumeSource
}
func (t FCVolumeSource) UnderlyingKind() interface{} { return t.V }
func (t FCVolumeSource) Package() util.Package       { return util.V1 }
func (t FCVolumeSource) Type() string                { return "k8s_v1_FCVolumeSource" }
func (t FCVolumeSource) String() string              { return t.V.String() }
func (t FCVolumeSource) Freeze()                     {} // TODO
func (t FCVolumeSource) Truth() skylark.Bool         { return skylark.True }
func (t FCVolumeSource) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t FCVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*FCVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t FCVolumeSource) AttrNames() []string { return FCVolumeSource_attrs }
func (t FCVolumeSource) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, FCVolumeSource_fields, FCVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type FlexPersistentVolumeSource struct {
	V *v1.FlexPersistentVolumeSource
}

var (
	_ boxed = (*FlexPersistentVolumeSource)(nil)

	FlexPersistentVolumeSource_fields = map[string]util.FieldSpec{}
	FlexPersistentVolumeSource_inline = map[string]util.FieldSpec{}
	FlexPersistentVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.FlexPersistentVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.FlexPersistentVolumeSource:
			return FlexPersistentVolumeSource{V: v}
		case v1.FlexPersistentVolumeSource:
			return FlexPersistentVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	FlexPersistentVolumeSource_attrs = setFieldTypes(t, FlexPersistentVolumeSource_fields, FlexPersistentVolumeSource_inline)
	Library["FlexPersistentVolumeSource"] = skylark.NewBuiltin("FlexPersistentVolumeSource", createFlexPersistentVolumeSource)
}

func createFlexPersistentVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for FlexPersistentVolumeSource
}
func (t FlexPersistentVolumeSource) UnderlyingKind() interface{} { return t.V }
func (t FlexPersistentVolumeSource) Package() util.Package       { return util.V1 }
func (t FlexPersistentVolumeSource) Type() string                { return "k8s_v1_FlexPersistentVolumeSource" }
func (t FlexPersistentVolumeSource) String() string              { return t.V.String() }
func (t FlexPersistentVolumeSource) Freeze()                     {} // TODO
func (t FlexPersistentVolumeSource) Truth() skylark.Bool         { return skylark.True }
func (t FlexPersistentVolumeSource) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t FlexPersistentVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*FlexPersistentVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t FlexPersistentVolumeSource) AttrNames() []string { return FlexPersistentVolumeSource_attrs }
func (t FlexPersistentVolumeSource) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, FlexPersistentVolumeSource_fields, FlexPersistentVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type FlexVolumeSource struct {
	V *v1.FlexVolumeSource
}

var (
	_ boxed = (*FlexVolumeSource)(nil)

	FlexVolumeSource_fields = map[string]util.FieldSpec{}
	FlexVolumeSource_inline = map[string]util.FieldSpec{}
	FlexVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.FlexVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.FlexVolumeSource:
			return FlexVolumeSource{V: v}
		case v1.FlexVolumeSource:
			return FlexVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	FlexVolumeSource_attrs = setFieldTypes(t, FlexVolumeSource_fields, FlexVolumeSource_inline)
	Library["FlexVolumeSource"] = skylark.NewBuiltin("FlexVolumeSource", createFlexVolumeSource)
}

func createFlexVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for FlexVolumeSource
}
func (t FlexVolumeSource) UnderlyingKind() interface{} { return t.V }
func (t FlexVolumeSource) Package() util.Package       { return util.V1 }
func (t FlexVolumeSource) Type() string                { return "k8s_v1_FlexVolumeSource" }
func (t FlexVolumeSource) String() string              { return t.V.String() }
func (t FlexVolumeSource) Freeze()                     {} // TODO
func (t FlexVolumeSource) Truth() skylark.Bool         { return skylark.True }
func (t FlexVolumeSource) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t FlexVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*FlexVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t FlexVolumeSource) AttrNames() []string { return FlexVolumeSource_attrs }
func (t FlexVolumeSource) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, FlexVolumeSource_fields, FlexVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type FlockerVolumeSource struct {
	V *v1.FlockerVolumeSource
}

var (
	_ boxed = (*FlockerVolumeSource)(nil)

	FlockerVolumeSource_fields = map[string]util.FieldSpec{}
	FlockerVolumeSource_inline = map[string]util.FieldSpec{}
	FlockerVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.FlockerVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.FlockerVolumeSource:
			return FlockerVolumeSource{V: v}
		case v1.FlockerVolumeSource:
			return FlockerVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	FlockerVolumeSource_attrs = setFieldTypes(t, FlockerVolumeSource_fields, FlockerVolumeSource_inline)
	Library["FlockerVolumeSource"] = skylark.NewBuiltin("FlockerVolumeSource", createFlockerVolumeSource)
}

func createFlockerVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for FlockerVolumeSource
}
func (t FlockerVolumeSource) UnderlyingKind() interface{} { return t.V }
func (t FlockerVolumeSource) Package() util.Package       { return util.V1 }
func (t FlockerVolumeSource) Type() string                { return "k8s_v1_FlockerVolumeSource" }
func (t FlockerVolumeSource) String() string              { return t.V.String() }
func (t FlockerVolumeSource) Freeze()                     {} // TODO
func (t FlockerVolumeSource) Truth() skylark.Bool         { return skylark.True }
func (t FlockerVolumeSource) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t FlockerVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*FlockerVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t FlockerVolumeSource) AttrNames() []string { return FlockerVolumeSource_attrs }
func (t FlockerVolumeSource) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, FlockerVolumeSource_fields, FlockerVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type GCEPersistentDiskVolumeSource struct {
	V *v1.GCEPersistentDiskVolumeSource
}

var (
	_ boxed = (*GCEPersistentDiskVolumeSource)(nil)

	GCEPersistentDiskVolumeSource_fields = map[string]util.FieldSpec{}
	GCEPersistentDiskVolumeSource_inline = map[string]util.FieldSpec{}
	GCEPersistentDiskVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.GCEPersistentDiskVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.GCEPersistentDiskVolumeSource:
			return GCEPersistentDiskVolumeSource{V: v}
		case v1.GCEPersistentDiskVolumeSource:
			return GCEPersistentDiskVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	GCEPersistentDiskVolumeSource_attrs = setFieldTypes(t, GCEPersistentDiskVolumeSource_fields, GCEPersistentDiskVolumeSource_inline)
	Library["GCEPersistentDiskVolumeSource"] = skylark.NewBuiltin("GCEPersistentDiskVolumeSource", createGCEPersistentDiskVolumeSource)
}

func createGCEPersistentDiskVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for GCEPersistentDiskVolumeSource
}
func (t GCEPersistentDiskVolumeSource) UnderlyingKind() interface{} { return t.V }
func (t GCEPersistentDiskVolumeSource) Package() util.Package       { return util.V1 }
func (t GCEPersistentDiskVolumeSource) Type() string                { return "k8s_v1_GCEPersistentDiskVolumeSource" }
func (t GCEPersistentDiskVolumeSource) String() string              { return t.V.String() }
func (t GCEPersistentDiskVolumeSource) Freeze()                     {} // TODO
func (t GCEPersistentDiskVolumeSource) Truth() skylark.Bool         { return skylark.True }
func (t GCEPersistentDiskVolumeSource) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t GCEPersistentDiskVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*GCEPersistentDiskVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t GCEPersistentDiskVolumeSource) AttrNames() []string {
	return GCEPersistentDiskVolumeSource_attrs
}
func (t GCEPersistentDiskVolumeSource) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, GCEPersistentDiskVolumeSource_fields, GCEPersistentDiskVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type GitRepoVolumeSource struct {
	V *v1.GitRepoVolumeSource
}

var (
	_ boxed = (*GitRepoVolumeSource)(nil)

	GitRepoVolumeSource_fields = map[string]util.FieldSpec{}
	GitRepoVolumeSource_inline = map[string]util.FieldSpec{}
	GitRepoVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.GitRepoVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.GitRepoVolumeSource:
			return GitRepoVolumeSource{V: v}
		case v1.GitRepoVolumeSource:
			return GitRepoVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	GitRepoVolumeSource_attrs = setFieldTypes(t, GitRepoVolumeSource_fields, GitRepoVolumeSource_inline)
	Library["GitRepoVolumeSource"] = skylark.NewBuiltin("GitRepoVolumeSource", createGitRepoVolumeSource)
}

func createGitRepoVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for GitRepoVolumeSource
}
func (t GitRepoVolumeSource) UnderlyingKind() interface{} { return t.V }
func (t GitRepoVolumeSource) Package() util.Package       { return util.V1 }
func (t GitRepoVolumeSource) Type() string                { return "k8s_v1_GitRepoVolumeSource" }
func (t GitRepoVolumeSource) String() string              { return t.V.String() }
func (t GitRepoVolumeSource) Freeze()                     {} // TODO
func (t GitRepoVolumeSource) Truth() skylark.Bool         { return skylark.True }
func (t GitRepoVolumeSource) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t GitRepoVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*GitRepoVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t GitRepoVolumeSource) AttrNames() []string { return GitRepoVolumeSource_attrs }
func (t GitRepoVolumeSource) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, GitRepoVolumeSource_fields, GitRepoVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type GlusterfsVolumeSource struct {
	V *v1.GlusterfsVolumeSource
}

var (
	_ boxed = (*GlusterfsVolumeSource)(nil)

	GlusterfsVolumeSource_fields = map[string]util.FieldSpec{}
	GlusterfsVolumeSource_inline = map[string]util.FieldSpec{}
	GlusterfsVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.GlusterfsVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.GlusterfsVolumeSource:
			return GlusterfsVolumeSource{V: v}
		case v1.GlusterfsVolumeSource:
			return GlusterfsVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	GlusterfsVolumeSource_attrs = setFieldTypes(t, GlusterfsVolumeSource_fields, GlusterfsVolumeSource_inline)
	Library["GlusterfsVolumeSource"] = skylark.NewBuiltin("GlusterfsVolumeSource", createGlusterfsVolumeSource)
}

func createGlusterfsVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for GlusterfsVolumeSource
}
func (t GlusterfsVolumeSource) UnderlyingKind() interface{} { return t.V }
func (t GlusterfsVolumeSource) Package() util.Package       { return util.V1 }
func (t GlusterfsVolumeSource) Type() string                { return "k8s_v1_GlusterfsVolumeSource" }
func (t GlusterfsVolumeSource) String() string              { return t.V.String() }
func (t GlusterfsVolumeSource) Freeze()                     {} // TODO
func (t GlusterfsVolumeSource) Truth() skylark.Bool         { return skylark.True }
func (t GlusterfsVolumeSource) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t GlusterfsVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*GlusterfsVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t GlusterfsVolumeSource) AttrNames() []string { return GlusterfsVolumeSource_attrs }
func (t GlusterfsVolumeSource) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, GlusterfsVolumeSource_fields, GlusterfsVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type HTTPGetAction struct {
	V *v1.HTTPGetAction
}

var (
	_ boxed = (*HTTPGetAction)(nil)

	HTTPGetAction_fields = map[string]util.FieldSpec{}
	HTTPGetAction_inline = map[string]util.FieldSpec{}
	HTTPGetAction_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.HTTPGetAction)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.HTTPGetAction:
			return HTTPGetAction{V: v}
		case v1.HTTPGetAction:
			return HTTPGetAction{V: &v}
		default:
			return skylark.None
		}
	}
	HTTPGetAction_attrs = setFieldTypes(t, HTTPGetAction_fields, HTTPGetAction_inline)
	Library["HTTPGetAction"] = skylark.NewBuiltin("HTTPGetAction", createHTTPGetAction)
}

func createHTTPGetAction(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for HTTPGetAction
}
func (t HTTPGetAction) UnderlyingKind() interface{} { return t.V }
func (t HTTPGetAction) Package() util.Package       { return util.V1 }
func (t HTTPGetAction) Type() string                { return "k8s_v1_HTTPGetAction" }
func (t HTTPGetAction) String() string              { return t.V.String() }
func (t HTTPGetAction) Freeze()                     {} // TODO
func (t HTTPGetAction) Truth() skylark.Bool         { return skylark.True }
func (t HTTPGetAction) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t HTTPGetAction) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*HTTPGetAction)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t HTTPGetAction) AttrNames() []string { return HTTPGetAction_attrs }
func (t HTTPGetAction) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, HTTPGetAction_fields, HTTPGetAction_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type HTTPHeader struct {
	V *v1.HTTPHeader
}

var (
	_ boxed = (*HTTPHeader)(nil)

	HTTPHeader_fields = map[string]util.FieldSpec{}
	HTTPHeader_inline = map[string]util.FieldSpec{}
	HTTPHeader_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.HTTPHeader)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.HTTPHeader:
			return HTTPHeader{V: v}
		case v1.HTTPHeader:
			return HTTPHeader{V: &v}
		default:
			return skylark.None
		}
	}
	HTTPHeader_attrs = setFieldTypes(t, HTTPHeader_fields, HTTPHeader_inline)
	Library["HTTPHeader"] = skylark.NewBuiltin("HTTPHeader", createHTTPHeader)
}

func createHTTPHeader(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for HTTPHeader
}
func (t HTTPHeader) UnderlyingKind() interface{} { return t.V }
func (t HTTPHeader) Package() util.Package       { return util.V1 }
func (t HTTPHeader) Type() string                { return "k8s_v1_HTTPHeader" }
func (t HTTPHeader) String() string              { return t.V.String() }
func (t HTTPHeader) Freeze()                     {} // TODO
func (t HTTPHeader) Truth() skylark.Bool         { return skylark.True }
func (t HTTPHeader) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t HTTPHeader) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*HTTPHeader)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t HTTPHeader) AttrNames() []string { return HTTPHeader_attrs }
func (t HTTPHeader) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, HTTPHeader_fields, HTTPHeader_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type Handler struct {
	V *v1.Handler
}

var (
	_ boxed = (*Handler)(nil)

	Handler_fields = map[string]util.FieldSpec{}
	Handler_inline = map[string]util.FieldSpec{}
	Handler_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.Handler)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.Handler:
			return Handler{V: v}
		case v1.Handler:
			return Handler{V: &v}
		default:
			return skylark.None
		}
	}
	Handler_attrs = setFieldTypes(t, Handler_fields, Handler_inline)
	Library["Handler"] = skylark.NewBuiltin("Handler", createHandler)
}

func createHandler(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for Handler
}
func (t Handler) UnderlyingKind() interface{} { return t.V }
func (t Handler) Package() util.Package       { return util.V1 }
func (t Handler) Type() string                { return "k8s_v1_Handler" }
func (t Handler) String() string              { return t.V.String() }
func (t Handler) Freeze()                     {} // TODO
func (t Handler) Truth() skylark.Bool         { return skylark.True }
func (t Handler) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t Handler) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*Handler)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t Handler) AttrNames() []string { return Handler_attrs }
func (t Handler) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, Handler_fields, Handler_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type HostAlias struct {
	V *v1.HostAlias
}

var (
	_ boxed = (*HostAlias)(nil)

	HostAlias_fields = map[string]util.FieldSpec{}
	HostAlias_inline = map[string]util.FieldSpec{}
	HostAlias_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.HostAlias)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.HostAlias:
			return HostAlias{V: v}
		case v1.HostAlias:
			return HostAlias{V: &v}
		default:
			return skylark.None
		}
	}
	HostAlias_attrs = setFieldTypes(t, HostAlias_fields, HostAlias_inline)
	Library["HostAlias"] = skylark.NewBuiltin("HostAlias", createHostAlias)
}

func createHostAlias(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for HostAlias
}
func (t HostAlias) UnderlyingKind() interface{} { return t.V }
func (t HostAlias) Package() util.Package       { return util.V1 }
func (t HostAlias) Type() string                { return "k8s_v1_HostAlias" }
func (t HostAlias) String() string              { return t.V.String() }
func (t HostAlias) Freeze()                     {} // TODO
func (t HostAlias) Truth() skylark.Bool         { return skylark.True }
func (t HostAlias) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t HostAlias) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*HostAlias)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t HostAlias) AttrNames() []string { return HostAlias_attrs }
func (t HostAlias) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, HostAlias_fields, HostAlias_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type HostPathVolumeSource struct {
	V *v1.HostPathVolumeSource
}

var (
	_ boxed = (*HostPathVolumeSource)(nil)

	HostPathVolumeSource_fields = map[string]util.FieldSpec{}
	HostPathVolumeSource_inline = map[string]util.FieldSpec{}
	HostPathVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.HostPathVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.HostPathVolumeSource:
			return HostPathVolumeSource{V: v}
		case v1.HostPathVolumeSource:
			return HostPathVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	HostPathVolumeSource_attrs = setFieldTypes(t, HostPathVolumeSource_fields, HostPathVolumeSource_inline)
	Library["HostPathVolumeSource"] = skylark.NewBuiltin("HostPathVolumeSource", createHostPathVolumeSource)
}

func createHostPathVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for HostPathVolumeSource
}
func (t HostPathVolumeSource) UnderlyingKind() interface{} { return t.V }
func (t HostPathVolumeSource) Package() util.Package       { return util.V1 }
func (t HostPathVolumeSource) Type() string                { return "k8s_v1_HostPathVolumeSource" }
func (t HostPathVolumeSource) String() string              { return t.V.String() }
func (t HostPathVolumeSource) Freeze()                     {} // TODO
func (t HostPathVolumeSource) Truth() skylark.Bool         { return skylark.True }
func (t HostPathVolumeSource) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t HostPathVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*HostPathVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t HostPathVolumeSource) AttrNames() []string { return HostPathVolumeSource_attrs }
func (t HostPathVolumeSource) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, HostPathVolumeSource_fields, HostPathVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type ISCSIPersistentVolumeSource struct {
	V *v1.ISCSIPersistentVolumeSource
}

var (
	_ boxed = (*ISCSIPersistentVolumeSource)(nil)

	ISCSIPersistentVolumeSource_fields = map[string]util.FieldSpec{}
	ISCSIPersistentVolumeSource_inline = map[string]util.FieldSpec{}
	ISCSIPersistentVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.ISCSIPersistentVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.ISCSIPersistentVolumeSource:
			return ISCSIPersistentVolumeSource{V: v}
		case v1.ISCSIPersistentVolumeSource:
			return ISCSIPersistentVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	ISCSIPersistentVolumeSource_attrs = setFieldTypes(t, ISCSIPersistentVolumeSource_fields, ISCSIPersistentVolumeSource_inline)
	Library["ISCSIPersistentVolumeSource"] = skylark.NewBuiltin("ISCSIPersistentVolumeSource", createISCSIPersistentVolumeSource)
}

func createISCSIPersistentVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for ISCSIPersistentVolumeSource
}
func (t ISCSIPersistentVolumeSource) UnderlyingKind() interface{} { return t.V }
func (t ISCSIPersistentVolumeSource) Package() util.Package       { return util.V1 }
func (t ISCSIPersistentVolumeSource) Type() string                { return "k8s_v1_ISCSIPersistentVolumeSource" }
func (t ISCSIPersistentVolumeSource) String() string              { return t.V.String() }
func (t ISCSIPersistentVolumeSource) Freeze()                     {} // TODO
func (t ISCSIPersistentVolumeSource) Truth() skylark.Bool         { return skylark.True }
func (t ISCSIPersistentVolumeSource) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t ISCSIPersistentVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ISCSIPersistentVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ISCSIPersistentVolumeSource) AttrNames() []string { return ISCSIPersistentVolumeSource_attrs }
func (t ISCSIPersistentVolumeSource) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, ISCSIPersistentVolumeSource_fields, ISCSIPersistentVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type ISCSIVolumeSource struct {
	V *v1.ISCSIVolumeSource
}

var (
	_ boxed = (*ISCSIVolumeSource)(nil)

	ISCSIVolumeSource_fields = map[string]util.FieldSpec{}
	ISCSIVolumeSource_inline = map[string]util.FieldSpec{}
	ISCSIVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.ISCSIVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.ISCSIVolumeSource:
			return ISCSIVolumeSource{V: v}
		case v1.ISCSIVolumeSource:
			return ISCSIVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	ISCSIVolumeSource_attrs = setFieldTypes(t, ISCSIVolumeSource_fields, ISCSIVolumeSource_inline)
	Library["ISCSIVolumeSource"] = skylark.NewBuiltin("ISCSIVolumeSource", createISCSIVolumeSource)
}

func createISCSIVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for ISCSIVolumeSource
}
func (t ISCSIVolumeSource) UnderlyingKind() interface{} { return t.V }
func (t ISCSIVolumeSource) Package() util.Package       { return util.V1 }
func (t ISCSIVolumeSource) Type() string                { return "k8s_v1_ISCSIVolumeSource" }
func (t ISCSIVolumeSource) String() string              { return t.V.String() }
func (t ISCSIVolumeSource) Freeze()                     {} // TODO
func (t ISCSIVolumeSource) Truth() skylark.Bool         { return skylark.True }
func (t ISCSIVolumeSource) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t ISCSIVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ISCSIVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ISCSIVolumeSource) AttrNames() []string { return ISCSIVolumeSource_attrs }
func (t ISCSIVolumeSource) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, ISCSIVolumeSource_fields, ISCSIVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type KeyToPath struct {
	V *v1.KeyToPath
}

var (
	_ boxed = (*KeyToPath)(nil)

	KeyToPath_fields = map[string]util.FieldSpec{}
	KeyToPath_inline = map[string]util.FieldSpec{}
	KeyToPath_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.KeyToPath)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.KeyToPath:
			return KeyToPath{V: v}
		case v1.KeyToPath:
			return KeyToPath{V: &v}
		default:
			return skylark.None
		}
	}
	KeyToPath_attrs = setFieldTypes(t, KeyToPath_fields, KeyToPath_inline)
	Library["KeyToPath"] = skylark.NewBuiltin("KeyToPath", createKeyToPath)
}

func createKeyToPath(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for KeyToPath
}
func (t KeyToPath) UnderlyingKind() interface{} { return t.V }
func (t KeyToPath) Package() util.Package       { return util.V1 }
func (t KeyToPath) Type() string                { return "k8s_v1_KeyToPath" }
func (t KeyToPath) String() string              { return t.V.String() }
func (t KeyToPath) Freeze()                     {} // TODO
func (t KeyToPath) Truth() skylark.Bool         { return skylark.True }
func (t KeyToPath) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t KeyToPath) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*KeyToPath)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t KeyToPath) AttrNames() []string { return KeyToPath_attrs }
func (t KeyToPath) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, KeyToPath_fields, KeyToPath_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type Lifecycle struct {
	V *v1.Lifecycle
}

var (
	_ boxed = (*Lifecycle)(nil)

	Lifecycle_fields = map[string]util.FieldSpec{}
	Lifecycle_inline = map[string]util.FieldSpec{}
	Lifecycle_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.Lifecycle)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.Lifecycle:
			return Lifecycle{V: v}
		case v1.Lifecycle:
			return Lifecycle{V: &v}
		default:
			return skylark.None
		}
	}
	Lifecycle_attrs = setFieldTypes(t, Lifecycle_fields, Lifecycle_inline)
	Library["Lifecycle"] = skylark.NewBuiltin("Lifecycle", createLifecycle)
}

func createLifecycle(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for Lifecycle
}
func (t Lifecycle) UnderlyingKind() interface{} { return t.V }
func (t Lifecycle) Package() util.Package       { return util.V1 }
func (t Lifecycle) Type() string                { return "k8s_v1_Lifecycle" }
func (t Lifecycle) String() string              { return t.V.String() }
func (t Lifecycle) Freeze()                     {} // TODO
func (t Lifecycle) Truth() skylark.Bool         { return skylark.True }
func (t Lifecycle) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t Lifecycle) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*Lifecycle)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t Lifecycle) AttrNames() []string { return Lifecycle_attrs }
func (t Lifecycle) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, Lifecycle_fields, Lifecycle_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type LimitRange struct {
	V *v1.LimitRange
}

var (
	_ boxed = (*LimitRange)(nil)

	LimitRange_fields = map[string]util.FieldSpec{}
	LimitRange_inline = map[string]util.FieldSpec{}
	LimitRange_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.LimitRange)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.LimitRange:
			return LimitRange{V: v}
		case v1.LimitRange:
			return LimitRange{V: &v}
		default:
			return skylark.None
		}
	}
	LimitRange_attrs = setFieldTypes(t, LimitRange_fields, LimitRange_inline)
	Library["LimitRange"] = skylark.NewBuiltin("LimitRange", createLimitRange)
}

func createLimitRange(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for LimitRange
}
func (t LimitRange) UnderlyingKind() interface{} { return t.V }
func (t LimitRange) Package() util.Package       { return util.V1 }
func (t LimitRange) Type() string                { return "k8s_v1_LimitRange" }
func (t LimitRange) String() string              { return t.V.String() }
func (t LimitRange) Freeze()                     {} // TODO
func (t LimitRange) Truth() skylark.Bool         { return skylark.True }
func (t LimitRange) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t LimitRange) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*LimitRange)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t LimitRange) AttrNames() []string { return LimitRange_attrs }
func (t LimitRange) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, LimitRange_fields, LimitRange_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type LimitRangeItem struct {
	V *v1.LimitRangeItem
}

var (
	_ boxed = (*LimitRangeItem)(nil)

	LimitRangeItem_fields = map[string]util.FieldSpec{}
	LimitRangeItem_inline = map[string]util.FieldSpec{}
	LimitRangeItem_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.LimitRangeItem)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.LimitRangeItem:
			return LimitRangeItem{V: v}
		case v1.LimitRangeItem:
			return LimitRangeItem{V: &v}
		default:
			return skylark.None
		}
	}
	LimitRangeItem_attrs = setFieldTypes(t, LimitRangeItem_fields, LimitRangeItem_inline)
	Library["LimitRangeItem"] = skylark.NewBuiltin("LimitRangeItem", createLimitRangeItem)
}

func createLimitRangeItem(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for LimitRangeItem
}
func (t LimitRangeItem) UnderlyingKind() interface{} { return t.V }
func (t LimitRangeItem) Package() util.Package       { return util.V1 }
func (t LimitRangeItem) Type() string                { return "k8s_v1_LimitRangeItem" }
func (t LimitRangeItem) String() string              { return t.V.String() }
func (t LimitRangeItem) Freeze()                     {} // TODO
func (t LimitRangeItem) Truth() skylark.Bool         { return skylark.True }
func (t LimitRangeItem) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t LimitRangeItem) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*LimitRangeItem)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t LimitRangeItem) AttrNames() []string { return LimitRangeItem_attrs }
func (t LimitRangeItem) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, LimitRangeItem_fields, LimitRangeItem_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type LimitRangeList struct {
	V *v1.LimitRangeList
}

var (
	_ boxed = (*LimitRangeList)(nil)

	LimitRangeList_fields = map[string]util.FieldSpec{}
	LimitRangeList_inline = map[string]util.FieldSpec{}
	LimitRangeList_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.LimitRangeList)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.LimitRangeList:
			return LimitRangeList{V: v}
		case v1.LimitRangeList:
			return LimitRangeList{V: &v}
		default:
			return skylark.None
		}
	}
	LimitRangeList_attrs = setFieldTypes(t, LimitRangeList_fields, LimitRangeList_inline)
	Library["LimitRangeList"] = skylark.NewBuiltin("LimitRangeList", createLimitRangeList)
}

func createLimitRangeList(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for LimitRangeList
}
func (t LimitRangeList) UnderlyingKind() interface{} { return t.V }
func (t LimitRangeList) Package() util.Package       { return util.V1 }
func (t LimitRangeList) Type() string                { return "k8s_v1_LimitRangeList" }
func (t LimitRangeList) String() string              { return t.V.String() }
func (t LimitRangeList) Freeze()                     {} // TODO
func (t LimitRangeList) Truth() skylark.Bool         { return skylark.True }
func (t LimitRangeList) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t LimitRangeList) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*LimitRangeList)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t LimitRangeList) AttrNames() []string { return LimitRangeList_attrs }
func (t LimitRangeList) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, LimitRangeList_fields, LimitRangeList_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type LimitRangeSpec struct {
	V *v1.LimitRangeSpec
}

var (
	_ boxed = (*LimitRangeSpec)(nil)

	LimitRangeSpec_fields = map[string]util.FieldSpec{}
	LimitRangeSpec_inline = map[string]util.FieldSpec{}
	LimitRangeSpec_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.LimitRangeSpec)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.LimitRangeSpec:
			return LimitRangeSpec{V: v}
		case v1.LimitRangeSpec:
			return LimitRangeSpec{V: &v}
		default:
			return skylark.None
		}
	}
	LimitRangeSpec_attrs = setFieldTypes(t, LimitRangeSpec_fields, LimitRangeSpec_inline)
	Library["LimitRangeSpec"] = skylark.NewBuiltin("LimitRangeSpec", createLimitRangeSpec)
}

func createLimitRangeSpec(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for LimitRangeSpec
}
func (t LimitRangeSpec) UnderlyingKind() interface{} { return t.V }
func (t LimitRangeSpec) Package() util.Package       { return util.V1 }
func (t LimitRangeSpec) Type() string                { return "k8s_v1_LimitRangeSpec" }
func (t LimitRangeSpec) String() string              { return t.V.String() }
func (t LimitRangeSpec) Freeze()                     {} // TODO
func (t LimitRangeSpec) Truth() skylark.Bool         { return skylark.True }
func (t LimitRangeSpec) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t LimitRangeSpec) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*LimitRangeSpec)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t LimitRangeSpec) AttrNames() []string { return LimitRangeSpec_attrs }
func (t LimitRangeSpec) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, LimitRangeSpec_fields, LimitRangeSpec_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type List struct {
	V *v1.List
}

var (
	_ boxed = (*List)(nil)

	List_fields = map[string]util.FieldSpec{}
	List_inline = map[string]util.FieldSpec{}
	List_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.List)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.List:
			return List{V: v}
		case v1.List:
			return List{V: &v}
		default:
			return skylark.None
		}
	}
	List_attrs = setFieldTypes(t, List_fields, List_inline)
	Library["List"] = skylark.NewBuiltin("List", createList)
}

func createList(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for List
}
func (t List) UnderlyingKind() interface{} { return t.V }
func (t List) Package() util.Package       { return util.V1 }
func (t List) Type() string                { return "k8s_v1_List" }
func (t List) String() string              { return t.V.String() }
func (t List) Freeze()                     {} // TODO
func (t List) Truth() skylark.Bool         { return skylark.True }
func (t List) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t List) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*List)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t List) AttrNames() []string { return List_attrs }
func (t List) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, List_fields, List_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type LoadBalancerIngress struct {
	V *v1.LoadBalancerIngress
}

var (
	_ boxed = (*LoadBalancerIngress)(nil)

	LoadBalancerIngress_fields = map[string]util.FieldSpec{}
	LoadBalancerIngress_inline = map[string]util.FieldSpec{}
	LoadBalancerIngress_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.LoadBalancerIngress)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.LoadBalancerIngress:
			return LoadBalancerIngress{V: v}
		case v1.LoadBalancerIngress:
			return LoadBalancerIngress{V: &v}
		default:
			return skylark.None
		}
	}
	LoadBalancerIngress_attrs = setFieldTypes(t, LoadBalancerIngress_fields, LoadBalancerIngress_inline)
	Library["LoadBalancerIngress"] = skylark.NewBuiltin("LoadBalancerIngress", createLoadBalancerIngress)
}

func createLoadBalancerIngress(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for LoadBalancerIngress
}
func (t LoadBalancerIngress) UnderlyingKind() interface{} { return t.V }
func (t LoadBalancerIngress) Package() util.Package       { return util.V1 }
func (t LoadBalancerIngress) Type() string                { return "k8s_v1_LoadBalancerIngress" }
func (t LoadBalancerIngress) String() string              { return t.V.String() }
func (t LoadBalancerIngress) Freeze()                     {} // TODO
func (t LoadBalancerIngress) Truth() skylark.Bool         { return skylark.True }
func (t LoadBalancerIngress) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t LoadBalancerIngress) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*LoadBalancerIngress)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t LoadBalancerIngress) AttrNames() []string { return LoadBalancerIngress_attrs }
func (t LoadBalancerIngress) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, LoadBalancerIngress_fields, LoadBalancerIngress_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type LoadBalancerStatus struct {
	V *v1.LoadBalancerStatus
}

var (
	_ boxed = (*LoadBalancerStatus)(nil)

	LoadBalancerStatus_fields = map[string]util.FieldSpec{}
	LoadBalancerStatus_inline = map[string]util.FieldSpec{}
	LoadBalancerStatus_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.LoadBalancerStatus)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.LoadBalancerStatus:
			return LoadBalancerStatus{V: v}
		case v1.LoadBalancerStatus:
			return LoadBalancerStatus{V: &v}
		default:
			return skylark.None
		}
	}
	LoadBalancerStatus_attrs = setFieldTypes(t, LoadBalancerStatus_fields, LoadBalancerStatus_inline)
	Library["LoadBalancerStatus"] = skylark.NewBuiltin("LoadBalancerStatus", createLoadBalancerStatus)
}

func createLoadBalancerStatus(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for LoadBalancerStatus
}
func (t LoadBalancerStatus) UnderlyingKind() interface{} { return t.V }
func (t LoadBalancerStatus) Package() util.Package       { return util.V1 }
func (t LoadBalancerStatus) Type() string                { return "k8s_v1_LoadBalancerStatus" }
func (t LoadBalancerStatus) String() string              { return t.V.String() }
func (t LoadBalancerStatus) Freeze()                     {} // TODO
func (t LoadBalancerStatus) Truth() skylark.Bool         { return skylark.True }
func (t LoadBalancerStatus) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t LoadBalancerStatus) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*LoadBalancerStatus)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t LoadBalancerStatus) AttrNames() []string { return LoadBalancerStatus_attrs }
func (t LoadBalancerStatus) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, LoadBalancerStatus_fields, LoadBalancerStatus_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type LocalObjectReference struct {
	V *v1.LocalObjectReference
}

var (
	_ boxed = (*LocalObjectReference)(nil)

	LocalObjectReference_fields = map[string]util.FieldSpec{}
	LocalObjectReference_inline = map[string]util.FieldSpec{}
	LocalObjectReference_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.LocalObjectReference)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.LocalObjectReference:
			return LocalObjectReference{V: v}
		case v1.LocalObjectReference:
			return LocalObjectReference{V: &v}
		default:
			return skylark.None
		}
	}
	LocalObjectReference_attrs = setFieldTypes(t, LocalObjectReference_fields, LocalObjectReference_inline)
	Library["LocalObjectReference"] = skylark.NewBuiltin("LocalObjectReference", createLocalObjectReference)
}

func createLocalObjectReference(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for LocalObjectReference
}
func (t LocalObjectReference) UnderlyingKind() interface{} { return t.V }
func (t LocalObjectReference) Package() util.Package       { return util.V1 }
func (t LocalObjectReference) Type() string                { return "k8s_v1_LocalObjectReference" }
func (t LocalObjectReference) String() string              { return t.V.String() }
func (t LocalObjectReference) Freeze()                     {} // TODO
func (t LocalObjectReference) Truth() skylark.Bool         { return skylark.True }
func (t LocalObjectReference) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t LocalObjectReference) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*LocalObjectReference)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t LocalObjectReference) AttrNames() []string { return LocalObjectReference_attrs }
func (t LocalObjectReference) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, LocalObjectReference_fields, LocalObjectReference_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type LocalVolumeSource struct {
	V *v1.LocalVolumeSource
}

var (
	_ boxed = (*LocalVolumeSource)(nil)

	LocalVolumeSource_fields = map[string]util.FieldSpec{}
	LocalVolumeSource_inline = map[string]util.FieldSpec{}
	LocalVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.LocalVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.LocalVolumeSource:
			return LocalVolumeSource{V: v}
		case v1.LocalVolumeSource:
			return LocalVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	LocalVolumeSource_attrs = setFieldTypes(t, LocalVolumeSource_fields, LocalVolumeSource_inline)
	Library["LocalVolumeSource"] = skylark.NewBuiltin("LocalVolumeSource", createLocalVolumeSource)
}

func createLocalVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for LocalVolumeSource
}
func (t LocalVolumeSource) UnderlyingKind() interface{} { return t.V }
func (t LocalVolumeSource) Package() util.Package       { return util.V1 }
func (t LocalVolumeSource) Type() string                { return "k8s_v1_LocalVolumeSource" }
func (t LocalVolumeSource) String() string              { return t.V.String() }
func (t LocalVolumeSource) Freeze()                     {} // TODO
func (t LocalVolumeSource) Truth() skylark.Bool         { return skylark.True }
func (t LocalVolumeSource) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t LocalVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*LocalVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t LocalVolumeSource) AttrNames() []string { return LocalVolumeSource_attrs }
func (t LocalVolumeSource) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, LocalVolumeSource_fields, LocalVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type NFSVolumeSource struct {
	V *v1.NFSVolumeSource
}

var (
	_ boxed = (*NFSVolumeSource)(nil)

	NFSVolumeSource_fields = map[string]util.FieldSpec{}
	NFSVolumeSource_inline = map[string]util.FieldSpec{}
	NFSVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.NFSVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.NFSVolumeSource:
			return NFSVolumeSource{V: v}
		case v1.NFSVolumeSource:
			return NFSVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	NFSVolumeSource_attrs = setFieldTypes(t, NFSVolumeSource_fields, NFSVolumeSource_inline)
	Library["NFSVolumeSource"] = skylark.NewBuiltin("NFSVolumeSource", createNFSVolumeSource)
}

func createNFSVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for NFSVolumeSource
}
func (t NFSVolumeSource) UnderlyingKind() interface{} { return t.V }
func (t NFSVolumeSource) Package() util.Package       { return util.V1 }
func (t NFSVolumeSource) Type() string                { return "k8s_v1_NFSVolumeSource" }
func (t NFSVolumeSource) String() string              { return t.V.String() }
func (t NFSVolumeSource) Freeze()                     {} // TODO
func (t NFSVolumeSource) Truth() skylark.Bool         { return skylark.True }
func (t NFSVolumeSource) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t NFSVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*NFSVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t NFSVolumeSource) AttrNames() []string { return NFSVolumeSource_attrs }
func (t NFSVolumeSource) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, NFSVolumeSource_fields, NFSVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type Namespace struct {
	V *v1.Namespace
}

var (
	_ boxed = (*Namespace)(nil)

	Namespace_fields = map[string]util.FieldSpec{}
	Namespace_inline = map[string]util.FieldSpec{}
	Namespace_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.Namespace)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.Namespace:
			return Namespace{V: v}
		case v1.Namespace:
			return Namespace{V: &v}
		default:
			return skylark.None
		}
	}
	Namespace_attrs = setFieldTypes(t, Namespace_fields, Namespace_inline)
	Library["Namespace"] = skylark.NewBuiltin("Namespace", createNamespace)
}

func createNamespace(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for Namespace
}
func (t Namespace) UnderlyingKind() interface{} { return t.V }
func (t Namespace) Package() util.Package       { return util.V1 }
func (t Namespace) Type() string                { return "k8s_v1_Namespace" }
func (t Namespace) String() string              { return t.V.String() }
func (t Namespace) Freeze()                     {} // TODO
func (t Namespace) Truth() skylark.Bool         { return skylark.True }
func (t Namespace) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t Namespace) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*Namespace)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t Namespace) AttrNames() []string { return Namespace_attrs }
func (t Namespace) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, Namespace_fields, Namespace_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type NamespaceList struct {
	V *v1.NamespaceList
}

var (
	_ boxed = (*NamespaceList)(nil)

	NamespaceList_fields = map[string]util.FieldSpec{}
	NamespaceList_inline = map[string]util.FieldSpec{}
	NamespaceList_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.NamespaceList)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.NamespaceList:
			return NamespaceList{V: v}
		case v1.NamespaceList:
			return NamespaceList{V: &v}
		default:
			return skylark.None
		}
	}
	NamespaceList_attrs = setFieldTypes(t, NamespaceList_fields, NamespaceList_inline)
	Library["NamespaceList"] = skylark.NewBuiltin("NamespaceList", createNamespaceList)
}

func createNamespaceList(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for NamespaceList
}
func (t NamespaceList) UnderlyingKind() interface{} { return t.V }
func (t NamespaceList) Package() util.Package       { return util.V1 }
func (t NamespaceList) Type() string                { return "k8s_v1_NamespaceList" }
func (t NamespaceList) String() string              { return t.V.String() }
func (t NamespaceList) Freeze()                     {} // TODO
func (t NamespaceList) Truth() skylark.Bool         { return skylark.True }
func (t NamespaceList) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t NamespaceList) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*NamespaceList)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t NamespaceList) AttrNames() []string { return NamespaceList_attrs }
func (t NamespaceList) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, NamespaceList_fields, NamespaceList_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type NamespaceSpec struct {
	V *v1.NamespaceSpec
}

var (
	_ boxed = (*NamespaceSpec)(nil)

	NamespaceSpec_fields = map[string]util.FieldSpec{}
	NamespaceSpec_inline = map[string]util.FieldSpec{}
	NamespaceSpec_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.NamespaceSpec)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.NamespaceSpec:
			return NamespaceSpec{V: v}
		case v1.NamespaceSpec:
			return NamespaceSpec{V: &v}
		default:
			return skylark.None
		}
	}
	NamespaceSpec_attrs = setFieldTypes(t, NamespaceSpec_fields, NamespaceSpec_inline)
	Library["NamespaceSpec"] = skylark.NewBuiltin("NamespaceSpec", createNamespaceSpec)
}

func createNamespaceSpec(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for NamespaceSpec
}
func (t NamespaceSpec) UnderlyingKind() interface{} { return t.V }
func (t NamespaceSpec) Package() util.Package       { return util.V1 }
func (t NamespaceSpec) Type() string                { return "k8s_v1_NamespaceSpec" }
func (t NamespaceSpec) String() string              { return t.V.String() }
func (t NamespaceSpec) Freeze()                     {} // TODO
func (t NamespaceSpec) Truth() skylark.Bool         { return skylark.True }
func (t NamespaceSpec) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t NamespaceSpec) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*NamespaceSpec)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t NamespaceSpec) AttrNames() []string { return NamespaceSpec_attrs }
func (t NamespaceSpec) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, NamespaceSpec_fields, NamespaceSpec_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type NamespaceStatus struct {
	V *v1.NamespaceStatus
}

var (
	_ boxed = (*NamespaceStatus)(nil)

	NamespaceStatus_fields = map[string]util.FieldSpec{}
	NamespaceStatus_inline = map[string]util.FieldSpec{}
	NamespaceStatus_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.NamespaceStatus)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.NamespaceStatus:
			return NamespaceStatus{V: v}
		case v1.NamespaceStatus:
			return NamespaceStatus{V: &v}
		default:
			return skylark.None
		}
	}
	NamespaceStatus_attrs = setFieldTypes(t, NamespaceStatus_fields, NamespaceStatus_inline)
	Library["NamespaceStatus"] = skylark.NewBuiltin("NamespaceStatus", createNamespaceStatus)
}

func createNamespaceStatus(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for NamespaceStatus
}
func (t NamespaceStatus) UnderlyingKind() interface{} { return t.V }
func (t NamespaceStatus) Package() util.Package       { return util.V1 }
func (t NamespaceStatus) Type() string                { return "k8s_v1_NamespaceStatus" }
func (t NamespaceStatus) String() string              { return t.V.String() }
func (t NamespaceStatus) Freeze()                     {} // TODO
func (t NamespaceStatus) Truth() skylark.Bool         { return skylark.True }
func (t NamespaceStatus) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t NamespaceStatus) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*NamespaceStatus)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t NamespaceStatus) AttrNames() []string { return NamespaceStatus_attrs }
func (t NamespaceStatus) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, NamespaceStatus_fields, NamespaceStatus_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type Node struct {
	V *v1.Node
}

var (
	_ boxed = (*Node)(nil)

	Node_fields = map[string]util.FieldSpec{}
	Node_inline = map[string]util.FieldSpec{}
	Node_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.Node)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.Node:
			return Node{V: v}
		case v1.Node:
			return Node{V: &v}
		default:
			return skylark.None
		}
	}
	Node_attrs = setFieldTypes(t, Node_fields, Node_inline)
	Library["Node"] = skylark.NewBuiltin("Node", createNode)
}

func createNode(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for Node
}
func (t Node) UnderlyingKind() interface{} { return t.V }
func (t Node) Package() util.Package       { return util.V1 }
func (t Node) Type() string                { return "k8s_v1_Node" }
func (t Node) String() string              { return t.V.String() }
func (t Node) Freeze()                     {} // TODO
func (t Node) Truth() skylark.Bool         { return skylark.True }
func (t Node) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t Node) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*Node)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t Node) AttrNames() []string { return Node_attrs }
func (t Node) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, Node_fields, Node_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type NodeAddress struct {
	V *v1.NodeAddress
}

var (
	_ boxed = (*NodeAddress)(nil)

	NodeAddress_fields = map[string]util.FieldSpec{}
	NodeAddress_inline = map[string]util.FieldSpec{}
	NodeAddress_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.NodeAddress)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.NodeAddress:
			return NodeAddress{V: v}
		case v1.NodeAddress:
			return NodeAddress{V: &v}
		default:
			return skylark.None
		}
	}
	NodeAddress_attrs = setFieldTypes(t, NodeAddress_fields, NodeAddress_inline)
	Library["NodeAddress"] = skylark.NewBuiltin("NodeAddress", createNodeAddress)
}

func createNodeAddress(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for NodeAddress
}
func (t NodeAddress) UnderlyingKind() interface{} { return t.V }
func (t NodeAddress) Package() util.Package       { return util.V1 }
func (t NodeAddress) Type() string                { return "k8s_v1_NodeAddress" }
func (t NodeAddress) String() string              { return t.V.String() }
func (t NodeAddress) Freeze()                     {} // TODO
func (t NodeAddress) Truth() skylark.Bool         { return skylark.True }
func (t NodeAddress) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t NodeAddress) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*NodeAddress)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t NodeAddress) AttrNames() []string { return NodeAddress_attrs }
func (t NodeAddress) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, NodeAddress_fields, NodeAddress_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type NodeAffinity struct {
	V *v1.NodeAffinity
}

var (
	_ boxed = (*NodeAffinity)(nil)

	NodeAffinity_fields = map[string]util.FieldSpec{}
	NodeAffinity_inline = map[string]util.FieldSpec{}
	NodeAffinity_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.NodeAffinity)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.NodeAffinity:
			return NodeAffinity{V: v}
		case v1.NodeAffinity:
			return NodeAffinity{V: &v}
		default:
			return skylark.None
		}
	}
	NodeAffinity_attrs = setFieldTypes(t, NodeAffinity_fields, NodeAffinity_inline)
	Library["NodeAffinity"] = skylark.NewBuiltin("NodeAffinity", createNodeAffinity)
}

func createNodeAffinity(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for NodeAffinity
}
func (t NodeAffinity) UnderlyingKind() interface{} { return t.V }
func (t NodeAffinity) Package() util.Package       { return util.V1 }
func (t NodeAffinity) Type() string                { return "k8s_v1_NodeAffinity" }
func (t NodeAffinity) String() string              { return t.V.String() }
func (t NodeAffinity) Freeze()                     {} // TODO
func (t NodeAffinity) Truth() skylark.Bool         { return skylark.True }
func (t NodeAffinity) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t NodeAffinity) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*NodeAffinity)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t NodeAffinity) AttrNames() []string { return NodeAffinity_attrs }
func (t NodeAffinity) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, NodeAffinity_fields, NodeAffinity_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type NodeCondition struct {
	V *v1.NodeCondition
}

var (
	_ boxed = (*NodeCondition)(nil)

	NodeCondition_fields = map[string]util.FieldSpec{}
	NodeCondition_inline = map[string]util.FieldSpec{}
	NodeCondition_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.NodeCondition)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.NodeCondition:
			return NodeCondition{V: v}
		case v1.NodeCondition:
			return NodeCondition{V: &v}
		default:
			return skylark.None
		}
	}
	NodeCondition_attrs = setFieldTypes(t, NodeCondition_fields, NodeCondition_inline)
	Library["NodeCondition"] = skylark.NewBuiltin("NodeCondition", createNodeCondition)
}

func createNodeCondition(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for NodeCondition
}
func (t NodeCondition) UnderlyingKind() interface{} { return t.V }
func (t NodeCondition) Package() util.Package       { return util.V1 }
func (t NodeCondition) Type() string                { return "k8s_v1_NodeCondition" }
func (t NodeCondition) String() string              { return t.V.String() }
func (t NodeCondition) Freeze()                     {} // TODO
func (t NodeCondition) Truth() skylark.Bool         { return skylark.True }
func (t NodeCondition) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t NodeCondition) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*NodeCondition)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t NodeCondition) AttrNames() []string { return NodeCondition_attrs }
func (t NodeCondition) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, NodeCondition_fields, NodeCondition_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type NodeConfigSource struct {
	V *v1.NodeConfigSource
}

var (
	_ boxed = (*NodeConfigSource)(nil)

	NodeConfigSource_fields = map[string]util.FieldSpec{}
	NodeConfigSource_inline = map[string]util.FieldSpec{}
	NodeConfigSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.NodeConfigSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.NodeConfigSource:
			return NodeConfigSource{V: v}
		case v1.NodeConfigSource:
			return NodeConfigSource{V: &v}
		default:
			return skylark.None
		}
	}
	NodeConfigSource_attrs = setFieldTypes(t, NodeConfigSource_fields, NodeConfigSource_inline)
	Library["NodeConfigSource"] = skylark.NewBuiltin("NodeConfigSource", createNodeConfigSource)
}

func createNodeConfigSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for NodeConfigSource
}
func (t NodeConfigSource) UnderlyingKind() interface{} { return t.V }
func (t NodeConfigSource) Package() util.Package       { return util.V1 }
func (t NodeConfigSource) Type() string                { return "k8s_v1_NodeConfigSource" }
func (t NodeConfigSource) String() string              { return t.V.String() }
func (t NodeConfigSource) Freeze()                     {} // TODO
func (t NodeConfigSource) Truth() skylark.Bool         { return skylark.True }
func (t NodeConfigSource) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t NodeConfigSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*NodeConfigSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t NodeConfigSource) AttrNames() []string { return NodeConfigSource_attrs }
func (t NodeConfigSource) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, NodeConfigSource_fields, NodeConfigSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type NodeConfigStatus struct {
	V *v1.NodeConfigStatus
}

var (
	_ boxed = (*NodeConfigStatus)(nil)

	NodeConfigStatus_fields = map[string]util.FieldSpec{}
	NodeConfigStatus_inline = map[string]util.FieldSpec{}
	NodeConfigStatus_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.NodeConfigStatus)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.NodeConfigStatus:
			return NodeConfigStatus{V: v}
		case v1.NodeConfigStatus:
			return NodeConfigStatus{V: &v}
		default:
			return skylark.None
		}
	}
	NodeConfigStatus_attrs = setFieldTypes(t, NodeConfigStatus_fields, NodeConfigStatus_inline)
	Library["NodeConfigStatus"] = skylark.NewBuiltin("NodeConfigStatus", createNodeConfigStatus)
}

func createNodeConfigStatus(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for NodeConfigStatus
}
func (t NodeConfigStatus) UnderlyingKind() interface{} { return t.V }
func (t NodeConfigStatus) Package() util.Package       { return util.V1 }
func (t NodeConfigStatus) Type() string                { return "k8s_v1_NodeConfigStatus" }
func (t NodeConfigStatus) String() string              { return t.V.String() }
func (t NodeConfigStatus) Freeze()                     {} // TODO
func (t NodeConfigStatus) Truth() skylark.Bool         { return skylark.True }
func (t NodeConfigStatus) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t NodeConfigStatus) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*NodeConfigStatus)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t NodeConfigStatus) AttrNames() []string { return NodeConfigStatus_attrs }
func (t NodeConfigStatus) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, NodeConfigStatus_fields, NodeConfigStatus_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type NodeDaemonEndpoints struct {
	V *v1.NodeDaemonEndpoints
}

var (
	_ boxed = (*NodeDaemonEndpoints)(nil)

	NodeDaemonEndpoints_fields = map[string]util.FieldSpec{}
	NodeDaemonEndpoints_inline = map[string]util.FieldSpec{}
	NodeDaemonEndpoints_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.NodeDaemonEndpoints)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.NodeDaemonEndpoints:
			return NodeDaemonEndpoints{V: v}
		case v1.NodeDaemonEndpoints:
			return NodeDaemonEndpoints{V: &v}
		default:
			return skylark.None
		}
	}
	NodeDaemonEndpoints_attrs = setFieldTypes(t, NodeDaemonEndpoints_fields, NodeDaemonEndpoints_inline)
	Library["NodeDaemonEndpoints"] = skylark.NewBuiltin("NodeDaemonEndpoints", createNodeDaemonEndpoints)
}

func createNodeDaemonEndpoints(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for NodeDaemonEndpoints
}
func (t NodeDaemonEndpoints) UnderlyingKind() interface{} { return t.V }
func (t NodeDaemonEndpoints) Package() util.Package       { return util.V1 }
func (t NodeDaemonEndpoints) Type() string                { return "k8s_v1_NodeDaemonEndpoints" }
func (t NodeDaemonEndpoints) String() string              { return t.V.String() }
func (t NodeDaemonEndpoints) Freeze()                     {} // TODO
func (t NodeDaemonEndpoints) Truth() skylark.Bool         { return skylark.True }
func (t NodeDaemonEndpoints) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t NodeDaemonEndpoints) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*NodeDaemonEndpoints)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t NodeDaemonEndpoints) AttrNames() []string { return NodeDaemonEndpoints_attrs }
func (t NodeDaemonEndpoints) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, NodeDaemonEndpoints_fields, NodeDaemonEndpoints_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type NodeList struct {
	V *v1.NodeList
}

var (
	_ boxed = (*NodeList)(nil)

	NodeList_fields = map[string]util.FieldSpec{}
	NodeList_inline = map[string]util.FieldSpec{}
	NodeList_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.NodeList)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.NodeList:
			return NodeList{V: v}
		case v1.NodeList:
			return NodeList{V: &v}
		default:
			return skylark.None
		}
	}
	NodeList_attrs = setFieldTypes(t, NodeList_fields, NodeList_inline)
	Library["NodeList"] = skylark.NewBuiltin("NodeList", createNodeList)
}

func createNodeList(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for NodeList
}
func (t NodeList) UnderlyingKind() interface{} { return t.V }
func (t NodeList) Package() util.Package       { return util.V1 }
func (t NodeList) Type() string                { return "k8s_v1_NodeList" }
func (t NodeList) String() string              { return t.V.String() }
func (t NodeList) Freeze()                     {} // TODO
func (t NodeList) Truth() skylark.Bool         { return skylark.True }
func (t NodeList) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t NodeList) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*NodeList)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t NodeList) AttrNames() []string { return NodeList_attrs }
func (t NodeList) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, NodeList_fields, NodeList_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type NodeProxyOptions struct {
	V *v1.NodeProxyOptions
}

var (
	_ boxed = (*NodeProxyOptions)(nil)

	NodeProxyOptions_fields = map[string]util.FieldSpec{}
	NodeProxyOptions_inline = map[string]util.FieldSpec{}
	NodeProxyOptions_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.NodeProxyOptions)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.NodeProxyOptions:
			return NodeProxyOptions{V: v}
		case v1.NodeProxyOptions:
			return NodeProxyOptions{V: &v}
		default:
			return skylark.None
		}
	}
	NodeProxyOptions_attrs = setFieldTypes(t, NodeProxyOptions_fields, NodeProxyOptions_inline)
	Library["NodeProxyOptions"] = skylark.NewBuiltin("NodeProxyOptions", createNodeProxyOptions)
}

func createNodeProxyOptions(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for NodeProxyOptions
}
func (t NodeProxyOptions) UnderlyingKind() interface{} { return t.V }
func (t NodeProxyOptions) Package() util.Package       { return util.V1 }
func (t NodeProxyOptions) Type() string                { return "k8s_v1_NodeProxyOptions" }
func (t NodeProxyOptions) String() string              { return t.V.String() }
func (t NodeProxyOptions) Freeze()                     {} // TODO
func (t NodeProxyOptions) Truth() skylark.Bool         { return skylark.True }
func (t NodeProxyOptions) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t NodeProxyOptions) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*NodeProxyOptions)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t NodeProxyOptions) AttrNames() []string { return NodeProxyOptions_attrs }
func (t NodeProxyOptions) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, NodeProxyOptions_fields, NodeProxyOptions_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type NodeResources struct {
	V *v1.NodeResources
}

var (
	_ boxed = (*NodeResources)(nil)

	NodeResources_fields = map[string]util.FieldSpec{}
	NodeResources_inline = map[string]util.FieldSpec{}
	NodeResources_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.NodeResources)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.NodeResources:
			return NodeResources{V: v}
		case v1.NodeResources:
			return NodeResources{V: &v}
		default:
			return skylark.None
		}
	}
	NodeResources_attrs = setFieldTypes(t, NodeResources_fields, NodeResources_inline)
	Library["NodeResources"] = skylark.NewBuiltin("NodeResources", createNodeResources)
}

func createNodeResources(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for NodeResources
}
func (t NodeResources) UnderlyingKind() interface{} { return t.V }
func (t NodeResources) Package() util.Package       { return util.V1 }
func (t NodeResources) Type() string                { return "k8s_v1_NodeResources" }
func (t NodeResources) String() string              { return t.V.String() }
func (t NodeResources) Freeze()                     {} // TODO
func (t NodeResources) Truth() skylark.Bool         { return skylark.True }
func (t NodeResources) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t NodeResources) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*NodeResources)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t NodeResources) AttrNames() []string { return NodeResources_attrs }
func (t NodeResources) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, NodeResources_fields, NodeResources_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type NodeSelector struct {
	V *v1.NodeSelector
}

var (
	_ boxed = (*NodeSelector)(nil)

	NodeSelector_fields = map[string]util.FieldSpec{}
	NodeSelector_inline = map[string]util.FieldSpec{}
	NodeSelector_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.NodeSelector)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.NodeSelector:
			return NodeSelector{V: v}
		case v1.NodeSelector:
			return NodeSelector{V: &v}
		default:
			return skylark.None
		}
	}
	NodeSelector_attrs = setFieldTypes(t, NodeSelector_fields, NodeSelector_inline)
	Library["NodeSelector"] = skylark.NewBuiltin("NodeSelector", createNodeSelector)
}

func createNodeSelector(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for NodeSelector
}
func (t NodeSelector) UnderlyingKind() interface{} { return t.V }
func (t NodeSelector) Package() util.Package       { return util.V1 }
func (t NodeSelector) Type() string                { return "k8s_v1_NodeSelector" }
func (t NodeSelector) String() string              { return t.V.String() }
func (t NodeSelector) Freeze()                     {} // TODO
func (t NodeSelector) Truth() skylark.Bool         { return skylark.True }
func (t NodeSelector) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t NodeSelector) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*NodeSelector)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t NodeSelector) AttrNames() []string { return NodeSelector_attrs }
func (t NodeSelector) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, NodeSelector_fields, NodeSelector_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type NodeSelectorRequirement struct {
	V *v1.NodeSelectorRequirement
}

var (
	_ boxed = (*NodeSelectorRequirement)(nil)

	NodeSelectorRequirement_fields = map[string]util.FieldSpec{}
	NodeSelectorRequirement_inline = map[string]util.FieldSpec{}
	NodeSelectorRequirement_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.NodeSelectorRequirement)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.NodeSelectorRequirement:
			return NodeSelectorRequirement{V: v}
		case v1.NodeSelectorRequirement:
			return NodeSelectorRequirement{V: &v}
		default:
			return skylark.None
		}
	}
	NodeSelectorRequirement_attrs = setFieldTypes(t, NodeSelectorRequirement_fields, NodeSelectorRequirement_inline)
	Library["NodeSelectorRequirement"] = skylark.NewBuiltin("NodeSelectorRequirement", createNodeSelectorRequirement)
}

func createNodeSelectorRequirement(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for NodeSelectorRequirement
}
func (t NodeSelectorRequirement) UnderlyingKind() interface{} { return t.V }
func (t NodeSelectorRequirement) Package() util.Package       { return util.V1 }
func (t NodeSelectorRequirement) Type() string                { return "k8s_v1_NodeSelectorRequirement" }
func (t NodeSelectorRequirement) String() string              { return t.V.String() }
func (t NodeSelectorRequirement) Freeze()                     {} // TODO
func (t NodeSelectorRequirement) Truth() skylark.Bool         { return skylark.True }
func (t NodeSelectorRequirement) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t NodeSelectorRequirement) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*NodeSelectorRequirement)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t NodeSelectorRequirement) AttrNames() []string { return NodeSelectorRequirement_attrs }
func (t NodeSelectorRequirement) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, NodeSelectorRequirement_fields, NodeSelectorRequirement_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type NodeSelectorTerm struct {
	V *v1.NodeSelectorTerm
}

var (
	_ boxed = (*NodeSelectorTerm)(nil)

	NodeSelectorTerm_fields = map[string]util.FieldSpec{}
	NodeSelectorTerm_inline = map[string]util.FieldSpec{}
	NodeSelectorTerm_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.NodeSelectorTerm)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.NodeSelectorTerm:
			return NodeSelectorTerm{V: v}
		case v1.NodeSelectorTerm:
			return NodeSelectorTerm{V: &v}
		default:
			return skylark.None
		}
	}
	NodeSelectorTerm_attrs = setFieldTypes(t, NodeSelectorTerm_fields, NodeSelectorTerm_inline)
	Library["NodeSelectorTerm"] = skylark.NewBuiltin("NodeSelectorTerm", createNodeSelectorTerm)
}

func createNodeSelectorTerm(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for NodeSelectorTerm
}
func (t NodeSelectorTerm) UnderlyingKind() interface{} { return t.V }
func (t NodeSelectorTerm) Package() util.Package       { return util.V1 }
func (t NodeSelectorTerm) Type() string                { return "k8s_v1_NodeSelectorTerm" }
func (t NodeSelectorTerm) String() string              { return t.V.String() }
func (t NodeSelectorTerm) Freeze()                     {} // TODO
func (t NodeSelectorTerm) Truth() skylark.Bool         { return skylark.True }
func (t NodeSelectorTerm) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t NodeSelectorTerm) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*NodeSelectorTerm)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t NodeSelectorTerm) AttrNames() []string { return NodeSelectorTerm_attrs }
func (t NodeSelectorTerm) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, NodeSelectorTerm_fields, NodeSelectorTerm_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type NodeSpec struct {
	V *v1.NodeSpec
}

var (
	_ boxed = (*NodeSpec)(nil)

	NodeSpec_fields = map[string]util.FieldSpec{}
	NodeSpec_inline = map[string]util.FieldSpec{}
	NodeSpec_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.NodeSpec)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.NodeSpec:
			return NodeSpec{V: v}
		case v1.NodeSpec:
			return NodeSpec{V: &v}
		default:
			return skylark.None
		}
	}
	NodeSpec_attrs = setFieldTypes(t, NodeSpec_fields, NodeSpec_inline)
	Library["NodeSpec"] = skylark.NewBuiltin("NodeSpec", createNodeSpec)
}

func createNodeSpec(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for NodeSpec
}
func (t NodeSpec) UnderlyingKind() interface{} { return t.V }
func (t NodeSpec) Package() util.Package       { return util.V1 }
func (t NodeSpec) Type() string                { return "k8s_v1_NodeSpec" }
func (t NodeSpec) String() string              { return t.V.String() }
func (t NodeSpec) Freeze()                     {} // TODO
func (t NodeSpec) Truth() skylark.Bool         { return skylark.True }
func (t NodeSpec) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t NodeSpec) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*NodeSpec)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t NodeSpec) AttrNames() []string { return NodeSpec_attrs }
func (t NodeSpec) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, NodeSpec_fields, NodeSpec_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type NodeStatus struct {
	V *v1.NodeStatus
}

var (
	_ boxed = (*NodeStatus)(nil)

	NodeStatus_fields = map[string]util.FieldSpec{}
	NodeStatus_inline = map[string]util.FieldSpec{}
	NodeStatus_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.NodeStatus)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.NodeStatus:
			return NodeStatus{V: v}
		case v1.NodeStatus:
			return NodeStatus{V: &v}
		default:
			return skylark.None
		}
	}
	NodeStatus_attrs = setFieldTypes(t, NodeStatus_fields, NodeStatus_inline)
	Library["NodeStatus"] = skylark.NewBuiltin("NodeStatus", createNodeStatus)
}

func createNodeStatus(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for NodeStatus
}
func (t NodeStatus) UnderlyingKind() interface{} { return t.V }
func (t NodeStatus) Package() util.Package       { return util.V1 }
func (t NodeStatus) Type() string                { return "k8s_v1_NodeStatus" }
func (t NodeStatus) String() string              { return t.V.String() }
func (t NodeStatus) Freeze()                     {} // TODO
func (t NodeStatus) Truth() skylark.Bool         { return skylark.True }
func (t NodeStatus) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t NodeStatus) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*NodeStatus)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t NodeStatus) AttrNames() []string { return NodeStatus_attrs }
func (t NodeStatus) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, NodeStatus_fields, NodeStatus_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type NodeSystemInfo struct {
	V *v1.NodeSystemInfo
}

var (
	_ boxed = (*NodeSystemInfo)(nil)

	NodeSystemInfo_fields = map[string]util.FieldSpec{}
	NodeSystemInfo_inline = map[string]util.FieldSpec{}
	NodeSystemInfo_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.NodeSystemInfo)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.NodeSystemInfo:
			return NodeSystemInfo{V: v}
		case v1.NodeSystemInfo:
			return NodeSystemInfo{V: &v}
		default:
			return skylark.None
		}
	}
	NodeSystemInfo_attrs = setFieldTypes(t, NodeSystemInfo_fields, NodeSystemInfo_inline)
	Library["NodeSystemInfo"] = skylark.NewBuiltin("NodeSystemInfo", createNodeSystemInfo)
}

func createNodeSystemInfo(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for NodeSystemInfo
}
func (t NodeSystemInfo) UnderlyingKind() interface{} { return t.V }
func (t NodeSystemInfo) Package() util.Package       { return util.V1 }
func (t NodeSystemInfo) Type() string                { return "k8s_v1_NodeSystemInfo" }
func (t NodeSystemInfo) String() string              { return t.V.String() }
func (t NodeSystemInfo) Freeze()                     {} // TODO
func (t NodeSystemInfo) Truth() skylark.Bool         { return skylark.True }
func (t NodeSystemInfo) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t NodeSystemInfo) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*NodeSystemInfo)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t NodeSystemInfo) AttrNames() []string { return NodeSystemInfo_attrs }
func (t NodeSystemInfo) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, NodeSystemInfo_fields, NodeSystemInfo_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type ObjectFieldSelector struct {
	V *v1.ObjectFieldSelector
}

var (
	_ boxed = (*ObjectFieldSelector)(nil)

	ObjectFieldSelector_fields = map[string]util.FieldSpec{}
	ObjectFieldSelector_inline = map[string]util.FieldSpec{}
	ObjectFieldSelector_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.ObjectFieldSelector)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.ObjectFieldSelector:
			return ObjectFieldSelector{V: v}
		case v1.ObjectFieldSelector:
			return ObjectFieldSelector{V: &v}
		default:
			return skylark.None
		}
	}
	ObjectFieldSelector_attrs = setFieldTypes(t, ObjectFieldSelector_fields, ObjectFieldSelector_inline)
	Library["ObjectFieldSelector"] = skylark.NewBuiltin("ObjectFieldSelector", createObjectFieldSelector)
}

func createObjectFieldSelector(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for ObjectFieldSelector
}
func (t ObjectFieldSelector) UnderlyingKind() interface{} { return t.V }
func (t ObjectFieldSelector) Package() util.Package       { return util.V1 }
func (t ObjectFieldSelector) Type() string                { return "k8s_v1_ObjectFieldSelector" }
func (t ObjectFieldSelector) String() string              { return t.V.String() }
func (t ObjectFieldSelector) Freeze()                     {} // TODO
func (t ObjectFieldSelector) Truth() skylark.Bool         { return skylark.True }
func (t ObjectFieldSelector) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t ObjectFieldSelector) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ObjectFieldSelector)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ObjectFieldSelector) AttrNames() []string { return ObjectFieldSelector_attrs }
func (t ObjectFieldSelector) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, ObjectFieldSelector_fields, ObjectFieldSelector_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type ObjectReference struct {
	V *v1.ObjectReference
}

var (
	_ boxed = (*ObjectReference)(nil)

	ObjectReference_fields = map[string]util.FieldSpec{}
	ObjectReference_inline = map[string]util.FieldSpec{}
	ObjectReference_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.ObjectReference)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.ObjectReference:
			return ObjectReference{V: v}
		case v1.ObjectReference:
			return ObjectReference{V: &v}
		default:
			return skylark.None
		}
	}
	ObjectReference_attrs = setFieldTypes(t, ObjectReference_fields, ObjectReference_inline)
	Library["ObjectReference"] = skylark.NewBuiltin("ObjectReference", createObjectReference)
}

func createObjectReference(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for ObjectReference
}
func (t ObjectReference) UnderlyingKind() interface{} { return t.V }
func (t ObjectReference) Package() util.Package       { return util.V1 }
func (t ObjectReference) Type() string                { return "k8s_v1_ObjectReference" }
func (t ObjectReference) String() string              { return t.V.String() }
func (t ObjectReference) Freeze()                     {} // TODO
func (t ObjectReference) Truth() skylark.Bool         { return skylark.True }
func (t ObjectReference) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t ObjectReference) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ObjectReference)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ObjectReference) AttrNames() []string { return ObjectReference_attrs }
func (t ObjectReference) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, ObjectReference_fields, ObjectReference_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type PersistentVolume struct {
	V *v1.PersistentVolume
}

var (
	_ boxed = (*PersistentVolume)(nil)

	PersistentVolume_fields = map[string]util.FieldSpec{}
	PersistentVolume_inline = map[string]util.FieldSpec{}
	PersistentVolume_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.PersistentVolume)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.PersistentVolume:
			return PersistentVolume{V: v}
		case v1.PersistentVolume:
			return PersistentVolume{V: &v}
		default:
			return skylark.None
		}
	}
	PersistentVolume_attrs = setFieldTypes(t, PersistentVolume_fields, PersistentVolume_inline)
	Library["PersistentVolume"] = skylark.NewBuiltin("PersistentVolume", createPersistentVolume)
}

func createPersistentVolume(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for PersistentVolume
}
func (t PersistentVolume) UnderlyingKind() interface{} { return t.V }
func (t PersistentVolume) Package() util.Package       { return util.V1 }
func (t PersistentVolume) Type() string                { return "k8s_v1_PersistentVolume" }
func (t PersistentVolume) String() string              { return t.V.String() }
func (t PersistentVolume) Freeze()                     {} // TODO
func (t PersistentVolume) Truth() skylark.Bool         { return skylark.True }
func (t PersistentVolume) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t PersistentVolume) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PersistentVolume)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PersistentVolume) AttrNames() []string { return PersistentVolume_attrs }
func (t PersistentVolume) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, PersistentVolume_fields, PersistentVolume_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type PersistentVolumeClaim struct {
	V *v1.PersistentVolumeClaim
}

var (
	_ boxed = (*PersistentVolumeClaim)(nil)

	PersistentVolumeClaim_fields = map[string]util.FieldSpec{}
	PersistentVolumeClaim_inline = map[string]util.FieldSpec{}
	PersistentVolumeClaim_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.PersistentVolumeClaim)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.PersistentVolumeClaim:
			return PersistentVolumeClaim{V: v}
		case v1.PersistentVolumeClaim:
			return PersistentVolumeClaim{V: &v}
		default:
			return skylark.None
		}
	}
	PersistentVolumeClaim_attrs = setFieldTypes(t, PersistentVolumeClaim_fields, PersistentVolumeClaim_inline)
	Library["PersistentVolumeClaim"] = skylark.NewBuiltin("PersistentVolumeClaim", createPersistentVolumeClaim)
}

func createPersistentVolumeClaim(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for PersistentVolumeClaim
}
func (t PersistentVolumeClaim) UnderlyingKind() interface{} { return t.V }
func (t PersistentVolumeClaim) Package() util.Package       { return util.V1 }
func (t PersistentVolumeClaim) Type() string                { return "k8s_v1_PersistentVolumeClaim" }
func (t PersistentVolumeClaim) String() string              { return t.V.String() }
func (t PersistentVolumeClaim) Freeze()                     {} // TODO
func (t PersistentVolumeClaim) Truth() skylark.Bool         { return skylark.True }
func (t PersistentVolumeClaim) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t PersistentVolumeClaim) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PersistentVolumeClaim)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PersistentVolumeClaim) AttrNames() []string { return PersistentVolumeClaim_attrs }
func (t PersistentVolumeClaim) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, PersistentVolumeClaim_fields, PersistentVolumeClaim_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type PersistentVolumeClaimCondition struct {
	V *v1.PersistentVolumeClaimCondition
}

var (
	_ boxed = (*PersistentVolumeClaimCondition)(nil)

	PersistentVolumeClaimCondition_fields = map[string]util.FieldSpec{}
	PersistentVolumeClaimCondition_inline = map[string]util.FieldSpec{}
	PersistentVolumeClaimCondition_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.PersistentVolumeClaimCondition)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.PersistentVolumeClaimCondition:
			return PersistentVolumeClaimCondition{V: v}
		case v1.PersistentVolumeClaimCondition:
			return PersistentVolumeClaimCondition{V: &v}
		default:
			return skylark.None
		}
	}
	PersistentVolumeClaimCondition_attrs = setFieldTypes(t, PersistentVolumeClaimCondition_fields, PersistentVolumeClaimCondition_inline)
	Library["PersistentVolumeClaimCondition"] = skylark.NewBuiltin("PersistentVolumeClaimCondition", createPersistentVolumeClaimCondition)
}

func createPersistentVolumeClaimCondition(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for PersistentVolumeClaimCondition
}
func (t PersistentVolumeClaimCondition) UnderlyingKind() interface{} { return t.V }
func (t PersistentVolumeClaimCondition) Package() util.Package       { return util.V1 }
func (t PersistentVolumeClaimCondition) Type() string                { return "k8s_v1_PersistentVolumeClaimCondition" }
func (t PersistentVolumeClaimCondition) String() string              { return t.V.String() }
func (t PersistentVolumeClaimCondition) Freeze()                     {} // TODO
func (t PersistentVolumeClaimCondition) Truth() skylark.Bool         { return skylark.True }
func (t PersistentVolumeClaimCondition) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t PersistentVolumeClaimCondition) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PersistentVolumeClaimCondition)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PersistentVolumeClaimCondition) AttrNames() []string {
	return PersistentVolumeClaimCondition_attrs
}
func (t PersistentVolumeClaimCondition) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, PersistentVolumeClaimCondition_fields, PersistentVolumeClaimCondition_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type PersistentVolumeClaimList struct {
	V *v1.PersistentVolumeClaimList
}

var (
	_ boxed = (*PersistentVolumeClaimList)(nil)

	PersistentVolumeClaimList_fields = map[string]util.FieldSpec{}
	PersistentVolumeClaimList_inline = map[string]util.FieldSpec{}
	PersistentVolumeClaimList_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.PersistentVolumeClaimList)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.PersistentVolumeClaimList:
			return PersistentVolumeClaimList{V: v}
		case v1.PersistentVolumeClaimList:
			return PersistentVolumeClaimList{V: &v}
		default:
			return skylark.None
		}
	}
	PersistentVolumeClaimList_attrs = setFieldTypes(t, PersistentVolumeClaimList_fields, PersistentVolumeClaimList_inline)
	Library["PersistentVolumeClaimList"] = skylark.NewBuiltin("PersistentVolumeClaimList", createPersistentVolumeClaimList)
}

func createPersistentVolumeClaimList(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for PersistentVolumeClaimList
}
func (t PersistentVolumeClaimList) UnderlyingKind() interface{} { return t.V }
func (t PersistentVolumeClaimList) Package() util.Package       { return util.V1 }
func (t PersistentVolumeClaimList) Type() string                { return "k8s_v1_PersistentVolumeClaimList" }
func (t PersistentVolumeClaimList) String() string              { return t.V.String() }
func (t PersistentVolumeClaimList) Freeze()                     {} // TODO
func (t PersistentVolumeClaimList) Truth() skylark.Bool         { return skylark.True }
func (t PersistentVolumeClaimList) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t PersistentVolumeClaimList) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PersistentVolumeClaimList)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PersistentVolumeClaimList) AttrNames() []string { return PersistentVolumeClaimList_attrs }
func (t PersistentVolumeClaimList) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, PersistentVolumeClaimList_fields, PersistentVolumeClaimList_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type PersistentVolumeClaimSpec struct {
	V *v1.PersistentVolumeClaimSpec
}

var (
	_ boxed = (*PersistentVolumeClaimSpec)(nil)

	PersistentVolumeClaimSpec_fields = map[string]util.FieldSpec{}
	PersistentVolumeClaimSpec_inline = map[string]util.FieldSpec{}
	PersistentVolumeClaimSpec_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.PersistentVolumeClaimSpec)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.PersistentVolumeClaimSpec:
			return PersistentVolumeClaimSpec{V: v}
		case v1.PersistentVolumeClaimSpec:
			return PersistentVolumeClaimSpec{V: &v}
		default:
			return skylark.None
		}
	}
	PersistentVolumeClaimSpec_attrs = setFieldTypes(t, PersistentVolumeClaimSpec_fields, PersistentVolumeClaimSpec_inline)
	Library["PersistentVolumeClaimSpec"] = skylark.NewBuiltin("PersistentVolumeClaimSpec", createPersistentVolumeClaimSpec)
}

func createPersistentVolumeClaimSpec(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for PersistentVolumeClaimSpec
}
func (t PersistentVolumeClaimSpec) UnderlyingKind() interface{} { return t.V }
func (t PersistentVolumeClaimSpec) Package() util.Package       { return util.V1 }
func (t PersistentVolumeClaimSpec) Type() string                { return "k8s_v1_PersistentVolumeClaimSpec" }
func (t PersistentVolumeClaimSpec) String() string              { return t.V.String() }
func (t PersistentVolumeClaimSpec) Freeze()                     {} // TODO
func (t PersistentVolumeClaimSpec) Truth() skylark.Bool         { return skylark.True }
func (t PersistentVolumeClaimSpec) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t PersistentVolumeClaimSpec) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PersistentVolumeClaimSpec)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PersistentVolumeClaimSpec) AttrNames() []string { return PersistentVolumeClaimSpec_attrs }
func (t PersistentVolumeClaimSpec) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, PersistentVolumeClaimSpec_fields, PersistentVolumeClaimSpec_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type PersistentVolumeClaimStatus struct {
	V *v1.PersistentVolumeClaimStatus
}

var (
	_ boxed = (*PersistentVolumeClaimStatus)(nil)

	PersistentVolumeClaimStatus_fields = map[string]util.FieldSpec{}
	PersistentVolumeClaimStatus_inline = map[string]util.FieldSpec{}
	PersistentVolumeClaimStatus_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.PersistentVolumeClaimStatus)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.PersistentVolumeClaimStatus:
			return PersistentVolumeClaimStatus{V: v}
		case v1.PersistentVolumeClaimStatus:
			return PersistentVolumeClaimStatus{V: &v}
		default:
			return skylark.None
		}
	}
	PersistentVolumeClaimStatus_attrs = setFieldTypes(t, PersistentVolumeClaimStatus_fields, PersistentVolumeClaimStatus_inline)
	Library["PersistentVolumeClaimStatus"] = skylark.NewBuiltin("PersistentVolumeClaimStatus", createPersistentVolumeClaimStatus)
}

func createPersistentVolumeClaimStatus(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for PersistentVolumeClaimStatus
}
func (t PersistentVolumeClaimStatus) UnderlyingKind() interface{} { return t.V }
func (t PersistentVolumeClaimStatus) Package() util.Package       { return util.V1 }
func (t PersistentVolumeClaimStatus) Type() string                { return "k8s_v1_PersistentVolumeClaimStatus" }
func (t PersistentVolumeClaimStatus) String() string              { return t.V.String() }
func (t PersistentVolumeClaimStatus) Freeze()                     {} // TODO
func (t PersistentVolumeClaimStatus) Truth() skylark.Bool         { return skylark.True }
func (t PersistentVolumeClaimStatus) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t PersistentVolumeClaimStatus) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PersistentVolumeClaimStatus)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PersistentVolumeClaimStatus) AttrNames() []string { return PersistentVolumeClaimStatus_attrs }
func (t PersistentVolumeClaimStatus) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, PersistentVolumeClaimStatus_fields, PersistentVolumeClaimStatus_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type PersistentVolumeClaimVolumeSource struct {
	V *v1.PersistentVolumeClaimVolumeSource
}

var (
	_ boxed = (*PersistentVolumeClaimVolumeSource)(nil)

	PersistentVolumeClaimVolumeSource_fields = map[string]util.FieldSpec{}
	PersistentVolumeClaimVolumeSource_inline = map[string]util.FieldSpec{}
	PersistentVolumeClaimVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.PersistentVolumeClaimVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.PersistentVolumeClaimVolumeSource:
			return PersistentVolumeClaimVolumeSource{V: v}
		case v1.PersistentVolumeClaimVolumeSource:
			return PersistentVolumeClaimVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	PersistentVolumeClaimVolumeSource_attrs = setFieldTypes(t, PersistentVolumeClaimVolumeSource_fields, PersistentVolumeClaimVolumeSource_inline)
	Library["PersistentVolumeClaimVolumeSource"] = skylark.NewBuiltin("PersistentVolumeClaimVolumeSource", createPersistentVolumeClaimVolumeSource)
}

func createPersistentVolumeClaimVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for PersistentVolumeClaimVolumeSource
}
func (t PersistentVolumeClaimVolumeSource) UnderlyingKind() interface{} { return t.V }
func (t PersistentVolumeClaimVolumeSource) Package() util.Package       { return util.V1 }
func (t PersistentVolumeClaimVolumeSource) Type() string {
	return "k8s_v1_PersistentVolumeClaimVolumeSource"
}
func (t PersistentVolumeClaimVolumeSource) String() string        { return t.V.String() }
func (t PersistentVolumeClaimVolumeSource) Freeze()               {} // TODO
func (t PersistentVolumeClaimVolumeSource) Truth() skylark.Bool   { return skylark.True }
func (t PersistentVolumeClaimVolumeSource) Hash() (uint32, error) { return 0, unhashable(t.Type()) }
func (t PersistentVolumeClaimVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PersistentVolumeClaimVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PersistentVolumeClaimVolumeSource) AttrNames() []string {
	return PersistentVolumeClaimVolumeSource_attrs
}
func (t PersistentVolumeClaimVolumeSource) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, PersistentVolumeClaimVolumeSource_fields, PersistentVolumeClaimVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type PersistentVolumeList struct {
	V *v1.PersistentVolumeList
}

var (
	_ boxed = (*PersistentVolumeList)(nil)

	PersistentVolumeList_fields = map[string]util.FieldSpec{}
	PersistentVolumeList_inline = map[string]util.FieldSpec{}
	PersistentVolumeList_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.PersistentVolumeList)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.PersistentVolumeList:
			return PersistentVolumeList{V: v}
		case v1.PersistentVolumeList:
			return PersistentVolumeList{V: &v}
		default:
			return skylark.None
		}
	}
	PersistentVolumeList_attrs = setFieldTypes(t, PersistentVolumeList_fields, PersistentVolumeList_inline)
	Library["PersistentVolumeList"] = skylark.NewBuiltin("PersistentVolumeList", createPersistentVolumeList)
}

func createPersistentVolumeList(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for PersistentVolumeList
}
func (t PersistentVolumeList) UnderlyingKind() interface{} { return t.V }
func (t PersistentVolumeList) Package() util.Package       { return util.V1 }
func (t PersistentVolumeList) Type() string                { return "k8s_v1_PersistentVolumeList" }
func (t PersistentVolumeList) String() string              { return t.V.String() }
func (t PersistentVolumeList) Freeze()                     {} // TODO
func (t PersistentVolumeList) Truth() skylark.Bool         { return skylark.True }
func (t PersistentVolumeList) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t PersistentVolumeList) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PersistentVolumeList)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PersistentVolumeList) AttrNames() []string { return PersistentVolumeList_attrs }
func (t PersistentVolumeList) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, PersistentVolumeList_fields, PersistentVolumeList_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type PersistentVolumeSource struct {
	V *v1.PersistentVolumeSource
}

var (
	_ boxed = (*PersistentVolumeSource)(nil)

	PersistentVolumeSource_fields = map[string]util.FieldSpec{}
	PersistentVolumeSource_inline = map[string]util.FieldSpec{}
	PersistentVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.PersistentVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.PersistentVolumeSource:
			return PersistentVolumeSource{V: v}
		case v1.PersistentVolumeSource:
			return PersistentVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	PersistentVolumeSource_attrs = setFieldTypes(t, PersistentVolumeSource_fields, PersistentVolumeSource_inline)
	Library["PersistentVolumeSource"] = skylark.NewBuiltin("PersistentVolumeSource", createPersistentVolumeSource)
}

func createPersistentVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for PersistentVolumeSource
}
func (t PersistentVolumeSource) UnderlyingKind() interface{} { return t.V }
func (t PersistentVolumeSource) Package() util.Package       { return util.V1 }
func (t PersistentVolumeSource) Type() string                { return "k8s_v1_PersistentVolumeSource" }
func (t PersistentVolumeSource) String() string              { return t.V.String() }
func (t PersistentVolumeSource) Freeze()                     {} // TODO
func (t PersistentVolumeSource) Truth() skylark.Bool         { return skylark.True }
func (t PersistentVolumeSource) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t PersistentVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PersistentVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PersistentVolumeSource) AttrNames() []string { return PersistentVolumeSource_attrs }
func (t PersistentVolumeSource) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, PersistentVolumeSource_fields, PersistentVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type PersistentVolumeSpec struct {
	V *v1.PersistentVolumeSpec
}

var (
	_ boxed = (*PersistentVolumeSpec)(nil)

	PersistentVolumeSpec_fields = map[string]util.FieldSpec{}
	PersistentVolumeSpec_inline = map[string]util.FieldSpec{}
	PersistentVolumeSpec_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.PersistentVolumeSpec)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.PersistentVolumeSpec:
			return PersistentVolumeSpec{V: v}
		case v1.PersistentVolumeSpec:
			return PersistentVolumeSpec{V: &v}
		default:
			return skylark.None
		}
	}
	PersistentVolumeSpec_attrs = setFieldTypes(t, PersistentVolumeSpec_fields, PersistentVolumeSpec_inline)
	Library["PersistentVolumeSpec"] = skylark.NewBuiltin("PersistentVolumeSpec", createPersistentVolumeSpec)
}

func createPersistentVolumeSpec(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for PersistentVolumeSpec
}
func (t PersistentVolumeSpec) UnderlyingKind() interface{} { return t.V }
func (t PersistentVolumeSpec) Package() util.Package       { return util.V1 }
func (t PersistentVolumeSpec) Type() string                { return "k8s_v1_PersistentVolumeSpec" }
func (t PersistentVolumeSpec) String() string              { return t.V.String() }
func (t PersistentVolumeSpec) Freeze()                     {} // TODO
func (t PersistentVolumeSpec) Truth() skylark.Bool         { return skylark.True }
func (t PersistentVolumeSpec) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t PersistentVolumeSpec) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PersistentVolumeSpec)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PersistentVolumeSpec) AttrNames() []string { return PersistentVolumeSpec_attrs }
func (t PersistentVolumeSpec) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, PersistentVolumeSpec_fields, PersistentVolumeSpec_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type PersistentVolumeStatus struct {
	V *v1.PersistentVolumeStatus
}

var (
	_ boxed = (*PersistentVolumeStatus)(nil)

	PersistentVolumeStatus_fields = map[string]util.FieldSpec{}
	PersistentVolumeStatus_inline = map[string]util.FieldSpec{}
	PersistentVolumeStatus_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.PersistentVolumeStatus)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.PersistentVolumeStatus:
			return PersistentVolumeStatus{V: v}
		case v1.PersistentVolumeStatus:
			return PersistentVolumeStatus{V: &v}
		default:
			return skylark.None
		}
	}
	PersistentVolumeStatus_attrs = setFieldTypes(t, PersistentVolumeStatus_fields, PersistentVolumeStatus_inline)
	Library["PersistentVolumeStatus"] = skylark.NewBuiltin("PersistentVolumeStatus", createPersistentVolumeStatus)
}

func createPersistentVolumeStatus(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for PersistentVolumeStatus
}
func (t PersistentVolumeStatus) UnderlyingKind() interface{} { return t.V }
func (t PersistentVolumeStatus) Package() util.Package       { return util.V1 }
func (t PersistentVolumeStatus) Type() string                { return "k8s_v1_PersistentVolumeStatus" }
func (t PersistentVolumeStatus) String() string              { return t.V.String() }
func (t PersistentVolumeStatus) Freeze()                     {} // TODO
func (t PersistentVolumeStatus) Truth() skylark.Bool         { return skylark.True }
func (t PersistentVolumeStatus) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t PersistentVolumeStatus) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PersistentVolumeStatus)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PersistentVolumeStatus) AttrNames() []string { return PersistentVolumeStatus_attrs }
func (t PersistentVolumeStatus) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, PersistentVolumeStatus_fields, PersistentVolumeStatus_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type PhotonPersistentDiskVolumeSource struct {
	V *v1.PhotonPersistentDiskVolumeSource
}

var (
	_ boxed = (*PhotonPersistentDiskVolumeSource)(nil)

	PhotonPersistentDiskVolumeSource_fields = map[string]util.FieldSpec{}
	PhotonPersistentDiskVolumeSource_inline = map[string]util.FieldSpec{}
	PhotonPersistentDiskVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.PhotonPersistentDiskVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.PhotonPersistentDiskVolumeSource:
			return PhotonPersistentDiskVolumeSource{V: v}
		case v1.PhotonPersistentDiskVolumeSource:
			return PhotonPersistentDiskVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	PhotonPersistentDiskVolumeSource_attrs = setFieldTypes(t, PhotonPersistentDiskVolumeSource_fields, PhotonPersistentDiskVolumeSource_inline)
	Library["PhotonPersistentDiskVolumeSource"] = skylark.NewBuiltin("PhotonPersistentDiskVolumeSource", createPhotonPersistentDiskVolumeSource)
}

func createPhotonPersistentDiskVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for PhotonPersistentDiskVolumeSource
}
func (t PhotonPersistentDiskVolumeSource) UnderlyingKind() interface{} { return t.V }
func (t PhotonPersistentDiskVolumeSource) Package() util.Package       { return util.V1 }
func (t PhotonPersistentDiskVolumeSource) Type() string {
	return "k8s_v1_PhotonPersistentDiskVolumeSource"
}
func (t PhotonPersistentDiskVolumeSource) String() string        { return t.V.String() }
func (t PhotonPersistentDiskVolumeSource) Freeze()               {} // TODO
func (t PhotonPersistentDiskVolumeSource) Truth() skylark.Bool   { return skylark.True }
func (t PhotonPersistentDiskVolumeSource) Hash() (uint32, error) { return 0, unhashable(t.Type()) }
func (t PhotonPersistentDiskVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PhotonPersistentDiskVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PhotonPersistentDiskVolumeSource) AttrNames() []string {
	return PhotonPersistentDiskVolumeSource_attrs
}
func (t PhotonPersistentDiskVolumeSource) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, PhotonPersistentDiskVolumeSource_fields, PhotonPersistentDiskVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type Pod struct {
	V *v1.Pod
}

var (
	_ boxed = (*Pod)(nil)

	Pod_fields = map[string]util.FieldSpec{}
	Pod_inline = map[string]util.FieldSpec{}
	Pod_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.Pod)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.Pod:
			return Pod{V: v}
		case v1.Pod:
			return Pod{V: &v}
		default:
			return skylark.None
		}
	}
	Pod_attrs = setFieldTypes(t, Pod_fields, Pod_inline)
	Library["Pod"] = skylark.NewBuiltin("Pod", createPod)
}

func createPod(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for Pod
}
func (t Pod) UnderlyingKind() interface{} { return t.V }
func (t Pod) Package() util.Package       { return util.V1 }
func (t Pod) Type() string                { return "k8s_v1_Pod" }
func (t Pod) String() string              { return t.V.String() }
func (t Pod) Freeze()                     {} // TODO
func (t Pod) Truth() skylark.Bool         { return skylark.True }
func (t Pod) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t Pod) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*Pod)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t Pod) AttrNames() []string { return Pod_attrs }
func (t Pod) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, Pod_fields, Pod_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type PodAffinity struct {
	V *v1.PodAffinity
}

var (
	_ boxed = (*PodAffinity)(nil)

	PodAffinity_fields = map[string]util.FieldSpec{}
	PodAffinity_inline = map[string]util.FieldSpec{}
	PodAffinity_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.PodAffinity)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.PodAffinity:
			return PodAffinity{V: v}
		case v1.PodAffinity:
			return PodAffinity{V: &v}
		default:
			return skylark.None
		}
	}
	PodAffinity_attrs = setFieldTypes(t, PodAffinity_fields, PodAffinity_inline)
	Library["PodAffinity"] = skylark.NewBuiltin("PodAffinity", createPodAffinity)
}

func createPodAffinity(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for PodAffinity
}
func (t PodAffinity) UnderlyingKind() interface{} { return t.V }
func (t PodAffinity) Package() util.Package       { return util.V1 }
func (t PodAffinity) Type() string                { return "k8s_v1_PodAffinity" }
func (t PodAffinity) String() string              { return t.V.String() }
func (t PodAffinity) Freeze()                     {} // TODO
func (t PodAffinity) Truth() skylark.Bool         { return skylark.True }
func (t PodAffinity) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t PodAffinity) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PodAffinity)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PodAffinity) AttrNames() []string { return PodAffinity_attrs }
func (t PodAffinity) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, PodAffinity_fields, PodAffinity_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type PodAffinityTerm struct {
	V *v1.PodAffinityTerm
}

var (
	_ boxed = (*PodAffinityTerm)(nil)

	PodAffinityTerm_fields = map[string]util.FieldSpec{}
	PodAffinityTerm_inline = map[string]util.FieldSpec{}
	PodAffinityTerm_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.PodAffinityTerm)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.PodAffinityTerm:
			return PodAffinityTerm{V: v}
		case v1.PodAffinityTerm:
			return PodAffinityTerm{V: &v}
		default:
			return skylark.None
		}
	}
	PodAffinityTerm_attrs = setFieldTypes(t, PodAffinityTerm_fields, PodAffinityTerm_inline)
	Library["PodAffinityTerm"] = skylark.NewBuiltin("PodAffinityTerm", createPodAffinityTerm)
}

func createPodAffinityTerm(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for PodAffinityTerm
}
func (t PodAffinityTerm) UnderlyingKind() interface{} { return t.V }
func (t PodAffinityTerm) Package() util.Package       { return util.V1 }
func (t PodAffinityTerm) Type() string                { return "k8s_v1_PodAffinityTerm" }
func (t PodAffinityTerm) String() string              { return t.V.String() }
func (t PodAffinityTerm) Freeze()                     {} // TODO
func (t PodAffinityTerm) Truth() skylark.Bool         { return skylark.True }
func (t PodAffinityTerm) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t PodAffinityTerm) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PodAffinityTerm)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PodAffinityTerm) AttrNames() []string { return PodAffinityTerm_attrs }
func (t PodAffinityTerm) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, PodAffinityTerm_fields, PodAffinityTerm_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type PodAntiAffinity struct {
	V *v1.PodAntiAffinity
}

var (
	_ boxed = (*PodAntiAffinity)(nil)

	PodAntiAffinity_fields = map[string]util.FieldSpec{}
	PodAntiAffinity_inline = map[string]util.FieldSpec{}
	PodAntiAffinity_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.PodAntiAffinity)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.PodAntiAffinity:
			return PodAntiAffinity{V: v}
		case v1.PodAntiAffinity:
			return PodAntiAffinity{V: &v}
		default:
			return skylark.None
		}
	}
	PodAntiAffinity_attrs = setFieldTypes(t, PodAntiAffinity_fields, PodAntiAffinity_inline)
	Library["PodAntiAffinity"] = skylark.NewBuiltin("PodAntiAffinity", createPodAntiAffinity)
}

func createPodAntiAffinity(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for PodAntiAffinity
}
func (t PodAntiAffinity) UnderlyingKind() interface{} { return t.V }
func (t PodAntiAffinity) Package() util.Package       { return util.V1 }
func (t PodAntiAffinity) Type() string                { return "k8s_v1_PodAntiAffinity" }
func (t PodAntiAffinity) String() string              { return t.V.String() }
func (t PodAntiAffinity) Freeze()                     {} // TODO
func (t PodAntiAffinity) Truth() skylark.Bool         { return skylark.True }
func (t PodAntiAffinity) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t PodAntiAffinity) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PodAntiAffinity)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PodAntiAffinity) AttrNames() []string { return PodAntiAffinity_attrs }
func (t PodAntiAffinity) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, PodAntiAffinity_fields, PodAntiAffinity_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type PodAttachOptions struct {
	V *v1.PodAttachOptions
}

var (
	_ boxed = (*PodAttachOptions)(nil)

	PodAttachOptions_fields = map[string]util.FieldSpec{}
	PodAttachOptions_inline = map[string]util.FieldSpec{}
	PodAttachOptions_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.PodAttachOptions)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.PodAttachOptions:
			return PodAttachOptions{V: v}
		case v1.PodAttachOptions:
			return PodAttachOptions{V: &v}
		default:
			return skylark.None
		}
	}
	PodAttachOptions_attrs = setFieldTypes(t, PodAttachOptions_fields, PodAttachOptions_inline)
	Library["PodAttachOptions"] = skylark.NewBuiltin("PodAttachOptions", createPodAttachOptions)
}

func createPodAttachOptions(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for PodAttachOptions
}
func (t PodAttachOptions) UnderlyingKind() interface{} { return t.V }
func (t PodAttachOptions) Package() util.Package       { return util.V1 }
func (t PodAttachOptions) Type() string                { return "k8s_v1_PodAttachOptions" }
func (t PodAttachOptions) String() string              { return t.V.String() }
func (t PodAttachOptions) Freeze()                     {} // TODO
func (t PodAttachOptions) Truth() skylark.Bool         { return skylark.True }
func (t PodAttachOptions) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t PodAttachOptions) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PodAttachOptions)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PodAttachOptions) AttrNames() []string { return PodAttachOptions_attrs }
func (t PodAttachOptions) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, PodAttachOptions_fields, PodAttachOptions_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type PodCondition struct {
	V *v1.PodCondition
}

var (
	_ boxed = (*PodCondition)(nil)

	PodCondition_fields = map[string]util.FieldSpec{}
	PodCondition_inline = map[string]util.FieldSpec{}
	PodCondition_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.PodCondition)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.PodCondition:
			return PodCondition{V: v}
		case v1.PodCondition:
			return PodCondition{V: &v}
		default:
			return skylark.None
		}
	}
	PodCondition_attrs = setFieldTypes(t, PodCondition_fields, PodCondition_inline)
	Library["PodCondition"] = skylark.NewBuiltin("PodCondition", createPodCondition)
}

func createPodCondition(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for PodCondition
}
func (t PodCondition) UnderlyingKind() interface{} { return t.V }
func (t PodCondition) Package() util.Package       { return util.V1 }
func (t PodCondition) Type() string                { return "k8s_v1_PodCondition" }
func (t PodCondition) String() string              { return t.V.String() }
func (t PodCondition) Freeze()                     {} // TODO
func (t PodCondition) Truth() skylark.Bool         { return skylark.True }
func (t PodCondition) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t PodCondition) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PodCondition)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PodCondition) AttrNames() []string { return PodCondition_attrs }
func (t PodCondition) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, PodCondition_fields, PodCondition_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type PodDNSConfig struct {
	V *v1.PodDNSConfig
}

var (
	_ boxed = (*PodDNSConfig)(nil)

	PodDNSConfig_fields = map[string]util.FieldSpec{}
	PodDNSConfig_inline = map[string]util.FieldSpec{}
	PodDNSConfig_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.PodDNSConfig)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.PodDNSConfig:
			return PodDNSConfig{V: v}
		case v1.PodDNSConfig:
			return PodDNSConfig{V: &v}
		default:
			return skylark.None
		}
	}
	PodDNSConfig_attrs = setFieldTypes(t, PodDNSConfig_fields, PodDNSConfig_inline)
	Library["PodDNSConfig"] = skylark.NewBuiltin("PodDNSConfig", createPodDNSConfig)
}

func createPodDNSConfig(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for PodDNSConfig
}
func (t PodDNSConfig) UnderlyingKind() interface{} { return t.V }
func (t PodDNSConfig) Package() util.Package       { return util.V1 }
func (t PodDNSConfig) Type() string                { return "k8s_v1_PodDNSConfig" }
func (t PodDNSConfig) String() string              { return t.V.String() }
func (t PodDNSConfig) Freeze()                     {} // TODO
func (t PodDNSConfig) Truth() skylark.Bool         { return skylark.True }
func (t PodDNSConfig) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t PodDNSConfig) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PodDNSConfig)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PodDNSConfig) AttrNames() []string { return PodDNSConfig_attrs }
func (t PodDNSConfig) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, PodDNSConfig_fields, PodDNSConfig_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type PodDNSConfigOption struct {
	V *v1.PodDNSConfigOption
}

var (
	_ boxed = (*PodDNSConfigOption)(nil)

	PodDNSConfigOption_fields = map[string]util.FieldSpec{}
	PodDNSConfigOption_inline = map[string]util.FieldSpec{}
	PodDNSConfigOption_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.PodDNSConfigOption)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.PodDNSConfigOption:
			return PodDNSConfigOption{V: v}
		case v1.PodDNSConfigOption:
			return PodDNSConfigOption{V: &v}
		default:
			return skylark.None
		}
	}
	PodDNSConfigOption_attrs = setFieldTypes(t, PodDNSConfigOption_fields, PodDNSConfigOption_inline)
	Library["PodDNSConfigOption"] = skylark.NewBuiltin("PodDNSConfigOption", createPodDNSConfigOption)
}

func createPodDNSConfigOption(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for PodDNSConfigOption
}
func (t PodDNSConfigOption) UnderlyingKind() interface{} { return t.V }
func (t PodDNSConfigOption) Package() util.Package       { return util.V1 }
func (t PodDNSConfigOption) Type() string                { return "k8s_v1_PodDNSConfigOption" }
func (t PodDNSConfigOption) String() string              { return t.V.String() }
func (t PodDNSConfigOption) Freeze()                     {} // TODO
func (t PodDNSConfigOption) Truth() skylark.Bool         { return skylark.True }
func (t PodDNSConfigOption) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t PodDNSConfigOption) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PodDNSConfigOption)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PodDNSConfigOption) AttrNames() []string { return PodDNSConfigOption_attrs }
func (t PodDNSConfigOption) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, PodDNSConfigOption_fields, PodDNSConfigOption_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type PodExecOptions struct {
	V *v1.PodExecOptions
}

var (
	_ boxed = (*PodExecOptions)(nil)

	PodExecOptions_fields = map[string]util.FieldSpec{}
	PodExecOptions_inline = map[string]util.FieldSpec{}
	PodExecOptions_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.PodExecOptions)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.PodExecOptions:
			return PodExecOptions{V: v}
		case v1.PodExecOptions:
			return PodExecOptions{V: &v}
		default:
			return skylark.None
		}
	}
	PodExecOptions_attrs = setFieldTypes(t, PodExecOptions_fields, PodExecOptions_inline)
	Library["PodExecOptions"] = skylark.NewBuiltin("PodExecOptions", createPodExecOptions)
}

func createPodExecOptions(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for PodExecOptions
}
func (t PodExecOptions) UnderlyingKind() interface{} { return t.V }
func (t PodExecOptions) Package() util.Package       { return util.V1 }
func (t PodExecOptions) Type() string                { return "k8s_v1_PodExecOptions" }
func (t PodExecOptions) String() string              { return t.V.String() }
func (t PodExecOptions) Freeze()                     {} // TODO
func (t PodExecOptions) Truth() skylark.Bool         { return skylark.True }
func (t PodExecOptions) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t PodExecOptions) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PodExecOptions)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PodExecOptions) AttrNames() []string { return PodExecOptions_attrs }
func (t PodExecOptions) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, PodExecOptions_fields, PodExecOptions_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type PodList struct {
	V *v1.PodList
}

var (
	_ boxed = (*PodList)(nil)

	PodList_fields = map[string]util.FieldSpec{}
	PodList_inline = map[string]util.FieldSpec{}
	PodList_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.PodList)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.PodList:
			return PodList{V: v}
		case v1.PodList:
			return PodList{V: &v}
		default:
			return skylark.None
		}
	}
	PodList_attrs = setFieldTypes(t, PodList_fields, PodList_inline)
	Library["PodList"] = skylark.NewBuiltin("PodList", createPodList)
}

func createPodList(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for PodList
}
func (t PodList) UnderlyingKind() interface{} { return t.V }
func (t PodList) Package() util.Package       { return util.V1 }
func (t PodList) Type() string                { return "k8s_v1_PodList" }
func (t PodList) String() string              { return t.V.String() }
func (t PodList) Freeze()                     {} // TODO
func (t PodList) Truth() skylark.Bool         { return skylark.True }
func (t PodList) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t PodList) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PodList)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PodList) AttrNames() []string { return PodList_attrs }
func (t PodList) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, PodList_fields, PodList_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type PodLogOptions struct {
	V *v1.PodLogOptions
}

var (
	_ boxed = (*PodLogOptions)(nil)

	PodLogOptions_fields = map[string]util.FieldSpec{}
	PodLogOptions_inline = map[string]util.FieldSpec{}
	PodLogOptions_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.PodLogOptions)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.PodLogOptions:
			return PodLogOptions{V: v}
		case v1.PodLogOptions:
			return PodLogOptions{V: &v}
		default:
			return skylark.None
		}
	}
	PodLogOptions_attrs = setFieldTypes(t, PodLogOptions_fields, PodLogOptions_inline)
	Library["PodLogOptions"] = skylark.NewBuiltin("PodLogOptions", createPodLogOptions)
}

func createPodLogOptions(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for PodLogOptions
}
func (t PodLogOptions) UnderlyingKind() interface{} { return t.V }
func (t PodLogOptions) Package() util.Package       { return util.V1 }
func (t PodLogOptions) Type() string                { return "k8s_v1_PodLogOptions" }
func (t PodLogOptions) String() string              { return t.V.String() }
func (t PodLogOptions) Freeze()                     {} // TODO
func (t PodLogOptions) Truth() skylark.Bool         { return skylark.True }
func (t PodLogOptions) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t PodLogOptions) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PodLogOptions)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PodLogOptions) AttrNames() []string { return PodLogOptions_attrs }
func (t PodLogOptions) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, PodLogOptions_fields, PodLogOptions_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type PodPortForwardOptions struct {
	V *v1.PodPortForwardOptions
}

var (
	_ boxed = (*PodPortForwardOptions)(nil)

	PodPortForwardOptions_fields = map[string]util.FieldSpec{}
	PodPortForwardOptions_inline = map[string]util.FieldSpec{}
	PodPortForwardOptions_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.PodPortForwardOptions)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.PodPortForwardOptions:
			return PodPortForwardOptions{V: v}
		case v1.PodPortForwardOptions:
			return PodPortForwardOptions{V: &v}
		default:
			return skylark.None
		}
	}
	PodPortForwardOptions_attrs = setFieldTypes(t, PodPortForwardOptions_fields, PodPortForwardOptions_inline)
	Library["PodPortForwardOptions"] = skylark.NewBuiltin("PodPortForwardOptions", createPodPortForwardOptions)
}

func createPodPortForwardOptions(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for PodPortForwardOptions
}
func (t PodPortForwardOptions) UnderlyingKind() interface{} { return t.V }
func (t PodPortForwardOptions) Package() util.Package       { return util.V1 }
func (t PodPortForwardOptions) Type() string                { return "k8s_v1_PodPortForwardOptions" }
func (t PodPortForwardOptions) String() string              { return t.V.String() }
func (t PodPortForwardOptions) Freeze()                     {} // TODO
func (t PodPortForwardOptions) Truth() skylark.Bool         { return skylark.True }
func (t PodPortForwardOptions) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t PodPortForwardOptions) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PodPortForwardOptions)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PodPortForwardOptions) AttrNames() []string { return PodPortForwardOptions_attrs }
func (t PodPortForwardOptions) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, PodPortForwardOptions_fields, PodPortForwardOptions_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type PodProxyOptions struct {
	V *v1.PodProxyOptions
}

var (
	_ boxed = (*PodProxyOptions)(nil)

	PodProxyOptions_fields = map[string]util.FieldSpec{}
	PodProxyOptions_inline = map[string]util.FieldSpec{}
	PodProxyOptions_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.PodProxyOptions)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.PodProxyOptions:
			return PodProxyOptions{V: v}
		case v1.PodProxyOptions:
			return PodProxyOptions{V: &v}
		default:
			return skylark.None
		}
	}
	PodProxyOptions_attrs = setFieldTypes(t, PodProxyOptions_fields, PodProxyOptions_inline)
	Library["PodProxyOptions"] = skylark.NewBuiltin("PodProxyOptions", createPodProxyOptions)
}

func createPodProxyOptions(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for PodProxyOptions
}
func (t PodProxyOptions) UnderlyingKind() interface{} { return t.V }
func (t PodProxyOptions) Package() util.Package       { return util.V1 }
func (t PodProxyOptions) Type() string                { return "k8s_v1_PodProxyOptions" }
func (t PodProxyOptions) String() string              { return t.V.String() }
func (t PodProxyOptions) Freeze()                     {} // TODO
func (t PodProxyOptions) Truth() skylark.Bool         { return skylark.True }
func (t PodProxyOptions) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t PodProxyOptions) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PodProxyOptions)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PodProxyOptions) AttrNames() []string { return PodProxyOptions_attrs }
func (t PodProxyOptions) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, PodProxyOptions_fields, PodProxyOptions_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type PodReadinessGate struct {
	V *v1.PodReadinessGate
}

var (
	_ boxed = (*PodReadinessGate)(nil)

	PodReadinessGate_fields = map[string]util.FieldSpec{}
	PodReadinessGate_inline = map[string]util.FieldSpec{}
	PodReadinessGate_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.PodReadinessGate)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.PodReadinessGate:
			return PodReadinessGate{V: v}
		case v1.PodReadinessGate:
			return PodReadinessGate{V: &v}
		default:
			return skylark.None
		}
	}
	PodReadinessGate_attrs = setFieldTypes(t, PodReadinessGate_fields, PodReadinessGate_inline)
	Library["PodReadinessGate"] = skylark.NewBuiltin("PodReadinessGate", createPodReadinessGate)
}

func createPodReadinessGate(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for PodReadinessGate
}
func (t PodReadinessGate) UnderlyingKind() interface{} { return t.V }
func (t PodReadinessGate) Package() util.Package       { return util.V1 }
func (t PodReadinessGate) Type() string                { return "k8s_v1_PodReadinessGate" }
func (t PodReadinessGate) String() string              { return t.V.String() }
func (t PodReadinessGate) Freeze()                     {} // TODO
func (t PodReadinessGate) Truth() skylark.Bool         { return skylark.True }
func (t PodReadinessGate) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t PodReadinessGate) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PodReadinessGate)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PodReadinessGate) AttrNames() []string { return PodReadinessGate_attrs }
func (t PodReadinessGate) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, PodReadinessGate_fields, PodReadinessGate_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type PodSecurityContext struct {
	V *v1.PodSecurityContext
}

var (
	_ boxed = (*PodSecurityContext)(nil)

	PodSecurityContext_fields = map[string]util.FieldSpec{}
	PodSecurityContext_inline = map[string]util.FieldSpec{}
	PodSecurityContext_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.PodSecurityContext)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.PodSecurityContext:
			return PodSecurityContext{V: v}
		case v1.PodSecurityContext:
			return PodSecurityContext{V: &v}
		default:
			return skylark.None
		}
	}
	PodSecurityContext_attrs = setFieldTypes(t, PodSecurityContext_fields, PodSecurityContext_inline)
	Library["PodSecurityContext"] = skylark.NewBuiltin("PodSecurityContext", createPodSecurityContext)
}

func createPodSecurityContext(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for PodSecurityContext
}
func (t PodSecurityContext) UnderlyingKind() interface{} { return t.V }
func (t PodSecurityContext) Package() util.Package       { return util.V1 }
func (t PodSecurityContext) Type() string                { return "k8s_v1_PodSecurityContext" }
func (t PodSecurityContext) String() string              { return t.V.String() }
func (t PodSecurityContext) Freeze()                     {} // TODO
func (t PodSecurityContext) Truth() skylark.Bool         { return skylark.True }
func (t PodSecurityContext) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t PodSecurityContext) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PodSecurityContext)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PodSecurityContext) AttrNames() []string { return PodSecurityContext_attrs }
func (t PodSecurityContext) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, PodSecurityContext_fields, PodSecurityContext_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type PodSignature struct {
	V *v1.PodSignature
}

var (
	_ boxed = (*PodSignature)(nil)

	PodSignature_fields = map[string]util.FieldSpec{}
	PodSignature_inline = map[string]util.FieldSpec{}
	PodSignature_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.PodSignature)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.PodSignature:
			return PodSignature{V: v}
		case v1.PodSignature:
			return PodSignature{V: &v}
		default:
			return skylark.None
		}
	}
	PodSignature_attrs = setFieldTypes(t, PodSignature_fields, PodSignature_inline)
	Library["PodSignature"] = skylark.NewBuiltin("PodSignature", createPodSignature)
}

func createPodSignature(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for PodSignature
}
func (t PodSignature) UnderlyingKind() interface{} { return t.V }
func (t PodSignature) Package() util.Package       { return util.V1 }
func (t PodSignature) Type() string                { return "k8s_v1_PodSignature" }
func (t PodSignature) String() string              { return t.V.String() }
func (t PodSignature) Freeze()                     {} // TODO
func (t PodSignature) Truth() skylark.Bool         { return skylark.True }
func (t PodSignature) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t PodSignature) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PodSignature)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PodSignature) AttrNames() []string { return PodSignature_attrs }
func (t PodSignature) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, PodSignature_fields, PodSignature_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type PodSpec struct {
	V *v1.PodSpec
}

var (
	_ boxed = (*PodSpec)(nil)

	PodSpec_fields = map[string]util.FieldSpec{}
	PodSpec_inline = map[string]util.FieldSpec{}
	PodSpec_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.PodSpec)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.PodSpec:
			return PodSpec{V: v}
		case v1.PodSpec:
			return PodSpec{V: &v}
		default:
			return skylark.None
		}
	}
	PodSpec_attrs = setFieldTypes(t, PodSpec_fields, PodSpec_inline)
	Library["PodSpec"] = skylark.NewBuiltin("PodSpec", createPodSpec)
}

func createPodSpec(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for PodSpec
}
func (t PodSpec) UnderlyingKind() interface{} { return t.V }
func (t PodSpec) Package() util.Package       { return util.V1 }
func (t PodSpec) Type() string                { return "k8s_v1_PodSpec" }
func (t PodSpec) String() string              { return t.V.String() }
func (t PodSpec) Freeze()                     {} // TODO
func (t PodSpec) Truth() skylark.Bool         { return skylark.True }
func (t PodSpec) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t PodSpec) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PodSpec)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PodSpec) AttrNames() []string { return PodSpec_attrs }
func (t PodSpec) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, PodSpec_fields, PodSpec_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type PodStatus struct {
	V *v1.PodStatus
}

var (
	_ boxed = (*PodStatus)(nil)

	PodStatus_fields = map[string]util.FieldSpec{}
	PodStatus_inline = map[string]util.FieldSpec{}
	PodStatus_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.PodStatus)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.PodStatus:
			return PodStatus{V: v}
		case v1.PodStatus:
			return PodStatus{V: &v}
		default:
			return skylark.None
		}
	}
	PodStatus_attrs = setFieldTypes(t, PodStatus_fields, PodStatus_inline)
	Library["PodStatus"] = skylark.NewBuiltin("PodStatus", createPodStatus)
}

func createPodStatus(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for PodStatus
}
func (t PodStatus) UnderlyingKind() interface{} { return t.V }
func (t PodStatus) Package() util.Package       { return util.V1 }
func (t PodStatus) Type() string                { return "k8s_v1_PodStatus" }
func (t PodStatus) String() string              { return t.V.String() }
func (t PodStatus) Freeze()                     {} // TODO
func (t PodStatus) Truth() skylark.Bool         { return skylark.True }
func (t PodStatus) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t PodStatus) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PodStatus)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PodStatus) AttrNames() []string { return PodStatus_attrs }
func (t PodStatus) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, PodStatus_fields, PodStatus_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type PodStatusResult struct {
	V *v1.PodStatusResult
}

var (
	_ boxed = (*PodStatusResult)(nil)

	PodStatusResult_fields = map[string]util.FieldSpec{}
	PodStatusResult_inline = map[string]util.FieldSpec{}
	PodStatusResult_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.PodStatusResult)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.PodStatusResult:
			return PodStatusResult{V: v}
		case v1.PodStatusResult:
			return PodStatusResult{V: &v}
		default:
			return skylark.None
		}
	}
	PodStatusResult_attrs = setFieldTypes(t, PodStatusResult_fields, PodStatusResult_inline)
	Library["PodStatusResult"] = skylark.NewBuiltin("PodStatusResult", createPodStatusResult)
}

func createPodStatusResult(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for PodStatusResult
}
func (t PodStatusResult) UnderlyingKind() interface{} { return t.V }
func (t PodStatusResult) Package() util.Package       { return util.V1 }
func (t PodStatusResult) Type() string                { return "k8s_v1_PodStatusResult" }
func (t PodStatusResult) String() string              { return t.V.String() }
func (t PodStatusResult) Freeze()                     {} // TODO
func (t PodStatusResult) Truth() skylark.Bool         { return skylark.True }
func (t PodStatusResult) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t PodStatusResult) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PodStatusResult)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PodStatusResult) AttrNames() []string { return PodStatusResult_attrs }
func (t PodStatusResult) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, PodStatusResult_fields, PodStatusResult_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type PodTemplate struct {
	V *v1.PodTemplate
}

var (
	_ boxed = (*PodTemplate)(nil)

	PodTemplate_fields = map[string]util.FieldSpec{}
	PodTemplate_inline = map[string]util.FieldSpec{}
	PodTemplate_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.PodTemplate)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.PodTemplate:
			return PodTemplate{V: v}
		case v1.PodTemplate:
			return PodTemplate{V: &v}
		default:
			return skylark.None
		}
	}
	PodTemplate_attrs = setFieldTypes(t, PodTemplate_fields, PodTemplate_inline)
	Library["PodTemplate"] = skylark.NewBuiltin("PodTemplate", createPodTemplate)
}

func createPodTemplate(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for PodTemplate
}
func (t PodTemplate) UnderlyingKind() interface{} { return t.V }
func (t PodTemplate) Package() util.Package       { return util.V1 }
func (t PodTemplate) Type() string                { return "k8s_v1_PodTemplate" }
func (t PodTemplate) String() string              { return t.V.String() }
func (t PodTemplate) Freeze()                     {} // TODO
func (t PodTemplate) Truth() skylark.Bool         { return skylark.True }
func (t PodTemplate) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t PodTemplate) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PodTemplate)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PodTemplate) AttrNames() []string { return PodTemplate_attrs }
func (t PodTemplate) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, PodTemplate_fields, PodTemplate_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type PodTemplateList struct {
	V *v1.PodTemplateList
}

var (
	_ boxed = (*PodTemplateList)(nil)

	PodTemplateList_fields = map[string]util.FieldSpec{}
	PodTemplateList_inline = map[string]util.FieldSpec{}
	PodTemplateList_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.PodTemplateList)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.PodTemplateList:
			return PodTemplateList{V: v}
		case v1.PodTemplateList:
			return PodTemplateList{V: &v}
		default:
			return skylark.None
		}
	}
	PodTemplateList_attrs = setFieldTypes(t, PodTemplateList_fields, PodTemplateList_inline)
	Library["PodTemplateList"] = skylark.NewBuiltin("PodTemplateList", createPodTemplateList)
}

func createPodTemplateList(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for PodTemplateList
}
func (t PodTemplateList) UnderlyingKind() interface{} { return t.V }
func (t PodTemplateList) Package() util.Package       { return util.V1 }
func (t PodTemplateList) Type() string                { return "k8s_v1_PodTemplateList" }
func (t PodTemplateList) String() string              { return t.V.String() }
func (t PodTemplateList) Freeze()                     {} // TODO
func (t PodTemplateList) Truth() skylark.Bool         { return skylark.True }
func (t PodTemplateList) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t PodTemplateList) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PodTemplateList)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PodTemplateList) AttrNames() []string { return PodTemplateList_attrs }
func (t PodTemplateList) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, PodTemplateList_fields, PodTemplateList_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type PodTemplateSpec struct {
	V *v1.PodTemplateSpec
}

var (
	_ boxed = (*PodTemplateSpec)(nil)

	PodTemplateSpec_fields = map[string]util.FieldSpec{}
	PodTemplateSpec_inline = map[string]util.FieldSpec{}
	PodTemplateSpec_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.PodTemplateSpec)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.PodTemplateSpec:
			return PodTemplateSpec{V: v}
		case v1.PodTemplateSpec:
			return PodTemplateSpec{V: &v}
		default:
			return skylark.None
		}
	}
	PodTemplateSpec_attrs = setFieldTypes(t, PodTemplateSpec_fields, PodTemplateSpec_inline)
	Library["PodTemplateSpec"] = skylark.NewBuiltin("PodTemplateSpec", createPodTemplateSpec)
}

func createPodTemplateSpec(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for PodTemplateSpec
}
func (t PodTemplateSpec) UnderlyingKind() interface{} { return t.V }
func (t PodTemplateSpec) Package() util.Package       { return util.V1 }
func (t PodTemplateSpec) Type() string                { return "k8s_v1_PodTemplateSpec" }
func (t PodTemplateSpec) String() string              { return t.V.String() }
func (t PodTemplateSpec) Freeze()                     {} // TODO
func (t PodTemplateSpec) Truth() skylark.Bool         { return skylark.True }
func (t PodTemplateSpec) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t PodTemplateSpec) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PodTemplateSpec)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PodTemplateSpec) AttrNames() []string { return PodTemplateSpec_attrs }
func (t PodTemplateSpec) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, PodTemplateSpec_fields, PodTemplateSpec_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type PortworxVolumeSource struct {
	V *v1.PortworxVolumeSource
}

var (
	_ boxed = (*PortworxVolumeSource)(nil)

	PortworxVolumeSource_fields = map[string]util.FieldSpec{}
	PortworxVolumeSource_inline = map[string]util.FieldSpec{}
	PortworxVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.PortworxVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.PortworxVolumeSource:
			return PortworxVolumeSource{V: v}
		case v1.PortworxVolumeSource:
			return PortworxVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	PortworxVolumeSource_attrs = setFieldTypes(t, PortworxVolumeSource_fields, PortworxVolumeSource_inline)
	Library["PortworxVolumeSource"] = skylark.NewBuiltin("PortworxVolumeSource", createPortworxVolumeSource)
}

func createPortworxVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for PortworxVolumeSource
}
func (t PortworxVolumeSource) UnderlyingKind() interface{} { return t.V }
func (t PortworxVolumeSource) Package() util.Package       { return util.V1 }
func (t PortworxVolumeSource) Type() string                { return "k8s_v1_PortworxVolumeSource" }
func (t PortworxVolumeSource) String() string              { return t.V.String() }
func (t PortworxVolumeSource) Freeze()                     {} // TODO
func (t PortworxVolumeSource) Truth() skylark.Bool         { return skylark.True }
func (t PortworxVolumeSource) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t PortworxVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PortworxVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PortworxVolumeSource) AttrNames() []string { return PortworxVolumeSource_attrs }
func (t PortworxVolumeSource) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, PortworxVolumeSource_fields, PortworxVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type Preconditions struct {
	V *v1.Preconditions
}

var (
	_ boxed = (*Preconditions)(nil)

	Preconditions_fields = map[string]util.FieldSpec{}
	Preconditions_inline = map[string]util.FieldSpec{}
	Preconditions_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.Preconditions)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.Preconditions:
			return Preconditions{V: v}
		case v1.Preconditions:
			return Preconditions{V: &v}
		default:
			return skylark.None
		}
	}
	Preconditions_attrs = setFieldTypes(t, Preconditions_fields, Preconditions_inline)
	Library["Preconditions"] = skylark.NewBuiltin("Preconditions", createPreconditions)
}

func createPreconditions(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for Preconditions
}
func (t Preconditions) UnderlyingKind() interface{} { return t.V }
func (t Preconditions) Package() util.Package       { return util.V1 }
func (t Preconditions) Type() string                { return "k8s_v1_Preconditions" }
func (t Preconditions) String() string              { return t.V.String() }
func (t Preconditions) Freeze()                     {} // TODO
func (t Preconditions) Truth() skylark.Bool         { return skylark.True }
func (t Preconditions) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t Preconditions) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*Preconditions)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t Preconditions) AttrNames() []string { return Preconditions_attrs }
func (t Preconditions) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, Preconditions_fields, Preconditions_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type PreferAvoidPodsEntry struct {
	V *v1.PreferAvoidPodsEntry
}

var (
	_ boxed = (*PreferAvoidPodsEntry)(nil)

	PreferAvoidPodsEntry_fields = map[string]util.FieldSpec{}
	PreferAvoidPodsEntry_inline = map[string]util.FieldSpec{}
	PreferAvoidPodsEntry_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.PreferAvoidPodsEntry)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.PreferAvoidPodsEntry:
			return PreferAvoidPodsEntry{V: v}
		case v1.PreferAvoidPodsEntry:
			return PreferAvoidPodsEntry{V: &v}
		default:
			return skylark.None
		}
	}
	PreferAvoidPodsEntry_attrs = setFieldTypes(t, PreferAvoidPodsEntry_fields, PreferAvoidPodsEntry_inline)
	Library["PreferAvoidPodsEntry"] = skylark.NewBuiltin("PreferAvoidPodsEntry", createPreferAvoidPodsEntry)
}

func createPreferAvoidPodsEntry(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for PreferAvoidPodsEntry
}
func (t PreferAvoidPodsEntry) UnderlyingKind() interface{} { return t.V }
func (t PreferAvoidPodsEntry) Package() util.Package       { return util.V1 }
func (t PreferAvoidPodsEntry) Type() string                { return "k8s_v1_PreferAvoidPodsEntry" }
func (t PreferAvoidPodsEntry) String() string              { return t.V.String() }
func (t PreferAvoidPodsEntry) Freeze()                     {} // TODO
func (t PreferAvoidPodsEntry) Truth() skylark.Bool         { return skylark.True }
func (t PreferAvoidPodsEntry) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t PreferAvoidPodsEntry) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PreferAvoidPodsEntry)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PreferAvoidPodsEntry) AttrNames() []string { return PreferAvoidPodsEntry_attrs }
func (t PreferAvoidPodsEntry) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, PreferAvoidPodsEntry_fields, PreferAvoidPodsEntry_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type PreferredSchedulingTerm struct {
	V *v1.PreferredSchedulingTerm
}

var (
	_ boxed = (*PreferredSchedulingTerm)(nil)

	PreferredSchedulingTerm_fields = map[string]util.FieldSpec{}
	PreferredSchedulingTerm_inline = map[string]util.FieldSpec{}
	PreferredSchedulingTerm_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.PreferredSchedulingTerm)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.PreferredSchedulingTerm:
			return PreferredSchedulingTerm{V: v}
		case v1.PreferredSchedulingTerm:
			return PreferredSchedulingTerm{V: &v}
		default:
			return skylark.None
		}
	}
	PreferredSchedulingTerm_attrs = setFieldTypes(t, PreferredSchedulingTerm_fields, PreferredSchedulingTerm_inline)
	Library["PreferredSchedulingTerm"] = skylark.NewBuiltin("PreferredSchedulingTerm", createPreferredSchedulingTerm)
}

func createPreferredSchedulingTerm(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for PreferredSchedulingTerm
}
func (t PreferredSchedulingTerm) UnderlyingKind() interface{} { return t.V }
func (t PreferredSchedulingTerm) Package() util.Package       { return util.V1 }
func (t PreferredSchedulingTerm) Type() string                { return "k8s_v1_PreferredSchedulingTerm" }
func (t PreferredSchedulingTerm) String() string              { return t.V.String() }
func (t PreferredSchedulingTerm) Freeze()                     {} // TODO
func (t PreferredSchedulingTerm) Truth() skylark.Bool         { return skylark.True }
func (t PreferredSchedulingTerm) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t PreferredSchedulingTerm) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PreferredSchedulingTerm)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PreferredSchedulingTerm) AttrNames() []string { return PreferredSchedulingTerm_attrs }
func (t PreferredSchedulingTerm) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, PreferredSchedulingTerm_fields, PreferredSchedulingTerm_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type Probe struct {
	V *v1.Probe
}

var (
	_ boxed = (*Probe)(nil)

	Probe_fields = map[string]util.FieldSpec{}
	Probe_inline = map[string]util.FieldSpec{}
	Probe_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.Probe)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.Probe:
			return Probe{V: v}
		case v1.Probe:
			return Probe{V: &v}
		default:
			return skylark.None
		}
	}
	Probe_attrs = setFieldTypes(t, Probe_fields, Probe_inline)
	Library["Probe"] = skylark.NewBuiltin("Probe", createProbe)
}

func createProbe(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for Probe
}
func (t Probe) UnderlyingKind() interface{} { return t.V }
func (t Probe) Package() util.Package       { return util.V1 }
func (t Probe) Type() string                { return "k8s_v1_Probe" }
func (t Probe) String() string              { return t.V.String() }
func (t Probe) Freeze()                     {} // TODO
func (t Probe) Truth() skylark.Bool         { return skylark.True }
func (t Probe) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t Probe) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*Probe)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t Probe) AttrNames() []string { return Probe_attrs }
func (t Probe) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, Probe_fields, Probe_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type ProjectedVolumeSource struct {
	V *v1.ProjectedVolumeSource
}

var (
	_ boxed = (*ProjectedVolumeSource)(nil)

	ProjectedVolumeSource_fields = map[string]util.FieldSpec{}
	ProjectedVolumeSource_inline = map[string]util.FieldSpec{}
	ProjectedVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.ProjectedVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.ProjectedVolumeSource:
			return ProjectedVolumeSource{V: v}
		case v1.ProjectedVolumeSource:
			return ProjectedVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	ProjectedVolumeSource_attrs = setFieldTypes(t, ProjectedVolumeSource_fields, ProjectedVolumeSource_inline)
	Library["ProjectedVolumeSource"] = skylark.NewBuiltin("ProjectedVolumeSource", createProjectedVolumeSource)
}

func createProjectedVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for ProjectedVolumeSource
}
func (t ProjectedVolumeSource) UnderlyingKind() interface{} { return t.V }
func (t ProjectedVolumeSource) Package() util.Package       { return util.V1 }
func (t ProjectedVolumeSource) Type() string                { return "k8s_v1_ProjectedVolumeSource" }
func (t ProjectedVolumeSource) String() string              { return t.V.String() }
func (t ProjectedVolumeSource) Freeze()                     {} // TODO
func (t ProjectedVolumeSource) Truth() skylark.Bool         { return skylark.True }
func (t ProjectedVolumeSource) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t ProjectedVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ProjectedVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ProjectedVolumeSource) AttrNames() []string { return ProjectedVolumeSource_attrs }
func (t ProjectedVolumeSource) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, ProjectedVolumeSource_fields, ProjectedVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type QuobyteVolumeSource struct {
	V *v1.QuobyteVolumeSource
}

var (
	_ boxed = (*QuobyteVolumeSource)(nil)

	QuobyteVolumeSource_fields = map[string]util.FieldSpec{}
	QuobyteVolumeSource_inline = map[string]util.FieldSpec{}
	QuobyteVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.QuobyteVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.QuobyteVolumeSource:
			return QuobyteVolumeSource{V: v}
		case v1.QuobyteVolumeSource:
			return QuobyteVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	QuobyteVolumeSource_attrs = setFieldTypes(t, QuobyteVolumeSource_fields, QuobyteVolumeSource_inline)
	Library["QuobyteVolumeSource"] = skylark.NewBuiltin("QuobyteVolumeSource", createQuobyteVolumeSource)
}

func createQuobyteVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for QuobyteVolumeSource
}
func (t QuobyteVolumeSource) UnderlyingKind() interface{} { return t.V }
func (t QuobyteVolumeSource) Package() util.Package       { return util.V1 }
func (t QuobyteVolumeSource) Type() string                { return "k8s_v1_QuobyteVolumeSource" }
func (t QuobyteVolumeSource) String() string              { return t.V.String() }
func (t QuobyteVolumeSource) Freeze()                     {} // TODO
func (t QuobyteVolumeSource) Truth() skylark.Bool         { return skylark.True }
func (t QuobyteVolumeSource) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t QuobyteVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*QuobyteVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t QuobyteVolumeSource) AttrNames() []string { return QuobyteVolumeSource_attrs }
func (t QuobyteVolumeSource) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, QuobyteVolumeSource_fields, QuobyteVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type RBDPersistentVolumeSource struct {
	V *v1.RBDPersistentVolumeSource
}

var (
	_ boxed = (*RBDPersistentVolumeSource)(nil)

	RBDPersistentVolumeSource_fields = map[string]util.FieldSpec{}
	RBDPersistentVolumeSource_inline = map[string]util.FieldSpec{}
	RBDPersistentVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.RBDPersistentVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.RBDPersistentVolumeSource:
			return RBDPersistentVolumeSource{V: v}
		case v1.RBDPersistentVolumeSource:
			return RBDPersistentVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	RBDPersistentVolumeSource_attrs = setFieldTypes(t, RBDPersistentVolumeSource_fields, RBDPersistentVolumeSource_inline)
	Library["RBDPersistentVolumeSource"] = skylark.NewBuiltin("RBDPersistentVolumeSource", createRBDPersistentVolumeSource)
}

func createRBDPersistentVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for RBDPersistentVolumeSource
}
func (t RBDPersistentVolumeSource) UnderlyingKind() interface{} { return t.V }
func (t RBDPersistentVolumeSource) Package() util.Package       { return util.V1 }
func (t RBDPersistentVolumeSource) Type() string                { return "k8s_v1_RBDPersistentVolumeSource" }
func (t RBDPersistentVolumeSource) String() string              { return t.V.String() }
func (t RBDPersistentVolumeSource) Freeze()                     {} // TODO
func (t RBDPersistentVolumeSource) Truth() skylark.Bool         { return skylark.True }
func (t RBDPersistentVolumeSource) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t RBDPersistentVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*RBDPersistentVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t RBDPersistentVolumeSource) AttrNames() []string { return RBDPersistentVolumeSource_attrs }
func (t RBDPersistentVolumeSource) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, RBDPersistentVolumeSource_fields, RBDPersistentVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type RBDVolumeSource struct {
	V *v1.RBDVolumeSource
}

var (
	_ boxed = (*RBDVolumeSource)(nil)

	RBDVolumeSource_fields = map[string]util.FieldSpec{}
	RBDVolumeSource_inline = map[string]util.FieldSpec{}
	RBDVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.RBDVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.RBDVolumeSource:
			return RBDVolumeSource{V: v}
		case v1.RBDVolumeSource:
			return RBDVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	RBDVolumeSource_attrs = setFieldTypes(t, RBDVolumeSource_fields, RBDVolumeSource_inline)
	Library["RBDVolumeSource"] = skylark.NewBuiltin("RBDVolumeSource", createRBDVolumeSource)
}

func createRBDVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for RBDVolumeSource
}
func (t RBDVolumeSource) UnderlyingKind() interface{} { return t.V }
func (t RBDVolumeSource) Package() util.Package       { return util.V1 }
func (t RBDVolumeSource) Type() string                { return "k8s_v1_RBDVolumeSource" }
func (t RBDVolumeSource) String() string              { return t.V.String() }
func (t RBDVolumeSource) Freeze()                     {} // TODO
func (t RBDVolumeSource) Truth() skylark.Bool         { return skylark.True }
func (t RBDVolumeSource) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t RBDVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*RBDVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t RBDVolumeSource) AttrNames() []string { return RBDVolumeSource_attrs }
func (t RBDVolumeSource) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, RBDVolumeSource_fields, RBDVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type RangeAllocation struct {
	V *v1.RangeAllocation
}

var (
	_ boxed = (*RangeAllocation)(nil)

	RangeAllocation_fields = map[string]util.FieldSpec{}
	RangeAllocation_inline = map[string]util.FieldSpec{}
	RangeAllocation_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.RangeAllocation)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.RangeAllocation:
			return RangeAllocation{V: v}
		case v1.RangeAllocation:
			return RangeAllocation{V: &v}
		default:
			return skylark.None
		}
	}
	RangeAllocation_attrs = setFieldTypes(t, RangeAllocation_fields, RangeAllocation_inline)
	Library["RangeAllocation"] = skylark.NewBuiltin("RangeAllocation", createRangeAllocation)
}

func createRangeAllocation(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for RangeAllocation
}
func (t RangeAllocation) UnderlyingKind() interface{} { return t.V }
func (t RangeAllocation) Package() util.Package       { return util.V1 }
func (t RangeAllocation) Type() string                { return "k8s_v1_RangeAllocation" }
func (t RangeAllocation) String() string              { return t.V.String() }
func (t RangeAllocation) Freeze()                     {} // TODO
func (t RangeAllocation) Truth() skylark.Bool         { return skylark.True }
func (t RangeAllocation) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t RangeAllocation) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*RangeAllocation)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t RangeAllocation) AttrNames() []string { return RangeAllocation_attrs }
func (t RangeAllocation) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, RangeAllocation_fields, RangeAllocation_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type ReplicationController struct {
	V *v1.ReplicationController
}

var (
	_ boxed = (*ReplicationController)(nil)

	ReplicationController_fields = map[string]util.FieldSpec{}
	ReplicationController_inline = map[string]util.FieldSpec{}
	ReplicationController_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.ReplicationController)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.ReplicationController:
			return ReplicationController{V: v}
		case v1.ReplicationController:
			return ReplicationController{V: &v}
		default:
			return skylark.None
		}
	}
	ReplicationController_attrs = setFieldTypes(t, ReplicationController_fields, ReplicationController_inline)
	Library["ReplicationController"] = skylark.NewBuiltin("ReplicationController", createReplicationController)
}

func createReplicationController(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for ReplicationController
}
func (t ReplicationController) UnderlyingKind() interface{} { return t.V }
func (t ReplicationController) Package() util.Package       { return util.V1 }
func (t ReplicationController) Type() string                { return "k8s_v1_ReplicationController" }
func (t ReplicationController) String() string              { return t.V.String() }
func (t ReplicationController) Freeze()                     {} // TODO
func (t ReplicationController) Truth() skylark.Bool         { return skylark.True }
func (t ReplicationController) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t ReplicationController) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ReplicationController)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ReplicationController) AttrNames() []string { return ReplicationController_attrs }
func (t ReplicationController) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, ReplicationController_fields, ReplicationController_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type ReplicationControllerCondition struct {
	V *v1.ReplicationControllerCondition
}

var (
	_ boxed = (*ReplicationControllerCondition)(nil)

	ReplicationControllerCondition_fields = map[string]util.FieldSpec{}
	ReplicationControllerCondition_inline = map[string]util.FieldSpec{}
	ReplicationControllerCondition_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.ReplicationControllerCondition)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.ReplicationControllerCondition:
			return ReplicationControllerCondition{V: v}
		case v1.ReplicationControllerCondition:
			return ReplicationControllerCondition{V: &v}
		default:
			return skylark.None
		}
	}
	ReplicationControllerCondition_attrs = setFieldTypes(t, ReplicationControllerCondition_fields, ReplicationControllerCondition_inline)
	Library["ReplicationControllerCondition"] = skylark.NewBuiltin("ReplicationControllerCondition", createReplicationControllerCondition)
}

func createReplicationControllerCondition(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for ReplicationControllerCondition
}
func (t ReplicationControllerCondition) UnderlyingKind() interface{} { return t.V }
func (t ReplicationControllerCondition) Package() util.Package       { return util.V1 }
func (t ReplicationControllerCondition) Type() string                { return "k8s_v1_ReplicationControllerCondition" }
func (t ReplicationControllerCondition) String() string              { return t.V.String() }
func (t ReplicationControllerCondition) Freeze()                     {} // TODO
func (t ReplicationControllerCondition) Truth() skylark.Bool         { return skylark.True }
func (t ReplicationControllerCondition) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t ReplicationControllerCondition) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ReplicationControllerCondition)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ReplicationControllerCondition) AttrNames() []string {
	return ReplicationControllerCondition_attrs
}
func (t ReplicationControllerCondition) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, ReplicationControllerCondition_fields, ReplicationControllerCondition_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type ReplicationControllerList struct {
	V *v1.ReplicationControllerList
}

var (
	_ boxed = (*ReplicationControllerList)(nil)

	ReplicationControllerList_fields = map[string]util.FieldSpec{}
	ReplicationControllerList_inline = map[string]util.FieldSpec{}
	ReplicationControllerList_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.ReplicationControllerList)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.ReplicationControllerList:
			return ReplicationControllerList{V: v}
		case v1.ReplicationControllerList:
			return ReplicationControllerList{V: &v}
		default:
			return skylark.None
		}
	}
	ReplicationControllerList_attrs = setFieldTypes(t, ReplicationControllerList_fields, ReplicationControllerList_inline)
	Library["ReplicationControllerList"] = skylark.NewBuiltin("ReplicationControllerList", createReplicationControllerList)
}

func createReplicationControllerList(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for ReplicationControllerList
}
func (t ReplicationControllerList) UnderlyingKind() interface{} { return t.V }
func (t ReplicationControllerList) Package() util.Package       { return util.V1 }
func (t ReplicationControllerList) Type() string                { return "k8s_v1_ReplicationControllerList" }
func (t ReplicationControllerList) String() string              { return t.V.String() }
func (t ReplicationControllerList) Freeze()                     {} // TODO
func (t ReplicationControllerList) Truth() skylark.Bool         { return skylark.True }
func (t ReplicationControllerList) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t ReplicationControllerList) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ReplicationControllerList)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ReplicationControllerList) AttrNames() []string { return ReplicationControllerList_attrs }
func (t ReplicationControllerList) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, ReplicationControllerList_fields, ReplicationControllerList_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type ReplicationControllerSpec struct {
	V *v1.ReplicationControllerSpec
}

var (
	_ boxed = (*ReplicationControllerSpec)(nil)

	ReplicationControllerSpec_fields = map[string]util.FieldSpec{}
	ReplicationControllerSpec_inline = map[string]util.FieldSpec{}
	ReplicationControllerSpec_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.ReplicationControllerSpec)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.ReplicationControllerSpec:
			return ReplicationControllerSpec{V: v}
		case v1.ReplicationControllerSpec:
			return ReplicationControllerSpec{V: &v}
		default:
			return skylark.None
		}
	}
	ReplicationControllerSpec_attrs = setFieldTypes(t, ReplicationControllerSpec_fields, ReplicationControllerSpec_inline)
	Library["ReplicationControllerSpec"] = skylark.NewBuiltin("ReplicationControllerSpec", createReplicationControllerSpec)
}

func createReplicationControllerSpec(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for ReplicationControllerSpec
}
func (t ReplicationControllerSpec) UnderlyingKind() interface{} { return t.V }
func (t ReplicationControllerSpec) Package() util.Package       { return util.V1 }
func (t ReplicationControllerSpec) Type() string                { return "k8s_v1_ReplicationControllerSpec" }
func (t ReplicationControllerSpec) String() string              { return t.V.String() }
func (t ReplicationControllerSpec) Freeze()                     {} // TODO
func (t ReplicationControllerSpec) Truth() skylark.Bool         { return skylark.True }
func (t ReplicationControllerSpec) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t ReplicationControllerSpec) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ReplicationControllerSpec)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ReplicationControllerSpec) AttrNames() []string { return ReplicationControllerSpec_attrs }
func (t ReplicationControllerSpec) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, ReplicationControllerSpec_fields, ReplicationControllerSpec_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type ReplicationControllerStatus struct {
	V *v1.ReplicationControllerStatus
}

var (
	_ boxed = (*ReplicationControllerStatus)(nil)

	ReplicationControllerStatus_fields = map[string]util.FieldSpec{}
	ReplicationControllerStatus_inline = map[string]util.FieldSpec{}
	ReplicationControllerStatus_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.ReplicationControllerStatus)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.ReplicationControllerStatus:
			return ReplicationControllerStatus{V: v}
		case v1.ReplicationControllerStatus:
			return ReplicationControllerStatus{V: &v}
		default:
			return skylark.None
		}
	}
	ReplicationControllerStatus_attrs = setFieldTypes(t, ReplicationControllerStatus_fields, ReplicationControllerStatus_inline)
	Library["ReplicationControllerStatus"] = skylark.NewBuiltin("ReplicationControllerStatus", createReplicationControllerStatus)
}

func createReplicationControllerStatus(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for ReplicationControllerStatus
}
func (t ReplicationControllerStatus) UnderlyingKind() interface{} { return t.V }
func (t ReplicationControllerStatus) Package() util.Package       { return util.V1 }
func (t ReplicationControllerStatus) Type() string                { return "k8s_v1_ReplicationControllerStatus" }
func (t ReplicationControllerStatus) String() string              { return t.V.String() }
func (t ReplicationControllerStatus) Freeze()                     {} // TODO
func (t ReplicationControllerStatus) Truth() skylark.Bool         { return skylark.True }
func (t ReplicationControllerStatus) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t ReplicationControllerStatus) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ReplicationControllerStatus)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ReplicationControllerStatus) AttrNames() []string { return ReplicationControllerStatus_attrs }
func (t ReplicationControllerStatus) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, ReplicationControllerStatus_fields, ReplicationControllerStatus_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type ResourceFieldSelector struct {
	V *v1.ResourceFieldSelector
}

var (
	_ boxed = (*ResourceFieldSelector)(nil)

	ResourceFieldSelector_fields = map[string]util.FieldSpec{}
	ResourceFieldSelector_inline = map[string]util.FieldSpec{}
	ResourceFieldSelector_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.ResourceFieldSelector)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.ResourceFieldSelector:
			return ResourceFieldSelector{V: v}
		case v1.ResourceFieldSelector:
			return ResourceFieldSelector{V: &v}
		default:
			return skylark.None
		}
	}
	ResourceFieldSelector_attrs = setFieldTypes(t, ResourceFieldSelector_fields, ResourceFieldSelector_inline)
	Library["ResourceFieldSelector"] = skylark.NewBuiltin("ResourceFieldSelector", createResourceFieldSelector)
}

func createResourceFieldSelector(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for ResourceFieldSelector
}
func (t ResourceFieldSelector) UnderlyingKind() interface{} { return t.V }
func (t ResourceFieldSelector) Package() util.Package       { return util.V1 }
func (t ResourceFieldSelector) Type() string                { return "k8s_v1_ResourceFieldSelector" }
func (t ResourceFieldSelector) String() string              { return t.V.String() }
func (t ResourceFieldSelector) Freeze()                     {} // TODO
func (t ResourceFieldSelector) Truth() skylark.Bool         { return skylark.True }
func (t ResourceFieldSelector) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t ResourceFieldSelector) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ResourceFieldSelector)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ResourceFieldSelector) AttrNames() []string { return ResourceFieldSelector_attrs }
func (t ResourceFieldSelector) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, ResourceFieldSelector_fields, ResourceFieldSelector_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type ResourceQuota struct {
	V *v1.ResourceQuota
}

var (
	_ boxed = (*ResourceQuota)(nil)

	ResourceQuota_fields = map[string]util.FieldSpec{}
	ResourceQuota_inline = map[string]util.FieldSpec{}
	ResourceQuota_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.ResourceQuota)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.ResourceQuota:
			return ResourceQuota{V: v}
		case v1.ResourceQuota:
			return ResourceQuota{V: &v}
		default:
			return skylark.None
		}
	}
	ResourceQuota_attrs = setFieldTypes(t, ResourceQuota_fields, ResourceQuota_inline)
	Library["ResourceQuota"] = skylark.NewBuiltin("ResourceQuota", createResourceQuota)
}

func createResourceQuota(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for ResourceQuota
}
func (t ResourceQuota) UnderlyingKind() interface{} { return t.V }
func (t ResourceQuota) Package() util.Package       { return util.V1 }
func (t ResourceQuota) Type() string                { return "k8s_v1_ResourceQuota" }
func (t ResourceQuota) String() string              { return t.V.String() }
func (t ResourceQuota) Freeze()                     {} // TODO
func (t ResourceQuota) Truth() skylark.Bool         { return skylark.True }
func (t ResourceQuota) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t ResourceQuota) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ResourceQuota)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ResourceQuota) AttrNames() []string { return ResourceQuota_attrs }
func (t ResourceQuota) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, ResourceQuota_fields, ResourceQuota_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type ResourceQuotaList struct {
	V *v1.ResourceQuotaList
}

var (
	_ boxed = (*ResourceQuotaList)(nil)

	ResourceQuotaList_fields = map[string]util.FieldSpec{}
	ResourceQuotaList_inline = map[string]util.FieldSpec{}
	ResourceQuotaList_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.ResourceQuotaList)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.ResourceQuotaList:
			return ResourceQuotaList{V: v}
		case v1.ResourceQuotaList:
			return ResourceQuotaList{V: &v}
		default:
			return skylark.None
		}
	}
	ResourceQuotaList_attrs = setFieldTypes(t, ResourceQuotaList_fields, ResourceQuotaList_inline)
	Library["ResourceQuotaList"] = skylark.NewBuiltin("ResourceQuotaList", createResourceQuotaList)
}

func createResourceQuotaList(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for ResourceQuotaList
}
func (t ResourceQuotaList) UnderlyingKind() interface{} { return t.V }
func (t ResourceQuotaList) Package() util.Package       { return util.V1 }
func (t ResourceQuotaList) Type() string                { return "k8s_v1_ResourceQuotaList" }
func (t ResourceQuotaList) String() string              { return t.V.String() }
func (t ResourceQuotaList) Freeze()                     {} // TODO
func (t ResourceQuotaList) Truth() skylark.Bool         { return skylark.True }
func (t ResourceQuotaList) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t ResourceQuotaList) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ResourceQuotaList)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ResourceQuotaList) AttrNames() []string { return ResourceQuotaList_attrs }
func (t ResourceQuotaList) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, ResourceQuotaList_fields, ResourceQuotaList_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type ResourceQuotaSpec struct {
	V *v1.ResourceQuotaSpec
}

var (
	_ boxed = (*ResourceQuotaSpec)(nil)

	ResourceQuotaSpec_fields = map[string]util.FieldSpec{}
	ResourceQuotaSpec_inline = map[string]util.FieldSpec{}
	ResourceQuotaSpec_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.ResourceQuotaSpec)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.ResourceQuotaSpec:
			return ResourceQuotaSpec{V: v}
		case v1.ResourceQuotaSpec:
			return ResourceQuotaSpec{V: &v}
		default:
			return skylark.None
		}
	}
	ResourceQuotaSpec_attrs = setFieldTypes(t, ResourceQuotaSpec_fields, ResourceQuotaSpec_inline)
	Library["ResourceQuotaSpec"] = skylark.NewBuiltin("ResourceQuotaSpec", createResourceQuotaSpec)
}

func createResourceQuotaSpec(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for ResourceQuotaSpec
}
func (t ResourceQuotaSpec) UnderlyingKind() interface{} { return t.V }
func (t ResourceQuotaSpec) Package() util.Package       { return util.V1 }
func (t ResourceQuotaSpec) Type() string                { return "k8s_v1_ResourceQuotaSpec" }
func (t ResourceQuotaSpec) String() string              { return t.V.String() }
func (t ResourceQuotaSpec) Freeze()                     {} // TODO
func (t ResourceQuotaSpec) Truth() skylark.Bool         { return skylark.True }
func (t ResourceQuotaSpec) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t ResourceQuotaSpec) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ResourceQuotaSpec)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ResourceQuotaSpec) AttrNames() []string { return ResourceQuotaSpec_attrs }
func (t ResourceQuotaSpec) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, ResourceQuotaSpec_fields, ResourceQuotaSpec_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type ResourceQuotaStatus struct {
	V *v1.ResourceQuotaStatus
}

var (
	_ boxed = (*ResourceQuotaStatus)(nil)

	ResourceQuotaStatus_fields = map[string]util.FieldSpec{}
	ResourceQuotaStatus_inline = map[string]util.FieldSpec{}
	ResourceQuotaStatus_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.ResourceQuotaStatus)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.ResourceQuotaStatus:
			return ResourceQuotaStatus{V: v}
		case v1.ResourceQuotaStatus:
			return ResourceQuotaStatus{V: &v}
		default:
			return skylark.None
		}
	}
	ResourceQuotaStatus_attrs = setFieldTypes(t, ResourceQuotaStatus_fields, ResourceQuotaStatus_inline)
	Library["ResourceQuotaStatus"] = skylark.NewBuiltin("ResourceQuotaStatus", createResourceQuotaStatus)
}

func createResourceQuotaStatus(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for ResourceQuotaStatus
}
func (t ResourceQuotaStatus) UnderlyingKind() interface{} { return t.V }
func (t ResourceQuotaStatus) Package() util.Package       { return util.V1 }
func (t ResourceQuotaStatus) Type() string                { return "k8s_v1_ResourceQuotaStatus" }
func (t ResourceQuotaStatus) String() string              { return t.V.String() }
func (t ResourceQuotaStatus) Freeze()                     {} // TODO
func (t ResourceQuotaStatus) Truth() skylark.Bool         { return skylark.True }
func (t ResourceQuotaStatus) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t ResourceQuotaStatus) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ResourceQuotaStatus)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ResourceQuotaStatus) AttrNames() []string { return ResourceQuotaStatus_attrs }
func (t ResourceQuotaStatus) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, ResourceQuotaStatus_fields, ResourceQuotaStatus_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type ResourceRequirements struct {
	V *v1.ResourceRequirements
}

var (
	_ boxed = (*ResourceRequirements)(nil)

	ResourceRequirements_fields = map[string]util.FieldSpec{}
	ResourceRequirements_inline = map[string]util.FieldSpec{}
	ResourceRequirements_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.ResourceRequirements)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.ResourceRequirements:
			return ResourceRequirements{V: v}
		case v1.ResourceRequirements:
			return ResourceRequirements{V: &v}
		default:
			return skylark.None
		}
	}
	ResourceRequirements_attrs = setFieldTypes(t, ResourceRequirements_fields, ResourceRequirements_inline)
	Library["ResourceRequirements"] = skylark.NewBuiltin("ResourceRequirements", createResourceRequirements)
}

func createResourceRequirements(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for ResourceRequirements
}
func (t ResourceRequirements) UnderlyingKind() interface{} { return t.V }
func (t ResourceRequirements) Package() util.Package       { return util.V1 }
func (t ResourceRequirements) Type() string                { return "k8s_v1_ResourceRequirements" }
func (t ResourceRequirements) String() string              { return t.V.String() }
func (t ResourceRequirements) Freeze()                     {} // TODO
func (t ResourceRequirements) Truth() skylark.Bool         { return skylark.True }
func (t ResourceRequirements) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t ResourceRequirements) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ResourceRequirements)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ResourceRequirements) AttrNames() []string { return ResourceRequirements_attrs }
func (t ResourceRequirements) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, ResourceRequirements_fields, ResourceRequirements_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type SELinuxOptions struct {
	V *v1.SELinuxOptions
}

var (
	_ boxed = (*SELinuxOptions)(nil)

	SELinuxOptions_fields = map[string]util.FieldSpec{}
	SELinuxOptions_inline = map[string]util.FieldSpec{}
	SELinuxOptions_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.SELinuxOptions)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.SELinuxOptions:
			return SELinuxOptions{V: v}
		case v1.SELinuxOptions:
			return SELinuxOptions{V: &v}
		default:
			return skylark.None
		}
	}
	SELinuxOptions_attrs = setFieldTypes(t, SELinuxOptions_fields, SELinuxOptions_inline)
	Library["SELinuxOptions"] = skylark.NewBuiltin("SELinuxOptions", createSELinuxOptions)
}

func createSELinuxOptions(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for SELinuxOptions
}
func (t SELinuxOptions) UnderlyingKind() interface{} { return t.V }
func (t SELinuxOptions) Package() util.Package       { return util.V1 }
func (t SELinuxOptions) Type() string                { return "k8s_v1_SELinuxOptions" }
func (t SELinuxOptions) String() string              { return t.V.String() }
func (t SELinuxOptions) Freeze()                     {} // TODO
func (t SELinuxOptions) Truth() skylark.Bool         { return skylark.True }
func (t SELinuxOptions) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t SELinuxOptions) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*SELinuxOptions)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t SELinuxOptions) AttrNames() []string { return SELinuxOptions_attrs }
func (t SELinuxOptions) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, SELinuxOptions_fields, SELinuxOptions_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type ScaleIOPersistentVolumeSource struct {
	V *v1.ScaleIOPersistentVolumeSource
}

var (
	_ boxed = (*ScaleIOPersistentVolumeSource)(nil)

	ScaleIOPersistentVolumeSource_fields = map[string]util.FieldSpec{}
	ScaleIOPersistentVolumeSource_inline = map[string]util.FieldSpec{}
	ScaleIOPersistentVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.ScaleIOPersistentVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.ScaleIOPersistentVolumeSource:
			return ScaleIOPersistentVolumeSource{V: v}
		case v1.ScaleIOPersistentVolumeSource:
			return ScaleIOPersistentVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	ScaleIOPersistentVolumeSource_attrs = setFieldTypes(t, ScaleIOPersistentVolumeSource_fields, ScaleIOPersistentVolumeSource_inline)
	Library["ScaleIOPersistentVolumeSource"] = skylark.NewBuiltin("ScaleIOPersistentVolumeSource", createScaleIOPersistentVolumeSource)
}

func createScaleIOPersistentVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for ScaleIOPersistentVolumeSource
}
func (t ScaleIOPersistentVolumeSource) UnderlyingKind() interface{} { return t.V }
func (t ScaleIOPersistentVolumeSource) Package() util.Package       { return util.V1 }
func (t ScaleIOPersistentVolumeSource) Type() string                { return "k8s_v1_ScaleIOPersistentVolumeSource" }
func (t ScaleIOPersistentVolumeSource) String() string              { return t.V.String() }
func (t ScaleIOPersistentVolumeSource) Freeze()                     {} // TODO
func (t ScaleIOPersistentVolumeSource) Truth() skylark.Bool         { return skylark.True }
func (t ScaleIOPersistentVolumeSource) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t ScaleIOPersistentVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ScaleIOPersistentVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ScaleIOPersistentVolumeSource) AttrNames() []string {
	return ScaleIOPersistentVolumeSource_attrs
}
func (t ScaleIOPersistentVolumeSource) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, ScaleIOPersistentVolumeSource_fields, ScaleIOPersistentVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type ScaleIOVolumeSource struct {
	V *v1.ScaleIOVolumeSource
}

var (
	_ boxed = (*ScaleIOVolumeSource)(nil)

	ScaleIOVolumeSource_fields = map[string]util.FieldSpec{}
	ScaleIOVolumeSource_inline = map[string]util.FieldSpec{}
	ScaleIOVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.ScaleIOVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.ScaleIOVolumeSource:
			return ScaleIOVolumeSource{V: v}
		case v1.ScaleIOVolumeSource:
			return ScaleIOVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	ScaleIOVolumeSource_attrs = setFieldTypes(t, ScaleIOVolumeSource_fields, ScaleIOVolumeSource_inline)
	Library["ScaleIOVolumeSource"] = skylark.NewBuiltin("ScaleIOVolumeSource", createScaleIOVolumeSource)
}

func createScaleIOVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for ScaleIOVolumeSource
}
func (t ScaleIOVolumeSource) UnderlyingKind() interface{} { return t.V }
func (t ScaleIOVolumeSource) Package() util.Package       { return util.V1 }
func (t ScaleIOVolumeSource) Type() string                { return "k8s_v1_ScaleIOVolumeSource" }
func (t ScaleIOVolumeSource) String() string              { return t.V.String() }
func (t ScaleIOVolumeSource) Freeze()                     {} // TODO
func (t ScaleIOVolumeSource) Truth() skylark.Bool         { return skylark.True }
func (t ScaleIOVolumeSource) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t ScaleIOVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ScaleIOVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ScaleIOVolumeSource) AttrNames() []string { return ScaleIOVolumeSource_attrs }
func (t ScaleIOVolumeSource) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, ScaleIOVolumeSource_fields, ScaleIOVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type ScopeSelector struct {
	V *v1.ScopeSelector
}

var (
	_ boxed = (*ScopeSelector)(nil)

	ScopeSelector_fields = map[string]util.FieldSpec{}
	ScopeSelector_inline = map[string]util.FieldSpec{}
	ScopeSelector_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.ScopeSelector)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.ScopeSelector:
			return ScopeSelector{V: v}
		case v1.ScopeSelector:
			return ScopeSelector{V: &v}
		default:
			return skylark.None
		}
	}
	ScopeSelector_attrs = setFieldTypes(t, ScopeSelector_fields, ScopeSelector_inline)
	Library["ScopeSelector"] = skylark.NewBuiltin("ScopeSelector", createScopeSelector)
}

func createScopeSelector(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for ScopeSelector
}
func (t ScopeSelector) UnderlyingKind() interface{} { return t.V }
func (t ScopeSelector) Package() util.Package       { return util.V1 }
func (t ScopeSelector) Type() string                { return "k8s_v1_ScopeSelector" }
func (t ScopeSelector) String() string              { return t.V.String() }
func (t ScopeSelector) Freeze()                     {} // TODO
func (t ScopeSelector) Truth() skylark.Bool         { return skylark.True }
func (t ScopeSelector) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t ScopeSelector) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ScopeSelector)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ScopeSelector) AttrNames() []string { return ScopeSelector_attrs }
func (t ScopeSelector) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, ScopeSelector_fields, ScopeSelector_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type ScopedResourceSelectorRequirement struct {
	V *v1.ScopedResourceSelectorRequirement
}

var (
	_ boxed = (*ScopedResourceSelectorRequirement)(nil)

	ScopedResourceSelectorRequirement_fields = map[string]util.FieldSpec{}
	ScopedResourceSelectorRequirement_inline = map[string]util.FieldSpec{}
	ScopedResourceSelectorRequirement_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.ScopedResourceSelectorRequirement)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.ScopedResourceSelectorRequirement:
			return ScopedResourceSelectorRequirement{V: v}
		case v1.ScopedResourceSelectorRequirement:
			return ScopedResourceSelectorRequirement{V: &v}
		default:
			return skylark.None
		}
	}
	ScopedResourceSelectorRequirement_attrs = setFieldTypes(t, ScopedResourceSelectorRequirement_fields, ScopedResourceSelectorRequirement_inline)
	Library["ScopedResourceSelectorRequirement"] = skylark.NewBuiltin("ScopedResourceSelectorRequirement", createScopedResourceSelectorRequirement)
}

func createScopedResourceSelectorRequirement(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for ScopedResourceSelectorRequirement
}
func (t ScopedResourceSelectorRequirement) UnderlyingKind() interface{} { return t.V }
func (t ScopedResourceSelectorRequirement) Package() util.Package       { return util.V1 }
func (t ScopedResourceSelectorRequirement) Type() string {
	return "k8s_v1_ScopedResourceSelectorRequirement"
}
func (t ScopedResourceSelectorRequirement) String() string        { return t.V.String() }
func (t ScopedResourceSelectorRequirement) Freeze()               {} // TODO
func (t ScopedResourceSelectorRequirement) Truth() skylark.Bool   { return skylark.True }
func (t ScopedResourceSelectorRequirement) Hash() (uint32, error) { return 0, unhashable(t.Type()) }
func (t ScopedResourceSelectorRequirement) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ScopedResourceSelectorRequirement)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ScopedResourceSelectorRequirement) AttrNames() []string {
	return ScopedResourceSelectorRequirement_attrs
}
func (t ScopedResourceSelectorRequirement) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, ScopedResourceSelectorRequirement_fields, ScopedResourceSelectorRequirement_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type Secret struct {
	V *v1.Secret
}

var (
	_ boxed = (*Secret)(nil)

	Secret_fields = map[string]util.FieldSpec{}
	Secret_inline = map[string]util.FieldSpec{}
	Secret_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.Secret)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.Secret:
			return Secret{V: v}
		case v1.Secret:
			return Secret{V: &v}
		default:
			return skylark.None
		}
	}
	Secret_attrs = setFieldTypes(t, Secret_fields, Secret_inline)
	Library["Secret"] = skylark.NewBuiltin("Secret", createSecret)
}

func createSecret(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for Secret
}
func (t Secret) UnderlyingKind() interface{} { return t.V }
func (t Secret) Package() util.Package       { return util.V1 }
func (t Secret) Type() string                { return "k8s_v1_Secret" }
func (t Secret) String() string              { return t.V.String() }
func (t Secret) Freeze()                     {} // TODO
func (t Secret) Truth() skylark.Bool         { return skylark.True }
func (t Secret) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t Secret) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*Secret)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t Secret) AttrNames() []string { return Secret_attrs }
func (t Secret) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, Secret_fields, Secret_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type SecretEnvSource struct {
	V *v1.SecretEnvSource
}

var (
	_ boxed = (*SecretEnvSource)(nil)

	SecretEnvSource_fields = map[string]util.FieldSpec{}
	SecretEnvSource_inline = map[string]util.FieldSpec{}
	SecretEnvSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.SecretEnvSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.SecretEnvSource:
			return SecretEnvSource{V: v}
		case v1.SecretEnvSource:
			return SecretEnvSource{V: &v}
		default:
			return skylark.None
		}
	}
	SecretEnvSource_attrs = setFieldTypes(t, SecretEnvSource_fields, SecretEnvSource_inline)
	Library["SecretEnvSource"] = skylark.NewBuiltin("SecretEnvSource", createSecretEnvSource)
}

func createSecretEnvSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for SecretEnvSource
}
func (t SecretEnvSource) UnderlyingKind() interface{} { return t.V }
func (t SecretEnvSource) Package() util.Package       { return util.V1 }
func (t SecretEnvSource) Type() string                { return "k8s_v1_SecretEnvSource" }
func (t SecretEnvSource) String() string              { return t.V.String() }
func (t SecretEnvSource) Freeze()                     {} // TODO
func (t SecretEnvSource) Truth() skylark.Bool         { return skylark.True }
func (t SecretEnvSource) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t SecretEnvSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*SecretEnvSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t SecretEnvSource) AttrNames() []string { return SecretEnvSource_attrs }
func (t SecretEnvSource) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, SecretEnvSource_fields, SecretEnvSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type SecretKeySelector struct {
	V *v1.SecretKeySelector
}

var (
	_ boxed = (*SecretKeySelector)(nil)

	SecretKeySelector_fields = map[string]util.FieldSpec{}
	SecretKeySelector_inline = map[string]util.FieldSpec{}
	SecretKeySelector_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.SecretKeySelector)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.SecretKeySelector:
			return SecretKeySelector{V: v}
		case v1.SecretKeySelector:
			return SecretKeySelector{V: &v}
		default:
			return skylark.None
		}
	}
	SecretKeySelector_attrs = setFieldTypes(t, SecretKeySelector_fields, SecretKeySelector_inline)
	Library["SecretKeySelector"] = skylark.NewBuiltin("SecretKeySelector", createSecretKeySelector)
}

func createSecretKeySelector(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for SecretKeySelector
}
func (t SecretKeySelector) UnderlyingKind() interface{} { return t.V }
func (t SecretKeySelector) Package() util.Package       { return util.V1 }
func (t SecretKeySelector) Type() string                { return "k8s_v1_SecretKeySelector" }
func (t SecretKeySelector) String() string              { return t.V.String() }
func (t SecretKeySelector) Freeze()                     {} // TODO
func (t SecretKeySelector) Truth() skylark.Bool         { return skylark.True }
func (t SecretKeySelector) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t SecretKeySelector) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*SecretKeySelector)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t SecretKeySelector) AttrNames() []string { return SecretKeySelector_attrs }
func (t SecretKeySelector) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, SecretKeySelector_fields, SecretKeySelector_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type SecretList struct {
	V *v1.SecretList
}

var (
	_ boxed = (*SecretList)(nil)

	SecretList_fields = map[string]util.FieldSpec{}
	SecretList_inline = map[string]util.FieldSpec{}
	SecretList_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.SecretList)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.SecretList:
			return SecretList{V: v}
		case v1.SecretList:
			return SecretList{V: &v}
		default:
			return skylark.None
		}
	}
	SecretList_attrs = setFieldTypes(t, SecretList_fields, SecretList_inline)
	Library["SecretList"] = skylark.NewBuiltin("SecretList", createSecretList)
}

func createSecretList(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for SecretList
}
func (t SecretList) UnderlyingKind() interface{} { return t.V }
func (t SecretList) Package() util.Package       { return util.V1 }
func (t SecretList) Type() string                { return "k8s_v1_SecretList" }
func (t SecretList) String() string              { return t.V.String() }
func (t SecretList) Freeze()                     {} // TODO
func (t SecretList) Truth() skylark.Bool         { return skylark.True }
func (t SecretList) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t SecretList) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*SecretList)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t SecretList) AttrNames() []string { return SecretList_attrs }
func (t SecretList) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, SecretList_fields, SecretList_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type SecretProjection struct {
	V *v1.SecretProjection
}

var (
	_ boxed = (*SecretProjection)(nil)

	SecretProjection_fields = map[string]util.FieldSpec{}
	SecretProjection_inline = map[string]util.FieldSpec{}
	SecretProjection_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.SecretProjection)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.SecretProjection:
			return SecretProjection{V: v}
		case v1.SecretProjection:
			return SecretProjection{V: &v}
		default:
			return skylark.None
		}
	}
	SecretProjection_attrs = setFieldTypes(t, SecretProjection_fields, SecretProjection_inline)
	Library["SecretProjection"] = skylark.NewBuiltin("SecretProjection", createSecretProjection)
}

func createSecretProjection(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for SecretProjection
}
func (t SecretProjection) UnderlyingKind() interface{} { return t.V }
func (t SecretProjection) Package() util.Package       { return util.V1 }
func (t SecretProjection) Type() string                { return "k8s_v1_SecretProjection" }
func (t SecretProjection) String() string              { return t.V.String() }
func (t SecretProjection) Freeze()                     {} // TODO
func (t SecretProjection) Truth() skylark.Bool         { return skylark.True }
func (t SecretProjection) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t SecretProjection) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*SecretProjection)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t SecretProjection) AttrNames() []string { return SecretProjection_attrs }
func (t SecretProjection) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, SecretProjection_fields, SecretProjection_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type SecretReference struct {
	V *v1.SecretReference
}

var (
	_ boxed = (*SecretReference)(nil)

	SecretReference_fields = map[string]util.FieldSpec{}
	SecretReference_inline = map[string]util.FieldSpec{}
	SecretReference_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.SecretReference)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.SecretReference:
			return SecretReference{V: v}
		case v1.SecretReference:
			return SecretReference{V: &v}
		default:
			return skylark.None
		}
	}
	SecretReference_attrs = setFieldTypes(t, SecretReference_fields, SecretReference_inline)
	Library["SecretReference"] = skylark.NewBuiltin("SecretReference", createSecretReference)
}

func createSecretReference(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for SecretReference
}
func (t SecretReference) UnderlyingKind() interface{} { return t.V }
func (t SecretReference) Package() util.Package       { return util.V1 }
func (t SecretReference) Type() string                { return "k8s_v1_SecretReference" }
func (t SecretReference) String() string              { return t.V.String() }
func (t SecretReference) Freeze()                     {} // TODO
func (t SecretReference) Truth() skylark.Bool         { return skylark.True }
func (t SecretReference) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t SecretReference) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*SecretReference)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t SecretReference) AttrNames() []string { return SecretReference_attrs }
func (t SecretReference) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, SecretReference_fields, SecretReference_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type SecretVolumeSource struct {
	V *v1.SecretVolumeSource
}

var (
	_ boxed = (*SecretVolumeSource)(nil)

	SecretVolumeSource_fields = map[string]util.FieldSpec{}
	SecretVolumeSource_inline = map[string]util.FieldSpec{}
	SecretVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.SecretVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.SecretVolumeSource:
			return SecretVolumeSource{V: v}
		case v1.SecretVolumeSource:
			return SecretVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	SecretVolumeSource_attrs = setFieldTypes(t, SecretVolumeSource_fields, SecretVolumeSource_inline)
	Library["SecretVolumeSource"] = skylark.NewBuiltin("SecretVolumeSource", createSecretVolumeSource)
}

func createSecretVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for SecretVolumeSource
}
func (t SecretVolumeSource) UnderlyingKind() interface{} { return t.V }
func (t SecretVolumeSource) Package() util.Package       { return util.V1 }
func (t SecretVolumeSource) Type() string                { return "k8s_v1_SecretVolumeSource" }
func (t SecretVolumeSource) String() string              { return t.V.String() }
func (t SecretVolumeSource) Freeze()                     {} // TODO
func (t SecretVolumeSource) Truth() skylark.Bool         { return skylark.True }
func (t SecretVolumeSource) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t SecretVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*SecretVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t SecretVolumeSource) AttrNames() []string { return SecretVolumeSource_attrs }
func (t SecretVolumeSource) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, SecretVolumeSource_fields, SecretVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type SecurityContext struct {
	V *v1.SecurityContext
}

var (
	_ boxed = (*SecurityContext)(nil)

	SecurityContext_fields = map[string]util.FieldSpec{}
	SecurityContext_inline = map[string]util.FieldSpec{}
	SecurityContext_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.SecurityContext)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.SecurityContext:
			return SecurityContext{V: v}
		case v1.SecurityContext:
			return SecurityContext{V: &v}
		default:
			return skylark.None
		}
	}
	SecurityContext_attrs = setFieldTypes(t, SecurityContext_fields, SecurityContext_inline)
	Library["SecurityContext"] = skylark.NewBuiltin("SecurityContext", createSecurityContext)
}

func createSecurityContext(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for SecurityContext
}
func (t SecurityContext) UnderlyingKind() interface{} { return t.V }
func (t SecurityContext) Package() util.Package       { return util.V1 }
func (t SecurityContext) Type() string                { return "k8s_v1_SecurityContext" }
func (t SecurityContext) String() string              { return t.V.String() }
func (t SecurityContext) Freeze()                     {} // TODO
func (t SecurityContext) Truth() skylark.Bool         { return skylark.True }
func (t SecurityContext) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t SecurityContext) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*SecurityContext)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t SecurityContext) AttrNames() []string { return SecurityContext_attrs }
func (t SecurityContext) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, SecurityContext_fields, SecurityContext_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type SerializedReference struct {
	V *v1.SerializedReference
}

var (
	_ boxed = (*SerializedReference)(nil)

	SerializedReference_fields = map[string]util.FieldSpec{}
	SerializedReference_inline = map[string]util.FieldSpec{}
	SerializedReference_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.SerializedReference)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.SerializedReference:
			return SerializedReference{V: v}
		case v1.SerializedReference:
			return SerializedReference{V: &v}
		default:
			return skylark.None
		}
	}
	SerializedReference_attrs = setFieldTypes(t, SerializedReference_fields, SerializedReference_inline)
	Library["SerializedReference"] = skylark.NewBuiltin("SerializedReference", createSerializedReference)
}

func createSerializedReference(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for SerializedReference
}
func (t SerializedReference) UnderlyingKind() interface{} { return t.V }
func (t SerializedReference) Package() util.Package       { return util.V1 }
func (t SerializedReference) Type() string                { return "k8s_v1_SerializedReference" }
func (t SerializedReference) String() string              { return t.V.String() }
func (t SerializedReference) Freeze()                     {} // TODO
func (t SerializedReference) Truth() skylark.Bool         { return skylark.True }
func (t SerializedReference) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t SerializedReference) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*SerializedReference)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t SerializedReference) AttrNames() []string { return SerializedReference_attrs }
func (t SerializedReference) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, SerializedReference_fields, SerializedReference_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type Service struct {
	V *v1.Service
}

var (
	_ boxed = (*Service)(nil)

	Service_fields = map[string]util.FieldSpec{}
	Service_inline = map[string]util.FieldSpec{}
	Service_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.Service)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.Service:
			return Service{V: v}
		case v1.Service:
			return Service{V: &v}
		default:
			return skylark.None
		}
	}
	Service_attrs = setFieldTypes(t, Service_fields, Service_inline)
	Library["Service"] = skylark.NewBuiltin("Service", createService)
}

func createService(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for Service
}
func (t Service) UnderlyingKind() interface{} { return t.V }
func (t Service) Package() util.Package       { return util.V1 }
func (t Service) Type() string                { return "k8s_v1_Service" }
func (t Service) String() string              { return t.V.String() }
func (t Service) Freeze()                     {} // TODO
func (t Service) Truth() skylark.Bool         { return skylark.True }
func (t Service) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t Service) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*Service)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t Service) AttrNames() []string { return Service_attrs }
func (t Service) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, Service_fields, Service_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type ServiceAccount struct {
	V *v1.ServiceAccount
}

var (
	_ boxed = (*ServiceAccount)(nil)

	ServiceAccount_fields = map[string]util.FieldSpec{}
	ServiceAccount_inline = map[string]util.FieldSpec{}
	ServiceAccount_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.ServiceAccount)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.ServiceAccount:
			return ServiceAccount{V: v}
		case v1.ServiceAccount:
			return ServiceAccount{V: &v}
		default:
			return skylark.None
		}
	}
	ServiceAccount_attrs = setFieldTypes(t, ServiceAccount_fields, ServiceAccount_inline)
	Library["ServiceAccount"] = skylark.NewBuiltin("ServiceAccount", createServiceAccount)
}

func createServiceAccount(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for ServiceAccount
}
func (t ServiceAccount) UnderlyingKind() interface{} { return t.V }
func (t ServiceAccount) Package() util.Package       { return util.V1 }
func (t ServiceAccount) Type() string                { return "k8s_v1_ServiceAccount" }
func (t ServiceAccount) String() string              { return t.V.String() }
func (t ServiceAccount) Freeze()                     {} // TODO
func (t ServiceAccount) Truth() skylark.Bool         { return skylark.True }
func (t ServiceAccount) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t ServiceAccount) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ServiceAccount)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ServiceAccount) AttrNames() []string { return ServiceAccount_attrs }
func (t ServiceAccount) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, ServiceAccount_fields, ServiceAccount_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type ServiceAccountList struct {
	V *v1.ServiceAccountList
}

var (
	_ boxed = (*ServiceAccountList)(nil)

	ServiceAccountList_fields = map[string]util.FieldSpec{}
	ServiceAccountList_inline = map[string]util.FieldSpec{}
	ServiceAccountList_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.ServiceAccountList)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.ServiceAccountList:
			return ServiceAccountList{V: v}
		case v1.ServiceAccountList:
			return ServiceAccountList{V: &v}
		default:
			return skylark.None
		}
	}
	ServiceAccountList_attrs = setFieldTypes(t, ServiceAccountList_fields, ServiceAccountList_inline)
	Library["ServiceAccountList"] = skylark.NewBuiltin("ServiceAccountList", createServiceAccountList)
}

func createServiceAccountList(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for ServiceAccountList
}
func (t ServiceAccountList) UnderlyingKind() interface{} { return t.V }
func (t ServiceAccountList) Package() util.Package       { return util.V1 }
func (t ServiceAccountList) Type() string                { return "k8s_v1_ServiceAccountList" }
func (t ServiceAccountList) String() string              { return t.V.String() }
func (t ServiceAccountList) Freeze()                     {} // TODO
func (t ServiceAccountList) Truth() skylark.Bool         { return skylark.True }
func (t ServiceAccountList) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t ServiceAccountList) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ServiceAccountList)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ServiceAccountList) AttrNames() []string { return ServiceAccountList_attrs }
func (t ServiceAccountList) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, ServiceAccountList_fields, ServiceAccountList_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type ServiceAccountTokenProjection struct {
	V *v1.ServiceAccountTokenProjection
}

var (
	_ boxed = (*ServiceAccountTokenProjection)(nil)

	ServiceAccountTokenProjection_fields = map[string]util.FieldSpec{}
	ServiceAccountTokenProjection_inline = map[string]util.FieldSpec{}
	ServiceAccountTokenProjection_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.ServiceAccountTokenProjection)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.ServiceAccountTokenProjection:
			return ServiceAccountTokenProjection{V: v}
		case v1.ServiceAccountTokenProjection:
			return ServiceAccountTokenProjection{V: &v}
		default:
			return skylark.None
		}
	}
	ServiceAccountTokenProjection_attrs = setFieldTypes(t, ServiceAccountTokenProjection_fields, ServiceAccountTokenProjection_inline)
	Library["ServiceAccountTokenProjection"] = skylark.NewBuiltin("ServiceAccountTokenProjection", createServiceAccountTokenProjection)
}

func createServiceAccountTokenProjection(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for ServiceAccountTokenProjection
}
func (t ServiceAccountTokenProjection) UnderlyingKind() interface{} { return t.V }
func (t ServiceAccountTokenProjection) Package() util.Package       { return util.V1 }
func (t ServiceAccountTokenProjection) Type() string                { return "k8s_v1_ServiceAccountTokenProjection" }
func (t ServiceAccountTokenProjection) String() string              { return t.V.String() }
func (t ServiceAccountTokenProjection) Freeze()                     {} // TODO
func (t ServiceAccountTokenProjection) Truth() skylark.Bool         { return skylark.True }
func (t ServiceAccountTokenProjection) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t ServiceAccountTokenProjection) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ServiceAccountTokenProjection)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ServiceAccountTokenProjection) AttrNames() []string {
	return ServiceAccountTokenProjection_attrs
}
func (t ServiceAccountTokenProjection) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, ServiceAccountTokenProjection_fields, ServiceAccountTokenProjection_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type ServiceList struct {
	V *v1.ServiceList
}

var (
	_ boxed = (*ServiceList)(nil)

	ServiceList_fields = map[string]util.FieldSpec{}
	ServiceList_inline = map[string]util.FieldSpec{}
	ServiceList_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.ServiceList)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.ServiceList:
			return ServiceList{V: v}
		case v1.ServiceList:
			return ServiceList{V: &v}
		default:
			return skylark.None
		}
	}
	ServiceList_attrs = setFieldTypes(t, ServiceList_fields, ServiceList_inline)
	Library["ServiceList"] = skylark.NewBuiltin("ServiceList", createServiceList)
}

func createServiceList(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for ServiceList
}
func (t ServiceList) UnderlyingKind() interface{} { return t.V }
func (t ServiceList) Package() util.Package       { return util.V1 }
func (t ServiceList) Type() string                { return "k8s_v1_ServiceList" }
func (t ServiceList) String() string              { return t.V.String() }
func (t ServiceList) Freeze()                     {} // TODO
func (t ServiceList) Truth() skylark.Bool         { return skylark.True }
func (t ServiceList) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t ServiceList) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ServiceList)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ServiceList) AttrNames() []string { return ServiceList_attrs }
func (t ServiceList) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, ServiceList_fields, ServiceList_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type ServicePort struct {
	V *v1.ServicePort
}

var (
	_ boxed = (*ServicePort)(nil)

	ServicePort_fields = map[string]util.FieldSpec{}
	ServicePort_inline = map[string]util.FieldSpec{}
	ServicePort_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.ServicePort)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.ServicePort:
			return ServicePort{V: v}
		case v1.ServicePort:
			return ServicePort{V: &v}
		default:
			return skylark.None
		}
	}
	ServicePort_attrs = setFieldTypes(t, ServicePort_fields, ServicePort_inline)
	Library["ServicePort"] = skylark.NewBuiltin("ServicePort", createServicePort)
}

func createServicePort(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for ServicePort
}
func (t ServicePort) UnderlyingKind() interface{} { return t.V }
func (t ServicePort) Package() util.Package       { return util.V1 }
func (t ServicePort) Type() string                { return "k8s_v1_ServicePort" }
func (t ServicePort) String() string              { return t.V.String() }
func (t ServicePort) Freeze()                     {} // TODO
func (t ServicePort) Truth() skylark.Bool         { return skylark.True }
func (t ServicePort) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t ServicePort) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ServicePort)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ServicePort) AttrNames() []string { return ServicePort_attrs }
func (t ServicePort) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, ServicePort_fields, ServicePort_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type ServiceProxyOptions struct {
	V *v1.ServiceProxyOptions
}

var (
	_ boxed = (*ServiceProxyOptions)(nil)

	ServiceProxyOptions_fields = map[string]util.FieldSpec{}
	ServiceProxyOptions_inline = map[string]util.FieldSpec{}
	ServiceProxyOptions_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.ServiceProxyOptions)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.ServiceProxyOptions:
			return ServiceProxyOptions{V: v}
		case v1.ServiceProxyOptions:
			return ServiceProxyOptions{V: &v}
		default:
			return skylark.None
		}
	}
	ServiceProxyOptions_attrs = setFieldTypes(t, ServiceProxyOptions_fields, ServiceProxyOptions_inline)
	Library["ServiceProxyOptions"] = skylark.NewBuiltin("ServiceProxyOptions", createServiceProxyOptions)
}

func createServiceProxyOptions(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for ServiceProxyOptions
}
func (t ServiceProxyOptions) UnderlyingKind() interface{} { return t.V }
func (t ServiceProxyOptions) Package() util.Package       { return util.V1 }
func (t ServiceProxyOptions) Type() string                { return "k8s_v1_ServiceProxyOptions" }
func (t ServiceProxyOptions) String() string              { return t.V.String() }
func (t ServiceProxyOptions) Freeze()                     {} // TODO
func (t ServiceProxyOptions) Truth() skylark.Bool         { return skylark.True }
func (t ServiceProxyOptions) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t ServiceProxyOptions) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ServiceProxyOptions)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ServiceProxyOptions) AttrNames() []string { return ServiceProxyOptions_attrs }
func (t ServiceProxyOptions) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, ServiceProxyOptions_fields, ServiceProxyOptions_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type ServiceSpec struct {
	V *v1.ServiceSpec
}

var (
	_ boxed = (*ServiceSpec)(nil)

	ServiceSpec_fields = map[string]util.FieldSpec{}
	ServiceSpec_inline = map[string]util.FieldSpec{}
	ServiceSpec_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.ServiceSpec)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.ServiceSpec:
			return ServiceSpec{V: v}
		case v1.ServiceSpec:
			return ServiceSpec{V: &v}
		default:
			return skylark.None
		}
	}
	ServiceSpec_attrs = setFieldTypes(t, ServiceSpec_fields, ServiceSpec_inline)
	Library["ServiceSpec"] = skylark.NewBuiltin("ServiceSpec", createServiceSpec)
}

func createServiceSpec(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for ServiceSpec
}
func (t ServiceSpec) UnderlyingKind() interface{} { return t.V }
func (t ServiceSpec) Package() util.Package       { return util.V1 }
func (t ServiceSpec) Type() string                { return "k8s_v1_ServiceSpec" }
func (t ServiceSpec) String() string              { return t.V.String() }
func (t ServiceSpec) Freeze()                     {} // TODO
func (t ServiceSpec) Truth() skylark.Bool         { return skylark.True }
func (t ServiceSpec) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t ServiceSpec) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ServiceSpec)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ServiceSpec) AttrNames() []string { return ServiceSpec_attrs }
func (t ServiceSpec) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, ServiceSpec_fields, ServiceSpec_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type ServiceStatus struct {
	V *v1.ServiceStatus
}

var (
	_ boxed = (*ServiceStatus)(nil)

	ServiceStatus_fields = map[string]util.FieldSpec{}
	ServiceStatus_inline = map[string]util.FieldSpec{}
	ServiceStatus_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.ServiceStatus)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.ServiceStatus:
			return ServiceStatus{V: v}
		case v1.ServiceStatus:
			return ServiceStatus{V: &v}
		default:
			return skylark.None
		}
	}
	ServiceStatus_attrs = setFieldTypes(t, ServiceStatus_fields, ServiceStatus_inline)
	Library["ServiceStatus"] = skylark.NewBuiltin("ServiceStatus", createServiceStatus)
}

func createServiceStatus(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for ServiceStatus
}
func (t ServiceStatus) UnderlyingKind() interface{} { return t.V }
func (t ServiceStatus) Package() util.Package       { return util.V1 }
func (t ServiceStatus) Type() string                { return "k8s_v1_ServiceStatus" }
func (t ServiceStatus) String() string              { return t.V.String() }
func (t ServiceStatus) Freeze()                     {} // TODO
func (t ServiceStatus) Truth() skylark.Bool         { return skylark.True }
func (t ServiceStatus) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t ServiceStatus) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ServiceStatus)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ServiceStatus) AttrNames() []string { return ServiceStatus_attrs }
func (t ServiceStatus) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, ServiceStatus_fields, ServiceStatus_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type SessionAffinityConfig struct {
	V *v1.SessionAffinityConfig
}

var (
	_ boxed = (*SessionAffinityConfig)(nil)

	SessionAffinityConfig_fields = map[string]util.FieldSpec{}
	SessionAffinityConfig_inline = map[string]util.FieldSpec{}
	SessionAffinityConfig_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.SessionAffinityConfig)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.SessionAffinityConfig:
			return SessionAffinityConfig{V: v}
		case v1.SessionAffinityConfig:
			return SessionAffinityConfig{V: &v}
		default:
			return skylark.None
		}
	}
	SessionAffinityConfig_attrs = setFieldTypes(t, SessionAffinityConfig_fields, SessionAffinityConfig_inline)
	Library["SessionAffinityConfig"] = skylark.NewBuiltin("SessionAffinityConfig", createSessionAffinityConfig)
}

func createSessionAffinityConfig(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for SessionAffinityConfig
}
func (t SessionAffinityConfig) UnderlyingKind() interface{} { return t.V }
func (t SessionAffinityConfig) Package() util.Package       { return util.V1 }
func (t SessionAffinityConfig) Type() string                { return "k8s_v1_SessionAffinityConfig" }
func (t SessionAffinityConfig) String() string              { return t.V.String() }
func (t SessionAffinityConfig) Freeze()                     {} // TODO
func (t SessionAffinityConfig) Truth() skylark.Bool         { return skylark.True }
func (t SessionAffinityConfig) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t SessionAffinityConfig) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*SessionAffinityConfig)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t SessionAffinityConfig) AttrNames() []string { return SessionAffinityConfig_attrs }
func (t SessionAffinityConfig) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, SessionAffinityConfig_fields, SessionAffinityConfig_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type StorageOSPersistentVolumeSource struct {
	V *v1.StorageOSPersistentVolumeSource
}

var (
	_ boxed = (*StorageOSPersistentVolumeSource)(nil)

	StorageOSPersistentVolumeSource_fields = map[string]util.FieldSpec{}
	StorageOSPersistentVolumeSource_inline = map[string]util.FieldSpec{}
	StorageOSPersistentVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.StorageOSPersistentVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.StorageOSPersistentVolumeSource:
			return StorageOSPersistentVolumeSource{V: v}
		case v1.StorageOSPersistentVolumeSource:
			return StorageOSPersistentVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	StorageOSPersistentVolumeSource_attrs = setFieldTypes(t, StorageOSPersistentVolumeSource_fields, StorageOSPersistentVolumeSource_inline)
	Library["StorageOSPersistentVolumeSource"] = skylark.NewBuiltin("StorageOSPersistentVolumeSource", createStorageOSPersistentVolumeSource)
}

func createStorageOSPersistentVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for StorageOSPersistentVolumeSource
}
func (t StorageOSPersistentVolumeSource) UnderlyingKind() interface{} { return t.V }
func (t StorageOSPersistentVolumeSource) Package() util.Package       { return util.V1 }
func (t StorageOSPersistentVolumeSource) Type() string {
	return "k8s_v1_StorageOSPersistentVolumeSource"
}
func (t StorageOSPersistentVolumeSource) String() string        { return t.V.String() }
func (t StorageOSPersistentVolumeSource) Freeze()               {} // TODO
func (t StorageOSPersistentVolumeSource) Truth() skylark.Bool   { return skylark.True }
func (t StorageOSPersistentVolumeSource) Hash() (uint32, error) { return 0, unhashable(t.Type()) }
func (t StorageOSPersistentVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*StorageOSPersistentVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t StorageOSPersistentVolumeSource) AttrNames() []string {
	return StorageOSPersistentVolumeSource_attrs
}
func (t StorageOSPersistentVolumeSource) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, StorageOSPersistentVolumeSource_fields, StorageOSPersistentVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type StorageOSVolumeSource struct {
	V *v1.StorageOSVolumeSource
}

var (
	_ boxed = (*StorageOSVolumeSource)(nil)

	StorageOSVolumeSource_fields = map[string]util.FieldSpec{}
	StorageOSVolumeSource_inline = map[string]util.FieldSpec{}
	StorageOSVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.StorageOSVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.StorageOSVolumeSource:
			return StorageOSVolumeSource{V: v}
		case v1.StorageOSVolumeSource:
			return StorageOSVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	StorageOSVolumeSource_attrs = setFieldTypes(t, StorageOSVolumeSource_fields, StorageOSVolumeSource_inline)
	Library["StorageOSVolumeSource"] = skylark.NewBuiltin("StorageOSVolumeSource", createStorageOSVolumeSource)
}

func createStorageOSVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for StorageOSVolumeSource
}
func (t StorageOSVolumeSource) UnderlyingKind() interface{} { return t.V }
func (t StorageOSVolumeSource) Package() util.Package       { return util.V1 }
func (t StorageOSVolumeSource) Type() string                { return "k8s_v1_StorageOSVolumeSource" }
func (t StorageOSVolumeSource) String() string              { return t.V.String() }
func (t StorageOSVolumeSource) Freeze()                     {} // TODO
func (t StorageOSVolumeSource) Truth() skylark.Bool         { return skylark.True }
func (t StorageOSVolumeSource) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t StorageOSVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*StorageOSVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t StorageOSVolumeSource) AttrNames() []string { return StorageOSVolumeSource_attrs }
func (t StorageOSVolumeSource) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, StorageOSVolumeSource_fields, StorageOSVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type Sysctl struct {
	V *v1.Sysctl
}

var (
	_ boxed = (*Sysctl)(nil)

	Sysctl_fields = map[string]util.FieldSpec{}
	Sysctl_inline = map[string]util.FieldSpec{}
	Sysctl_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.Sysctl)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.Sysctl:
			return Sysctl{V: v}
		case v1.Sysctl:
			return Sysctl{V: &v}
		default:
			return skylark.None
		}
	}
	Sysctl_attrs = setFieldTypes(t, Sysctl_fields, Sysctl_inline)
	Library["Sysctl"] = skylark.NewBuiltin("Sysctl", createSysctl)
}

func createSysctl(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for Sysctl
}
func (t Sysctl) UnderlyingKind() interface{} { return t.V }
func (t Sysctl) Package() util.Package       { return util.V1 }
func (t Sysctl) Type() string                { return "k8s_v1_Sysctl" }
func (t Sysctl) String() string              { return t.V.String() }
func (t Sysctl) Freeze()                     {} // TODO
func (t Sysctl) Truth() skylark.Bool         { return skylark.True }
func (t Sysctl) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t Sysctl) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*Sysctl)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t Sysctl) AttrNames() []string { return Sysctl_attrs }
func (t Sysctl) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, Sysctl_fields, Sysctl_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type TCPSocketAction struct {
	V *v1.TCPSocketAction
}

var (
	_ boxed = (*TCPSocketAction)(nil)

	TCPSocketAction_fields = map[string]util.FieldSpec{}
	TCPSocketAction_inline = map[string]util.FieldSpec{}
	TCPSocketAction_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.TCPSocketAction)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.TCPSocketAction:
			return TCPSocketAction{V: v}
		case v1.TCPSocketAction:
			return TCPSocketAction{V: &v}
		default:
			return skylark.None
		}
	}
	TCPSocketAction_attrs = setFieldTypes(t, TCPSocketAction_fields, TCPSocketAction_inline)
	Library["TCPSocketAction"] = skylark.NewBuiltin("TCPSocketAction", createTCPSocketAction)
}

func createTCPSocketAction(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for TCPSocketAction
}
func (t TCPSocketAction) UnderlyingKind() interface{} { return t.V }
func (t TCPSocketAction) Package() util.Package       { return util.V1 }
func (t TCPSocketAction) Type() string                { return "k8s_v1_TCPSocketAction" }
func (t TCPSocketAction) String() string              { return t.V.String() }
func (t TCPSocketAction) Freeze()                     {} // TODO
func (t TCPSocketAction) Truth() skylark.Bool         { return skylark.True }
func (t TCPSocketAction) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t TCPSocketAction) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*TCPSocketAction)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t TCPSocketAction) AttrNames() []string { return TCPSocketAction_attrs }
func (t TCPSocketAction) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, TCPSocketAction_fields, TCPSocketAction_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type Taint struct {
	V *v1.Taint
}

var (
	_ boxed = (*Taint)(nil)

	Taint_fields = map[string]util.FieldSpec{}
	Taint_inline = map[string]util.FieldSpec{}
	Taint_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.Taint)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.Taint:
			return Taint{V: v}
		case v1.Taint:
			return Taint{V: &v}
		default:
			return skylark.None
		}
	}
	Taint_attrs = setFieldTypes(t, Taint_fields, Taint_inline)
	Library["Taint"] = skylark.NewBuiltin("Taint", createTaint)
}

func createTaint(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for Taint
}
func (t Taint) UnderlyingKind() interface{} { return t.V }
func (t Taint) Package() util.Package       { return util.V1 }
func (t Taint) Type() string                { return "k8s_v1_Taint" }
func (t Taint) String() string              { return t.V.String() }
func (t Taint) Freeze()                     {} // TODO
func (t Taint) Truth() skylark.Bool         { return skylark.True }
func (t Taint) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t Taint) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*Taint)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t Taint) AttrNames() []string { return Taint_attrs }
func (t Taint) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, Taint_fields, Taint_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type Toleration struct {
	V *v1.Toleration
}

var (
	_ boxed = (*Toleration)(nil)

	Toleration_fields = map[string]util.FieldSpec{}
	Toleration_inline = map[string]util.FieldSpec{}
	Toleration_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.Toleration)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.Toleration:
			return Toleration{V: v}
		case v1.Toleration:
			return Toleration{V: &v}
		default:
			return skylark.None
		}
	}
	Toleration_attrs = setFieldTypes(t, Toleration_fields, Toleration_inline)
	Library["Toleration"] = skylark.NewBuiltin("Toleration", createToleration)
}

func createToleration(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for Toleration
}
func (t Toleration) UnderlyingKind() interface{} { return t.V }
func (t Toleration) Package() util.Package       { return util.V1 }
func (t Toleration) Type() string                { return "k8s_v1_Toleration" }
func (t Toleration) String() string              { return t.V.String() }
func (t Toleration) Freeze()                     {} // TODO
func (t Toleration) Truth() skylark.Bool         { return skylark.True }
func (t Toleration) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t Toleration) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*Toleration)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t Toleration) AttrNames() []string { return Toleration_attrs }
func (t Toleration) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, Toleration_fields, Toleration_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type TopologySelectorLabelRequirement struct {
	V *v1.TopologySelectorLabelRequirement
}

var (
	_ boxed = (*TopologySelectorLabelRequirement)(nil)

	TopologySelectorLabelRequirement_fields = map[string]util.FieldSpec{}
	TopologySelectorLabelRequirement_inline = map[string]util.FieldSpec{}
	TopologySelectorLabelRequirement_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.TopologySelectorLabelRequirement)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.TopologySelectorLabelRequirement:
			return TopologySelectorLabelRequirement{V: v}
		case v1.TopologySelectorLabelRequirement:
			return TopologySelectorLabelRequirement{V: &v}
		default:
			return skylark.None
		}
	}
	TopologySelectorLabelRequirement_attrs = setFieldTypes(t, TopologySelectorLabelRequirement_fields, TopologySelectorLabelRequirement_inline)
	Library["TopologySelectorLabelRequirement"] = skylark.NewBuiltin("TopologySelectorLabelRequirement", createTopologySelectorLabelRequirement)
}

func createTopologySelectorLabelRequirement(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for TopologySelectorLabelRequirement
}
func (t TopologySelectorLabelRequirement) UnderlyingKind() interface{} { return t.V }
func (t TopologySelectorLabelRequirement) Package() util.Package       { return util.V1 }
func (t TopologySelectorLabelRequirement) Type() string {
	return "k8s_v1_TopologySelectorLabelRequirement"
}
func (t TopologySelectorLabelRequirement) String() string        { return t.V.String() }
func (t TopologySelectorLabelRequirement) Freeze()               {} // TODO
func (t TopologySelectorLabelRequirement) Truth() skylark.Bool   { return skylark.True }
func (t TopologySelectorLabelRequirement) Hash() (uint32, error) { return 0, unhashable(t.Type()) }
func (t TopologySelectorLabelRequirement) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*TopologySelectorLabelRequirement)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t TopologySelectorLabelRequirement) AttrNames() []string {
	return TopologySelectorLabelRequirement_attrs
}
func (t TopologySelectorLabelRequirement) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, TopologySelectorLabelRequirement_fields, TopologySelectorLabelRequirement_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type TopologySelectorTerm struct {
	V *v1.TopologySelectorTerm
}

var (
	_ boxed = (*TopologySelectorTerm)(nil)

	TopologySelectorTerm_fields = map[string]util.FieldSpec{}
	TopologySelectorTerm_inline = map[string]util.FieldSpec{}
	TopologySelectorTerm_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.TopologySelectorTerm)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.TopologySelectorTerm:
			return TopologySelectorTerm{V: v}
		case v1.TopologySelectorTerm:
			return TopologySelectorTerm{V: &v}
		default:
			return skylark.None
		}
	}
	TopologySelectorTerm_attrs = setFieldTypes(t, TopologySelectorTerm_fields, TopologySelectorTerm_inline)
	Library["TopologySelectorTerm"] = skylark.NewBuiltin("TopologySelectorTerm", createTopologySelectorTerm)
}

func createTopologySelectorTerm(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for TopologySelectorTerm
}
func (t TopologySelectorTerm) UnderlyingKind() interface{} { return t.V }
func (t TopologySelectorTerm) Package() util.Package       { return util.V1 }
func (t TopologySelectorTerm) Type() string                { return "k8s_v1_TopologySelectorTerm" }
func (t TopologySelectorTerm) String() string              { return t.V.String() }
func (t TopologySelectorTerm) Freeze()                     {} // TODO
func (t TopologySelectorTerm) Truth() skylark.Bool         { return skylark.True }
func (t TopologySelectorTerm) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t TopologySelectorTerm) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*TopologySelectorTerm)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t TopologySelectorTerm) AttrNames() []string { return TopologySelectorTerm_attrs }
func (t TopologySelectorTerm) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, TopologySelectorTerm_fields, TopologySelectorTerm_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type Volume struct {
	V *v1.Volume
}

var (
	_ boxed = (*Volume)(nil)

	Volume_fields = map[string]util.FieldSpec{}
	Volume_inline = map[string]util.FieldSpec{}
	Volume_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.Volume)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.Volume:
			return Volume{V: v}
		case v1.Volume:
			return Volume{V: &v}
		default:
			return skylark.None
		}
	}
	Volume_attrs = setFieldTypes(t, Volume_fields, Volume_inline)
	Library["Volume"] = skylark.NewBuiltin("Volume", createVolume)
}

func createVolume(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for Volume
}
func (t Volume) UnderlyingKind() interface{} { return t.V }
func (t Volume) Package() util.Package       { return util.V1 }
func (t Volume) Type() string                { return "k8s_v1_Volume" }
func (t Volume) String() string              { return t.V.String() }
func (t Volume) Freeze()                     {} // TODO
func (t Volume) Truth() skylark.Bool         { return skylark.True }
func (t Volume) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t Volume) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*Volume)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t Volume) AttrNames() []string { return Volume_attrs }
func (t Volume) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, Volume_fields, Volume_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type VolumeDevice struct {
	V *v1.VolumeDevice
}

var (
	_ boxed = (*VolumeDevice)(nil)

	VolumeDevice_fields = map[string]util.FieldSpec{}
	VolumeDevice_inline = map[string]util.FieldSpec{}
	VolumeDevice_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.VolumeDevice)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.VolumeDevice:
			return VolumeDevice{V: v}
		case v1.VolumeDevice:
			return VolumeDevice{V: &v}
		default:
			return skylark.None
		}
	}
	VolumeDevice_attrs = setFieldTypes(t, VolumeDevice_fields, VolumeDevice_inline)
	Library["VolumeDevice"] = skylark.NewBuiltin("VolumeDevice", createVolumeDevice)
}

func createVolumeDevice(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for VolumeDevice
}
func (t VolumeDevice) UnderlyingKind() interface{} { return t.V }
func (t VolumeDevice) Package() util.Package       { return util.V1 }
func (t VolumeDevice) Type() string                { return "k8s_v1_VolumeDevice" }
func (t VolumeDevice) String() string              { return t.V.String() }
func (t VolumeDevice) Freeze()                     {} // TODO
func (t VolumeDevice) Truth() skylark.Bool         { return skylark.True }
func (t VolumeDevice) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t VolumeDevice) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*VolumeDevice)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t VolumeDevice) AttrNames() []string { return VolumeDevice_attrs }
func (t VolumeDevice) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, VolumeDevice_fields, VolumeDevice_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type VolumeMount struct {
	V *v1.VolumeMount
}

var (
	_ boxed = (*VolumeMount)(nil)

	VolumeMount_fields = map[string]util.FieldSpec{}
	VolumeMount_inline = map[string]util.FieldSpec{}
	VolumeMount_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.VolumeMount)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.VolumeMount:
			return VolumeMount{V: v}
		case v1.VolumeMount:
			return VolumeMount{V: &v}
		default:
			return skylark.None
		}
	}
	VolumeMount_attrs = setFieldTypes(t, VolumeMount_fields, VolumeMount_inline)
	Library["VolumeMount"] = skylark.NewBuiltin("VolumeMount", createVolumeMount)
}

func createVolumeMount(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for VolumeMount
}
func (t VolumeMount) UnderlyingKind() interface{} { return t.V }
func (t VolumeMount) Package() util.Package       { return util.V1 }
func (t VolumeMount) Type() string                { return "k8s_v1_VolumeMount" }
func (t VolumeMount) String() string              { return t.V.String() }
func (t VolumeMount) Freeze()                     {} // TODO
func (t VolumeMount) Truth() skylark.Bool         { return skylark.True }
func (t VolumeMount) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t VolumeMount) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*VolumeMount)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t VolumeMount) AttrNames() []string { return VolumeMount_attrs }
func (t VolumeMount) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, VolumeMount_fields, VolumeMount_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type VolumeNodeAffinity struct {
	V *v1.VolumeNodeAffinity
}

var (
	_ boxed = (*VolumeNodeAffinity)(nil)

	VolumeNodeAffinity_fields = map[string]util.FieldSpec{}
	VolumeNodeAffinity_inline = map[string]util.FieldSpec{}
	VolumeNodeAffinity_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.VolumeNodeAffinity)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.VolumeNodeAffinity:
			return VolumeNodeAffinity{V: v}
		case v1.VolumeNodeAffinity:
			return VolumeNodeAffinity{V: &v}
		default:
			return skylark.None
		}
	}
	VolumeNodeAffinity_attrs = setFieldTypes(t, VolumeNodeAffinity_fields, VolumeNodeAffinity_inline)
	Library["VolumeNodeAffinity"] = skylark.NewBuiltin("VolumeNodeAffinity", createVolumeNodeAffinity)
}

func createVolumeNodeAffinity(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for VolumeNodeAffinity
}
func (t VolumeNodeAffinity) UnderlyingKind() interface{} { return t.V }
func (t VolumeNodeAffinity) Package() util.Package       { return util.V1 }
func (t VolumeNodeAffinity) Type() string                { return "k8s_v1_VolumeNodeAffinity" }
func (t VolumeNodeAffinity) String() string              { return t.V.String() }
func (t VolumeNodeAffinity) Freeze()                     {} // TODO
func (t VolumeNodeAffinity) Truth() skylark.Bool         { return skylark.True }
func (t VolumeNodeAffinity) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t VolumeNodeAffinity) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*VolumeNodeAffinity)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t VolumeNodeAffinity) AttrNames() []string { return VolumeNodeAffinity_attrs }
func (t VolumeNodeAffinity) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, VolumeNodeAffinity_fields, VolumeNodeAffinity_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type VolumeProjection struct {
	V *v1.VolumeProjection
}

var (
	_ boxed = (*VolumeProjection)(nil)

	VolumeProjection_fields = map[string]util.FieldSpec{}
	VolumeProjection_inline = map[string]util.FieldSpec{}
	VolumeProjection_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.VolumeProjection)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.VolumeProjection:
			return VolumeProjection{V: v}
		case v1.VolumeProjection:
			return VolumeProjection{V: &v}
		default:
			return skylark.None
		}
	}
	VolumeProjection_attrs = setFieldTypes(t, VolumeProjection_fields, VolumeProjection_inline)
	Library["VolumeProjection"] = skylark.NewBuiltin("VolumeProjection", createVolumeProjection)
}

func createVolumeProjection(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for VolumeProjection
}
func (t VolumeProjection) UnderlyingKind() interface{} { return t.V }
func (t VolumeProjection) Package() util.Package       { return util.V1 }
func (t VolumeProjection) Type() string                { return "k8s_v1_VolumeProjection" }
func (t VolumeProjection) String() string              { return t.V.String() }
func (t VolumeProjection) Freeze()                     {} // TODO
func (t VolumeProjection) Truth() skylark.Bool         { return skylark.True }
func (t VolumeProjection) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t VolumeProjection) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*VolumeProjection)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t VolumeProjection) AttrNames() []string { return VolumeProjection_attrs }
func (t VolumeProjection) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, VolumeProjection_fields, VolumeProjection_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type VolumeSource struct {
	V *v1.VolumeSource
}

var (
	_ boxed = (*VolumeSource)(nil)

	VolumeSource_fields = map[string]util.FieldSpec{}
	VolumeSource_inline = map[string]util.FieldSpec{}
	VolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.VolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.VolumeSource:
			return VolumeSource{V: v}
		case v1.VolumeSource:
			return VolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	VolumeSource_attrs = setFieldTypes(t, VolumeSource_fields, VolumeSource_inline)
	Library["VolumeSource"] = skylark.NewBuiltin("VolumeSource", createVolumeSource)
}

func createVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for VolumeSource
}
func (t VolumeSource) UnderlyingKind() interface{} { return t.V }
func (t VolumeSource) Package() util.Package       { return util.V1 }
func (t VolumeSource) Type() string                { return "k8s_v1_VolumeSource" }
func (t VolumeSource) String() string              { return t.V.String() }
func (t VolumeSource) Freeze()                     {} // TODO
func (t VolumeSource) Truth() skylark.Bool         { return skylark.True }
func (t VolumeSource) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t VolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*VolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t VolumeSource) AttrNames() []string { return VolumeSource_attrs }
func (t VolumeSource) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, VolumeSource_fields, VolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type VsphereVirtualDiskVolumeSource struct {
	V *v1.VsphereVirtualDiskVolumeSource
}

var (
	_ boxed = (*VsphereVirtualDiskVolumeSource)(nil)

	VsphereVirtualDiskVolumeSource_fields = map[string]util.FieldSpec{}
	VsphereVirtualDiskVolumeSource_inline = map[string]util.FieldSpec{}
	VsphereVirtualDiskVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.VsphereVirtualDiskVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.VsphereVirtualDiskVolumeSource:
			return VsphereVirtualDiskVolumeSource{V: v}
		case v1.VsphereVirtualDiskVolumeSource:
			return VsphereVirtualDiskVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	VsphereVirtualDiskVolumeSource_attrs = setFieldTypes(t, VsphereVirtualDiskVolumeSource_fields, VsphereVirtualDiskVolumeSource_inline)
	Library["VsphereVirtualDiskVolumeSource"] = skylark.NewBuiltin("VsphereVirtualDiskVolumeSource", createVsphereVirtualDiskVolumeSource)
}

func createVsphereVirtualDiskVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for VsphereVirtualDiskVolumeSource
}
func (t VsphereVirtualDiskVolumeSource) UnderlyingKind() interface{} { return t.V }
func (t VsphereVirtualDiskVolumeSource) Package() util.Package       { return util.V1 }
func (t VsphereVirtualDiskVolumeSource) Type() string                { return "k8s_v1_VsphereVirtualDiskVolumeSource" }
func (t VsphereVirtualDiskVolumeSource) String() string              { return t.V.String() }
func (t VsphereVirtualDiskVolumeSource) Freeze()                     {} // TODO
func (t VsphereVirtualDiskVolumeSource) Truth() skylark.Bool         { return skylark.True }
func (t VsphereVirtualDiskVolumeSource) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t VsphereVirtualDiskVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*VsphereVirtualDiskVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t VsphereVirtualDiskVolumeSource) AttrNames() []string {
	return VsphereVirtualDiskVolumeSource_attrs
}
func (t VsphereVirtualDiskVolumeSource) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, VsphereVirtualDiskVolumeSource_fields, VsphereVirtualDiskVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type WeightedPodAffinityTerm struct {
	V *v1.WeightedPodAffinityTerm
}

var (
	_ boxed = (*WeightedPodAffinityTerm)(nil)

	WeightedPodAffinityTerm_fields = map[string]util.FieldSpec{}
	WeightedPodAffinityTerm_inline = map[string]util.FieldSpec{}
	WeightedPodAffinityTerm_attrs  []string
)

func init() {
	t := reflect.TypeOf((*v1.WeightedPodAffinityTerm)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *v1.WeightedPodAffinityTerm:
			return WeightedPodAffinityTerm{V: v}
		case v1.WeightedPodAffinityTerm:
			return WeightedPodAffinityTerm{V: &v}
		default:
			return skylark.None
		}
	}
	WeightedPodAffinityTerm_attrs = setFieldTypes(t, WeightedPodAffinityTerm_fields, WeightedPodAffinityTerm_inline)
	Library["WeightedPodAffinityTerm"] = skylark.NewBuiltin("WeightedPodAffinityTerm", createWeightedPodAffinityTerm)
}

func createWeightedPodAffinityTerm(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for WeightedPodAffinityTerm
}
func (t WeightedPodAffinityTerm) UnderlyingKind() interface{} { return t.V }
func (t WeightedPodAffinityTerm) Package() util.Package       { return util.V1 }
func (t WeightedPodAffinityTerm) Type() string                { return "k8s_v1_WeightedPodAffinityTerm" }
func (t WeightedPodAffinityTerm) String() string              { return t.V.String() }
func (t WeightedPodAffinityTerm) Freeze()                     {} // TODO
func (t WeightedPodAffinityTerm) Truth() skylark.Bool         { return skylark.True }
func (t WeightedPodAffinityTerm) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t WeightedPodAffinityTerm) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*WeightedPodAffinityTerm)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t WeightedPodAffinityTerm) AttrNames() []string { return WeightedPodAffinityTerm_attrs }
func (t WeightedPodAffinityTerm) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, WeightedPodAffinityTerm_fields, WeightedPodAffinityTerm_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type APIGroup struct {
	V *metav1.APIGroup
}

var (
	_ boxed = (*APIGroup)(nil)

	APIGroup_fields = map[string]util.FieldSpec{}
	APIGroup_inline = map[string]util.FieldSpec{}
	APIGroup_attrs  []string
)

func init() {
	t := reflect.TypeOf((*metav1.APIGroup)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *metav1.APIGroup:
			return APIGroup{V: v}
		case metav1.APIGroup:
			return APIGroup{V: &v}
		default:
			return skylark.None
		}
	}
	APIGroup_attrs = setFieldTypes(t, APIGroup_fields, APIGroup_inline)
	Library["APIGroup"] = skylark.NewBuiltin("APIGroup", createAPIGroup)
}

func createAPIGroup(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for APIGroup
}
func (t APIGroup) UnderlyingKind() interface{} { return t.V }
func (t APIGroup) Package() util.Package       { return util.Metav1 }
func (t APIGroup) Type() string                { return "k8s_metav1_APIGroup" }
func (t APIGroup) String() string              { return t.V.String() }
func (t APIGroup) Freeze()                     {} // TODO
func (t APIGroup) Truth() skylark.Bool         { return skylark.True }
func (t APIGroup) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t APIGroup) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*APIGroup)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t APIGroup) AttrNames() []string { return APIGroup_attrs }
func (t APIGroup) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, APIGroup_fields, APIGroup_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type APIGroupList struct {
	V *metav1.APIGroupList
}

var (
	_ boxed = (*APIGroupList)(nil)

	APIGroupList_fields = map[string]util.FieldSpec{}
	APIGroupList_inline = map[string]util.FieldSpec{}
	APIGroupList_attrs  []string
)

func init() {
	t := reflect.TypeOf((*metav1.APIGroupList)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *metav1.APIGroupList:
			return APIGroupList{V: v}
		case metav1.APIGroupList:
			return APIGroupList{V: &v}
		default:
			return skylark.None
		}
	}
	APIGroupList_attrs = setFieldTypes(t, APIGroupList_fields, APIGroupList_inline)
	Library["APIGroupList"] = skylark.NewBuiltin("APIGroupList", createAPIGroupList)
}

func createAPIGroupList(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for APIGroupList
}
func (t APIGroupList) UnderlyingKind() interface{} { return t.V }
func (t APIGroupList) Package() util.Package       { return util.Metav1 }
func (t APIGroupList) Type() string                { return "k8s_metav1_APIGroupList" }
func (t APIGroupList) String() string              { return t.V.String() }
func (t APIGroupList) Freeze()                     {} // TODO
func (t APIGroupList) Truth() skylark.Bool         { return skylark.True }
func (t APIGroupList) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t APIGroupList) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*APIGroupList)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t APIGroupList) AttrNames() []string { return APIGroupList_attrs }
func (t APIGroupList) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, APIGroupList_fields, APIGroupList_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type APIResource struct {
	V *metav1.APIResource
}

var (
	_ boxed = (*APIResource)(nil)

	APIResource_fields = map[string]util.FieldSpec{}
	APIResource_inline = map[string]util.FieldSpec{}
	APIResource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*metav1.APIResource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *metav1.APIResource:
			return APIResource{V: v}
		case metav1.APIResource:
			return APIResource{V: &v}
		default:
			return skylark.None
		}
	}
	APIResource_attrs = setFieldTypes(t, APIResource_fields, APIResource_inline)
	Library["APIResource"] = skylark.NewBuiltin("APIResource", createAPIResource)
}

func createAPIResource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for APIResource
}
func (t APIResource) UnderlyingKind() interface{} { return t.V }
func (t APIResource) Package() util.Package       { return util.Metav1 }
func (t APIResource) Type() string                { return "k8s_metav1_APIResource" }
func (t APIResource) String() string              { return t.V.String() }
func (t APIResource) Freeze()                     {} // TODO
func (t APIResource) Truth() skylark.Bool         { return skylark.True }
func (t APIResource) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t APIResource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*APIResource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t APIResource) AttrNames() []string { return APIResource_attrs }
func (t APIResource) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, APIResource_fields, APIResource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type APIResourceList struct {
	V *metav1.APIResourceList
}

var (
	_ boxed = (*APIResourceList)(nil)

	APIResourceList_fields = map[string]util.FieldSpec{}
	APIResourceList_inline = map[string]util.FieldSpec{}
	APIResourceList_attrs  []string
)

func init() {
	t := reflect.TypeOf((*metav1.APIResourceList)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *metav1.APIResourceList:
			return APIResourceList{V: v}
		case metav1.APIResourceList:
			return APIResourceList{V: &v}
		default:
			return skylark.None
		}
	}
	APIResourceList_attrs = setFieldTypes(t, APIResourceList_fields, APIResourceList_inline)
	Library["APIResourceList"] = skylark.NewBuiltin("APIResourceList", createAPIResourceList)
}

func createAPIResourceList(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for APIResourceList
}
func (t APIResourceList) UnderlyingKind() interface{} { return t.V }
func (t APIResourceList) Package() util.Package       { return util.Metav1 }
func (t APIResourceList) Type() string                { return "k8s_metav1_APIResourceList" }
func (t APIResourceList) String() string              { return t.V.String() }
func (t APIResourceList) Freeze()                     {} // TODO
func (t APIResourceList) Truth() skylark.Bool         { return skylark.True }
func (t APIResourceList) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t APIResourceList) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*APIResourceList)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t APIResourceList) AttrNames() []string { return APIResourceList_attrs }
func (t APIResourceList) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, APIResourceList_fields, APIResourceList_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type APIVersions struct {
	V *metav1.APIVersions
}

var (
	_ boxed = (*APIVersions)(nil)

	APIVersions_fields = map[string]util.FieldSpec{}
	APIVersions_inline = map[string]util.FieldSpec{}
	APIVersions_attrs  []string
)

func init() {
	t := reflect.TypeOf((*metav1.APIVersions)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *metav1.APIVersions:
			return APIVersions{V: v}
		case metav1.APIVersions:
			return APIVersions{V: &v}
		default:
			return skylark.None
		}
	}
	APIVersions_attrs = setFieldTypes(t, APIVersions_fields, APIVersions_inline)
	Library["APIVersions"] = skylark.NewBuiltin("APIVersions", createAPIVersions)
}

func createAPIVersions(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for APIVersions
}
func (t APIVersions) UnderlyingKind() interface{} { return t.V }
func (t APIVersions) Package() util.Package       { return util.Metav1 }
func (t APIVersions) Type() string                { return "k8s_metav1_APIVersions" }
func (t APIVersions) String() string              { return t.V.String() }
func (t APIVersions) Freeze()                     {} // TODO
func (t APIVersions) Truth() skylark.Bool         { return skylark.True }
func (t APIVersions) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t APIVersions) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*APIVersions)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t APIVersions) AttrNames() []string { return APIVersions_attrs }
func (t APIVersions) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, APIVersions_fields, APIVersions_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type CreateOptions struct {
	V *metav1.CreateOptions
}

var (
	_ boxed = (*CreateOptions)(nil)

	CreateOptions_fields = map[string]util.FieldSpec{}
	CreateOptions_inline = map[string]util.FieldSpec{}
	CreateOptions_attrs  []string
)

func init() {
	t := reflect.TypeOf((*metav1.CreateOptions)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *metav1.CreateOptions:
			return CreateOptions{V: v}
		case metav1.CreateOptions:
			return CreateOptions{V: &v}
		default:
			return skylark.None
		}
	}
	CreateOptions_attrs = setFieldTypes(t, CreateOptions_fields, CreateOptions_inline)
	Library["CreateOptions"] = skylark.NewBuiltin("CreateOptions", createCreateOptions)
}

func createCreateOptions(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for CreateOptions
}
func (t CreateOptions) UnderlyingKind() interface{} { return t.V }
func (t CreateOptions) Package() util.Package       { return util.Metav1 }
func (t CreateOptions) Type() string                { return "k8s_metav1_CreateOptions" }
func (t CreateOptions) String() string              { return t.V.String() }
func (t CreateOptions) Freeze()                     {} // TODO
func (t CreateOptions) Truth() skylark.Bool         { return skylark.True }
func (t CreateOptions) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t CreateOptions) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*CreateOptions)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t CreateOptions) AttrNames() []string { return CreateOptions_attrs }
func (t CreateOptions) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, CreateOptions_fields, CreateOptions_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type DeleteOptions struct {
	V *metav1.DeleteOptions
}

var (
	_ boxed = (*DeleteOptions)(nil)

	DeleteOptions_fields = map[string]util.FieldSpec{}
	DeleteOptions_inline = map[string]util.FieldSpec{}
	DeleteOptions_attrs  []string
)

func init() {
	t := reflect.TypeOf((*metav1.DeleteOptions)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *metav1.DeleteOptions:
			return DeleteOptions{V: v}
		case metav1.DeleteOptions:
			return DeleteOptions{V: &v}
		default:
			return skylark.None
		}
	}
	DeleteOptions_attrs = setFieldTypes(t, DeleteOptions_fields, DeleteOptions_inline)
	Library["DeleteOptions"] = skylark.NewBuiltin("DeleteOptions", createDeleteOptions)
}

func createDeleteOptions(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for DeleteOptions
}
func (t DeleteOptions) UnderlyingKind() interface{} { return t.V }
func (t DeleteOptions) Package() util.Package       { return util.Metav1 }
func (t DeleteOptions) Type() string                { return "k8s_metav1_DeleteOptions" }
func (t DeleteOptions) String() string              { return t.V.String() }
func (t DeleteOptions) Freeze()                     {} // TODO
func (t DeleteOptions) Truth() skylark.Bool         { return skylark.True }
func (t DeleteOptions) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t DeleteOptions) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*DeleteOptions)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t DeleteOptions) AttrNames() []string { return DeleteOptions_attrs }
func (t DeleteOptions) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, DeleteOptions_fields, DeleteOptions_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type Duration struct {
	V *metav1.Duration
}

var (
	_ boxed = (*Duration)(nil)

	Duration_fields = map[string]util.FieldSpec{}
	Duration_inline = map[string]util.FieldSpec{}
	Duration_attrs  []string
)

func init() {
	t := reflect.TypeOf((*metav1.Duration)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *metav1.Duration:
			return Duration{V: v}
		case metav1.Duration:
			return Duration{V: &v}
		default:
			return skylark.None
		}
	}
	Duration_attrs = setFieldTypes(t, Duration_fields, Duration_inline)
	Library["Duration"] = skylark.NewBuiltin("Duration", createDuration)
}

func createDuration(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for Duration
}
func (t Duration) UnderlyingKind() interface{} { return t.V }
func (t Duration) Package() util.Package       { return util.Metav1 }
func (t Duration) Type() string                { return "k8s_metav1_Duration" }
func (t Duration) String() string              { return t.V.String() }
func (t Duration) Freeze()                     {} // TODO
func (t Duration) Truth() skylark.Bool         { return skylark.True }
func (t Duration) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t Duration) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*Duration)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t Duration) AttrNames() []string { return Duration_attrs }
func (t Duration) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, Duration_fields, Duration_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type ExportOptions struct {
	V *metav1.ExportOptions
}

var (
	_ boxed = (*ExportOptions)(nil)

	ExportOptions_fields = map[string]util.FieldSpec{}
	ExportOptions_inline = map[string]util.FieldSpec{}
	ExportOptions_attrs  []string
)

func init() {
	t := reflect.TypeOf((*metav1.ExportOptions)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *metav1.ExportOptions:
			return ExportOptions{V: v}
		case metav1.ExportOptions:
			return ExportOptions{V: &v}
		default:
			return skylark.None
		}
	}
	ExportOptions_attrs = setFieldTypes(t, ExportOptions_fields, ExportOptions_inline)
	Library["ExportOptions"] = skylark.NewBuiltin("ExportOptions", createExportOptions)
}

func createExportOptions(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for ExportOptions
}
func (t ExportOptions) UnderlyingKind() interface{} { return t.V }
func (t ExportOptions) Package() util.Package       { return util.Metav1 }
func (t ExportOptions) Type() string                { return "k8s_metav1_ExportOptions" }
func (t ExportOptions) String() string              { return t.V.String() }
func (t ExportOptions) Freeze()                     {} // TODO
func (t ExportOptions) Truth() skylark.Bool         { return skylark.True }
func (t ExportOptions) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t ExportOptions) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ExportOptions)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ExportOptions) AttrNames() []string { return ExportOptions_attrs }
func (t ExportOptions) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, ExportOptions_fields, ExportOptions_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type GetOptions struct {
	V *metav1.GetOptions
}

var (
	_ boxed = (*GetOptions)(nil)

	GetOptions_fields = map[string]util.FieldSpec{}
	GetOptions_inline = map[string]util.FieldSpec{}
	GetOptions_attrs  []string
)

func init() {
	t := reflect.TypeOf((*metav1.GetOptions)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *metav1.GetOptions:
			return GetOptions{V: v}
		case metav1.GetOptions:
			return GetOptions{V: &v}
		default:
			return skylark.None
		}
	}
	GetOptions_attrs = setFieldTypes(t, GetOptions_fields, GetOptions_inline)
	Library["GetOptions"] = skylark.NewBuiltin("GetOptions", createGetOptions)
}

func createGetOptions(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for GetOptions
}
func (t GetOptions) UnderlyingKind() interface{} { return t.V }
func (t GetOptions) Package() util.Package       { return util.Metav1 }
func (t GetOptions) Type() string                { return "k8s_metav1_GetOptions" }
func (t GetOptions) String() string              { return t.V.String() }
func (t GetOptions) Freeze()                     {} // TODO
func (t GetOptions) Truth() skylark.Bool         { return skylark.True }
func (t GetOptions) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t GetOptions) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*GetOptions)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t GetOptions) AttrNames() []string { return GetOptions_attrs }
func (t GetOptions) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, GetOptions_fields, GetOptions_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type GroupKind struct {
	V *metav1.GroupKind
}

var (
	_ boxed = (*GroupKind)(nil)

	GroupKind_fields = map[string]util.FieldSpec{}
	GroupKind_inline = map[string]util.FieldSpec{}
	GroupKind_attrs  []string
)

func init() {
	t := reflect.TypeOf((*metav1.GroupKind)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *metav1.GroupKind:
			return GroupKind{V: v}
		case metav1.GroupKind:
			return GroupKind{V: &v}
		default:
			return skylark.None
		}
	}
	GroupKind_attrs = setFieldTypes(t, GroupKind_fields, GroupKind_inline)
	Library["GroupKind"] = skylark.NewBuiltin("GroupKind", createGroupKind)
}

func createGroupKind(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for GroupKind
}
func (t GroupKind) UnderlyingKind() interface{} { return t.V }
func (t GroupKind) Package() util.Package       { return util.Metav1 }
func (t GroupKind) Type() string                { return "k8s_metav1_GroupKind" }
func (t GroupKind) String() string              { return t.V.String() }
func (t GroupKind) Freeze()                     {} // TODO
func (t GroupKind) Truth() skylark.Bool         { return skylark.True }
func (t GroupKind) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t GroupKind) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*GroupKind)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t GroupKind) AttrNames() []string { return GroupKind_attrs }
func (t GroupKind) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, GroupKind_fields, GroupKind_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type GroupResource struct {
	V *metav1.GroupResource
}

var (
	_ boxed = (*GroupResource)(nil)

	GroupResource_fields = map[string]util.FieldSpec{}
	GroupResource_inline = map[string]util.FieldSpec{}
	GroupResource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*metav1.GroupResource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *metav1.GroupResource:
			return GroupResource{V: v}
		case metav1.GroupResource:
			return GroupResource{V: &v}
		default:
			return skylark.None
		}
	}
	GroupResource_attrs = setFieldTypes(t, GroupResource_fields, GroupResource_inline)
	Library["GroupResource"] = skylark.NewBuiltin("GroupResource", createGroupResource)
}

func createGroupResource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for GroupResource
}
func (t GroupResource) UnderlyingKind() interface{} { return t.V }
func (t GroupResource) Package() util.Package       { return util.Metav1 }
func (t GroupResource) Type() string                { return "k8s_metav1_GroupResource" }
func (t GroupResource) String() string              { return t.V.String() }
func (t GroupResource) Freeze()                     {} // TODO
func (t GroupResource) Truth() skylark.Bool         { return skylark.True }
func (t GroupResource) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t GroupResource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*GroupResource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t GroupResource) AttrNames() []string { return GroupResource_attrs }
func (t GroupResource) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, GroupResource_fields, GroupResource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type GroupVersion struct {
	V *metav1.GroupVersion
}

var (
	_ boxed = (*GroupVersion)(nil)

	GroupVersion_fields = map[string]util.FieldSpec{}
	GroupVersion_inline = map[string]util.FieldSpec{}
	GroupVersion_attrs  []string
)

func init() {
	t := reflect.TypeOf((*metav1.GroupVersion)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *metav1.GroupVersion:
			return GroupVersion{V: v}
		case metav1.GroupVersion:
			return GroupVersion{V: &v}
		default:
			return skylark.None
		}
	}
	GroupVersion_attrs = setFieldTypes(t, GroupVersion_fields, GroupVersion_inline)
	Library["GroupVersion"] = skylark.NewBuiltin("GroupVersion", createGroupVersion)
}

func createGroupVersion(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for GroupVersion
}
func (t GroupVersion) UnderlyingKind() interface{} { return t.V }
func (t GroupVersion) Package() util.Package       { return util.Metav1 }
func (t GroupVersion) Type() string                { return "k8s_metav1_GroupVersion" }
func (t GroupVersion) String() string              { return t.V.String() }
func (t GroupVersion) Freeze()                     {} // TODO
func (t GroupVersion) Truth() skylark.Bool         { return skylark.True }
func (t GroupVersion) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t GroupVersion) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*GroupVersion)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t GroupVersion) AttrNames() []string { return GroupVersion_attrs }
func (t GroupVersion) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, GroupVersion_fields, GroupVersion_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type GroupVersionForDiscovery struct {
	V *metav1.GroupVersionForDiscovery
}

var (
	_ boxed = (*GroupVersionForDiscovery)(nil)

	GroupVersionForDiscovery_fields = map[string]util.FieldSpec{}
	GroupVersionForDiscovery_inline = map[string]util.FieldSpec{}
	GroupVersionForDiscovery_attrs  []string
)

func init() {
	t := reflect.TypeOf((*metav1.GroupVersionForDiscovery)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *metav1.GroupVersionForDiscovery:
			return GroupVersionForDiscovery{V: v}
		case metav1.GroupVersionForDiscovery:
			return GroupVersionForDiscovery{V: &v}
		default:
			return skylark.None
		}
	}
	GroupVersionForDiscovery_attrs = setFieldTypes(t, GroupVersionForDiscovery_fields, GroupVersionForDiscovery_inline)
	Library["GroupVersionForDiscovery"] = skylark.NewBuiltin("GroupVersionForDiscovery", createGroupVersionForDiscovery)
}

func createGroupVersionForDiscovery(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for GroupVersionForDiscovery
}
func (t GroupVersionForDiscovery) UnderlyingKind() interface{} { return t.V }
func (t GroupVersionForDiscovery) Package() util.Package       { return util.Metav1 }
func (t GroupVersionForDiscovery) Type() string                { return "k8s_metav1_GroupVersionForDiscovery" }
func (t GroupVersionForDiscovery) String() string              { return t.V.String() }
func (t GroupVersionForDiscovery) Freeze()                     {} // TODO
func (t GroupVersionForDiscovery) Truth() skylark.Bool         { return skylark.True }
func (t GroupVersionForDiscovery) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t GroupVersionForDiscovery) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*GroupVersionForDiscovery)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t GroupVersionForDiscovery) AttrNames() []string { return GroupVersionForDiscovery_attrs }
func (t GroupVersionForDiscovery) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, GroupVersionForDiscovery_fields, GroupVersionForDiscovery_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type GroupVersionKind struct {
	V *metav1.GroupVersionKind
}

var (
	_ boxed = (*GroupVersionKind)(nil)

	GroupVersionKind_fields = map[string]util.FieldSpec{}
	GroupVersionKind_inline = map[string]util.FieldSpec{}
	GroupVersionKind_attrs  []string
)

func init() {
	t := reflect.TypeOf((*metav1.GroupVersionKind)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *metav1.GroupVersionKind:
			return GroupVersionKind{V: v}
		case metav1.GroupVersionKind:
			return GroupVersionKind{V: &v}
		default:
			return skylark.None
		}
	}
	GroupVersionKind_attrs = setFieldTypes(t, GroupVersionKind_fields, GroupVersionKind_inline)
	Library["GroupVersionKind"] = skylark.NewBuiltin("GroupVersionKind", createGroupVersionKind)
}

func createGroupVersionKind(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for GroupVersionKind
}
func (t GroupVersionKind) UnderlyingKind() interface{} { return t.V }
func (t GroupVersionKind) Package() util.Package       { return util.Metav1 }
func (t GroupVersionKind) Type() string                { return "k8s_metav1_GroupVersionKind" }
func (t GroupVersionKind) String() string              { return t.V.String() }
func (t GroupVersionKind) Freeze()                     {} // TODO
func (t GroupVersionKind) Truth() skylark.Bool         { return skylark.True }
func (t GroupVersionKind) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t GroupVersionKind) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*GroupVersionKind)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t GroupVersionKind) AttrNames() []string { return GroupVersionKind_attrs }
func (t GroupVersionKind) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, GroupVersionKind_fields, GroupVersionKind_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type GroupVersionResource struct {
	V *metav1.GroupVersionResource
}

var (
	_ boxed = (*GroupVersionResource)(nil)

	GroupVersionResource_fields = map[string]util.FieldSpec{}
	GroupVersionResource_inline = map[string]util.FieldSpec{}
	GroupVersionResource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*metav1.GroupVersionResource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *metav1.GroupVersionResource:
			return GroupVersionResource{V: v}
		case metav1.GroupVersionResource:
			return GroupVersionResource{V: &v}
		default:
			return skylark.None
		}
	}
	GroupVersionResource_attrs = setFieldTypes(t, GroupVersionResource_fields, GroupVersionResource_inline)
	Library["GroupVersionResource"] = skylark.NewBuiltin("GroupVersionResource", createGroupVersionResource)
}

func createGroupVersionResource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for GroupVersionResource
}
func (t GroupVersionResource) UnderlyingKind() interface{} { return t.V }
func (t GroupVersionResource) Package() util.Package       { return util.Metav1 }
func (t GroupVersionResource) Type() string                { return "k8s_metav1_GroupVersionResource" }
func (t GroupVersionResource) String() string              { return t.V.String() }
func (t GroupVersionResource) Freeze()                     {} // TODO
func (t GroupVersionResource) Truth() skylark.Bool         { return skylark.True }
func (t GroupVersionResource) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t GroupVersionResource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*GroupVersionResource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t GroupVersionResource) AttrNames() []string { return GroupVersionResource_attrs }
func (t GroupVersionResource) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, GroupVersionResource_fields, GroupVersionResource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type Initializer struct {
	V *metav1.Initializer
}

var (
	_ boxed = (*Initializer)(nil)

	Initializer_fields = map[string]util.FieldSpec{}
	Initializer_inline = map[string]util.FieldSpec{}
	Initializer_attrs  []string
)

func init() {
	t := reflect.TypeOf((*metav1.Initializer)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *metav1.Initializer:
			return Initializer{V: v}
		case metav1.Initializer:
			return Initializer{V: &v}
		default:
			return skylark.None
		}
	}
	Initializer_attrs = setFieldTypes(t, Initializer_fields, Initializer_inline)
	Library["Initializer"] = skylark.NewBuiltin("Initializer", createInitializer)
}

func createInitializer(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for Initializer
}
func (t Initializer) UnderlyingKind() interface{} { return t.V }
func (t Initializer) Package() util.Package       { return util.Metav1 }
func (t Initializer) Type() string                { return "k8s_metav1_Initializer" }
func (t Initializer) String() string              { return t.V.String() }
func (t Initializer) Freeze()                     {} // TODO
func (t Initializer) Truth() skylark.Bool         { return skylark.True }
func (t Initializer) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t Initializer) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*Initializer)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t Initializer) AttrNames() []string { return Initializer_attrs }
func (t Initializer) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, Initializer_fields, Initializer_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type Initializers struct {
	V *metav1.Initializers
}

var (
	_ boxed = (*Initializers)(nil)

	Initializers_fields = map[string]util.FieldSpec{}
	Initializers_inline = map[string]util.FieldSpec{}
	Initializers_attrs  []string
)

func init() {
	t := reflect.TypeOf((*metav1.Initializers)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *metav1.Initializers:
			return Initializers{V: v}
		case metav1.Initializers:
			return Initializers{V: &v}
		default:
			return skylark.None
		}
	}
	Initializers_attrs = setFieldTypes(t, Initializers_fields, Initializers_inline)
	Library["Initializers"] = skylark.NewBuiltin("Initializers", createInitializers)
}

func createInitializers(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for Initializers
}
func (t Initializers) UnderlyingKind() interface{} { return t.V }
func (t Initializers) Package() util.Package       { return util.Metav1 }
func (t Initializers) Type() string                { return "k8s_metav1_Initializers" }
func (t Initializers) String() string              { return t.V.String() }
func (t Initializers) Freeze()                     {} // TODO
func (t Initializers) Truth() skylark.Bool         { return skylark.True }
func (t Initializers) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t Initializers) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*Initializers)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t Initializers) AttrNames() []string { return Initializers_attrs }
func (t Initializers) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, Initializers_fields, Initializers_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type InternalEvent struct {
	V *metav1.InternalEvent
}

var (
	_ boxed = (*InternalEvent)(nil)

	InternalEvent_fields = map[string]util.FieldSpec{}
	InternalEvent_inline = map[string]util.FieldSpec{}
	InternalEvent_attrs  []string
)

func init() {
	t := reflect.TypeOf((*metav1.InternalEvent)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *metav1.InternalEvent:
			return InternalEvent{V: v}
		case metav1.InternalEvent:
			return InternalEvent{V: &v}
		default:
			return skylark.None
		}
	}
	InternalEvent_attrs = setFieldTypes(t, InternalEvent_fields, InternalEvent_inline)
	Library["InternalEvent"] = skylark.NewBuiltin("InternalEvent", createInternalEvent)
}

func createInternalEvent(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for InternalEvent
}
func (t InternalEvent) UnderlyingKind() interface{} { return t.V }
func (t InternalEvent) Package() util.Package       { return util.Metav1 }
func (t InternalEvent) Type() string                { return "k8s_metav1_InternalEvent" }
func (t InternalEvent) String() string              { return genericStringMethod(t.V) }
func (t InternalEvent) Freeze()                     {} // TODO
func (t InternalEvent) Truth() skylark.Bool         { return skylark.True }
func (t InternalEvent) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t InternalEvent) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*InternalEvent)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t InternalEvent) AttrNames() []string { return InternalEvent_attrs }
func (t InternalEvent) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, InternalEvent_fields, InternalEvent_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type LabelSelector struct {
	V *metav1.LabelSelector
}

var (
	_ boxed = (*LabelSelector)(nil)

	LabelSelector_fields = map[string]util.FieldSpec{}
	LabelSelector_inline = map[string]util.FieldSpec{}
	LabelSelector_attrs  []string
)

func init() {
	t := reflect.TypeOf((*metav1.LabelSelector)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *metav1.LabelSelector:
			return LabelSelector{V: v}
		case metav1.LabelSelector:
			return LabelSelector{V: &v}
		default:
			return skylark.None
		}
	}
	LabelSelector_attrs = setFieldTypes(t, LabelSelector_fields, LabelSelector_inline)
	Library["LabelSelector"] = skylark.NewBuiltin("LabelSelector", createLabelSelector)
}

func createLabelSelector(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for LabelSelector
}
func (t LabelSelector) UnderlyingKind() interface{} { return t.V }
func (t LabelSelector) Package() util.Package       { return util.Metav1 }
func (t LabelSelector) Type() string                { return "k8s_metav1_LabelSelector" }
func (t LabelSelector) String() string              { return t.V.String() }
func (t LabelSelector) Freeze()                     {} // TODO
func (t LabelSelector) Truth() skylark.Bool         { return skylark.True }
func (t LabelSelector) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t LabelSelector) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*LabelSelector)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t LabelSelector) AttrNames() []string { return LabelSelector_attrs }
func (t LabelSelector) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, LabelSelector_fields, LabelSelector_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type LabelSelectorRequirement struct {
	V *metav1.LabelSelectorRequirement
}

var (
	_ boxed = (*LabelSelectorRequirement)(nil)

	LabelSelectorRequirement_fields = map[string]util.FieldSpec{}
	LabelSelectorRequirement_inline = map[string]util.FieldSpec{}
	LabelSelectorRequirement_attrs  []string
)

func init() {
	t := reflect.TypeOf((*metav1.LabelSelectorRequirement)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *metav1.LabelSelectorRequirement:
			return LabelSelectorRequirement{V: v}
		case metav1.LabelSelectorRequirement:
			return LabelSelectorRequirement{V: &v}
		default:
			return skylark.None
		}
	}
	LabelSelectorRequirement_attrs = setFieldTypes(t, LabelSelectorRequirement_fields, LabelSelectorRequirement_inline)
	Library["LabelSelectorRequirement"] = skylark.NewBuiltin("LabelSelectorRequirement", createLabelSelectorRequirement)
}

func createLabelSelectorRequirement(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for LabelSelectorRequirement
}
func (t LabelSelectorRequirement) UnderlyingKind() interface{} { return t.V }
func (t LabelSelectorRequirement) Package() util.Package       { return util.Metav1 }
func (t LabelSelectorRequirement) Type() string                { return "k8s_metav1_LabelSelectorRequirement" }
func (t LabelSelectorRequirement) String() string              { return t.V.String() }
func (t LabelSelectorRequirement) Freeze()                     {} // TODO
func (t LabelSelectorRequirement) Truth() skylark.Bool         { return skylark.True }
func (t LabelSelectorRequirement) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t LabelSelectorRequirement) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*LabelSelectorRequirement)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t LabelSelectorRequirement) AttrNames() []string { return LabelSelectorRequirement_attrs }
func (t LabelSelectorRequirement) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, LabelSelectorRequirement_fields, LabelSelectorRequirement_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type ListMeta struct {
	V *metav1.ListMeta
}

var (
	_ boxed = (*ListMeta)(nil)

	ListMeta_fields = map[string]util.FieldSpec{}
	ListMeta_inline = map[string]util.FieldSpec{}
	ListMeta_attrs  []string
)

func init() {
	t := reflect.TypeOf((*metav1.ListMeta)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *metav1.ListMeta:
			return ListMeta{V: v}
		case metav1.ListMeta:
			return ListMeta{V: &v}
		default:
			return skylark.None
		}
	}
	ListMeta_attrs = setFieldTypes(t, ListMeta_fields, ListMeta_inline)
	Library["ListMeta"] = skylark.NewBuiltin("ListMeta", createListMeta)
}

func createListMeta(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for ListMeta
}
func (t ListMeta) UnderlyingKind() interface{} { return t.V }
func (t ListMeta) Package() util.Package       { return util.Metav1 }
func (t ListMeta) Type() string                { return "k8s_metav1_ListMeta" }
func (t ListMeta) String() string              { return t.V.String() }
func (t ListMeta) Freeze()                     {} // TODO
func (t ListMeta) Truth() skylark.Bool         { return skylark.True }
func (t ListMeta) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t ListMeta) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ListMeta)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ListMeta) AttrNames() []string { return ListMeta_attrs }
func (t ListMeta) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, ListMeta_fields, ListMeta_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type ListOptions struct {
	V *metav1.ListOptions
}

var (
	_ boxed = (*ListOptions)(nil)

	ListOptions_fields = map[string]util.FieldSpec{}
	ListOptions_inline = map[string]util.FieldSpec{}
	ListOptions_attrs  []string
)

func init() {
	t := reflect.TypeOf((*metav1.ListOptions)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *metav1.ListOptions:
			return ListOptions{V: v}
		case metav1.ListOptions:
			return ListOptions{V: &v}
		default:
			return skylark.None
		}
	}
	ListOptions_attrs = setFieldTypes(t, ListOptions_fields, ListOptions_inline)
	Library["ListOptions"] = skylark.NewBuiltin("ListOptions", createListOptions)
}

func createListOptions(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for ListOptions
}
func (t ListOptions) UnderlyingKind() interface{} { return t.V }
func (t ListOptions) Package() util.Package       { return util.Metav1 }
func (t ListOptions) Type() string                { return "k8s_metav1_ListOptions" }
func (t ListOptions) String() string              { return t.V.String() }
func (t ListOptions) Freeze()                     {} // TODO
func (t ListOptions) Truth() skylark.Bool         { return skylark.True }
func (t ListOptions) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t ListOptions) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ListOptions)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ListOptions) AttrNames() []string { return ListOptions_attrs }
func (t ListOptions) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, ListOptions_fields, ListOptions_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type ObjectMeta struct {
	V *metav1.ObjectMeta
}

var (
	_ boxed = (*ObjectMeta)(nil)

	ObjectMeta_fields = map[string]util.FieldSpec{}
	ObjectMeta_inline = map[string]util.FieldSpec{}
	ObjectMeta_attrs  []string
)

func init() {
	t := reflect.TypeOf((*metav1.ObjectMeta)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *metav1.ObjectMeta:
			return ObjectMeta{V: v}
		case metav1.ObjectMeta:
			return ObjectMeta{V: &v}
		default:
			return skylark.None
		}
	}
	ObjectMeta_attrs = setFieldTypes(t, ObjectMeta_fields, ObjectMeta_inline)
	Library["ObjectMeta"] = skylark.NewBuiltin("ObjectMeta", createObjectMeta)
}

func createObjectMeta(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for ObjectMeta
}
func (t ObjectMeta) UnderlyingKind() interface{} { return t.V }
func (t ObjectMeta) Package() util.Package       { return util.Metav1 }
func (t ObjectMeta) Type() string                { return "k8s_metav1_ObjectMeta" }
func (t ObjectMeta) String() string              { return t.V.String() }
func (t ObjectMeta) Freeze()                     {} // TODO
func (t ObjectMeta) Truth() skylark.Bool         { return skylark.True }
func (t ObjectMeta) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t ObjectMeta) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ObjectMeta)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ObjectMeta) AttrNames() []string { return ObjectMeta_attrs }
func (t ObjectMeta) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, ObjectMeta_fields, ObjectMeta_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type OwnerReference struct {
	V *metav1.OwnerReference
}

var (
	_ boxed = (*OwnerReference)(nil)

	OwnerReference_fields = map[string]util.FieldSpec{}
	OwnerReference_inline = map[string]util.FieldSpec{}
	OwnerReference_attrs  []string
)

func init() {
	t := reflect.TypeOf((*metav1.OwnerReference)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *metav1.OwnerReference:
			return OwnerReference{V: v}
		case metav1.OwnerReference:
			return OwnerReference{V: &v}
		default:
			return skylark.None
		}
	}
	OwnerReference_attrs = setFieldTypes(t, OwnerReference_fields, OwnerReference_inline)
	Library["OwnerReference"] = skylark.NewBuiltin("OwnerReference", createOwnerReference)
}

func createOwnerReference(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for OwnerReference
}
func (t OwnerReference) UnderlyingKind() interface{} { return t.V }
func (t OwnerReference) Package() util.Package       { return util.Metav1 }
func (t OwnerReference) Type() string                { return "k8s_metav1_OwnerReference" }
func (t OwnerReference) String() string              { return t.V.String() }
func (t OwnerReference) Freeze()                     {} // TODO
func (t OwnerReference) Truth() skylark.Bool         { return skylark.True }
func (t OwnerReference) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t OwnerReference) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*OwnerReference)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t OwnerReference) AttrNames() []string { return OwnerReference_attrs }
func (t OwnerReference) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, OwnerReference_fields, OwnerReference_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type Patch struct {
	V *metav1.Patch
}

var (
	_ boxed = (*Patch)(nil)

	Patch_fields = map[string]util.FieldSpec{}
	Patch_inline = map[string]util.FieldSpec{}
	Patch_attrs  []string
)

func init() {
	t := reflect.TypeOf((*metav1.Patch)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *metav1.Patch:
			return Patch{V: v}
		case metav1.Patch:
			return Patch{V: &v}
		default:
			return skylark.None
		}
	}
	Patch_attrs = setFieldTypes(t, Patch_fields, Patch_inline)
	Library["Patch"] = skylark.NewBuiltin("Patch", createPatch)
}

func createPatch(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for Patch
}
func (t Patch) UnderlyingKind() interface{} { return t.V }
func (t Patch) Package() util.Package       { return util.Metav1 }
func (t Patch) Type() string                { return "k8s_metav1_Patch" }
func (t Patch) String() string              { return t.V.String() }
func (t Patch) Freeze()                     {} // TODO
func (t Patch) Truth() skylark.Bool         { return skylark.True }
func (t Patch) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t Patch) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*Patch)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t Patch) AttrNames() []string { return Patch_attrs }
func (t Patch) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, Patch_fields, Patch_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type RootPaths struct {
	V *metav1.RootPaths
}

var (
	_ boxed = (*RootPaths)(nil)

	RootPaths_fields = map[string]util.FieldSpec{}
	RootPaths_inline = map[string]util.FieldSpec{}
	RootPaths_attrs  []string
)

func init() {
	t := reflect.TypeOf((*metav1.RootPaths)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *metav1.RootPaths:
			return RootPaths{V: v}
		case metav1.RootPaths:
			return RootPaths{V: &v}
		default:
			return skylark.None
		}
	}
	RootPaths_attrs = setFieldTypes(t, RootPaths_fields, RootPaths_inline)
	Library["RootPaths"] = skylark.NewBuiltin("RootPaths", createRootPaths)
}

func createRootPaths(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for RootPaths
}
func (t RootPaths) UnderlyingKind() interface{} { return t.V }
func (t RootPaths) Package() util.Package       { return util.Metav1 }
func (t RootPaths) Type() string                { return "k8s_metav1_RootPaths" }
func (t RootPaths) String() string              { return t.V.String() }
func (t RootPaths) Freeze()                     {} // TODO
func (t RootPaths) Truth() skylark.Bool         { return skylark.True }
func (t RootPaths) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t RootPaths) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*RootPaths)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t RootPaths) AttrNames() []string { return RootPaths_attrs }
func (t RootPaths) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, RootPaths_fields, RootPaths_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type ServerAddressByClientCIDR struct {
	V *metav1.ServerAddressByClientCIDR
}

var (
	_ boxed = (*ServerAddressByClientCIDR)(nil)

	ServerAddressByClientCIDR_fields = map[string]util.FieldSpec{}
	ServerAddressByClientCIDR_inline = map[string]util.FieldSpec{}
	ServerAddressByClientCIDR_attrs  []string
)

func init() {
	t := reflect.TypeOf((*metav1.ServerAddressByClientCIDR)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *metav1.ServerAddressByClientCIDR:
			return ServerAddressByClientCIDR{V: v}
		case metav1.ServerAddressByClientCIDR:
			return ServerAddressByClientCIDR{V: &v}
		default:
			return skylark.None
		}
	}
	ServerAddressByClientCIDR_attrs = setFieldTypes(t, ServerAddressByClientCIDR_fields, ServerAddressByClientCIDR_inline)
	Library["ServerAddressByClientCIDR"] = skylark.NewBuiltin("ServerAddressByClientCIDR", createServerAddressByClientCIDR)
}

func createServerAddressByClientCIDR(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for ServerAddressByClientCIDR
}
func (t ServerAddressByClientCIDR) UnderlyingKind() interface{} { return t.V }
func (t ServerAddressByClientCIDR) Package() util.Package       { return util.Metav1 }
func (t ServerAddressByClientCIDR) Type() string                { return "k8s_metav1_ServerAddressByClientCIDR" }
func (t ServerAddressByClientCIDR) String() string              { return t.V.String() }
func (t ServerAddressByClientCIDR) Freeze()                     {} // TODO
func (t ServerAddressByClientCIDR) Truth() skylark.Bool         { return skylark.True }
func (t ServerAddressByClientCIDR) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t ServerAddressByClientCIDR) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ServerAddressByClientCIDR)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ServerAddressByClientCIDR) AttrNames() []string { return ServerAddressByClientCIDR_attrs }
func (t ServerAddressByClientCIDR) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, ServerAddressByClientCIDR_fields, ServerAddressByClientCIDR_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type Status struct {
	V *metav1.Status
}

var (
	_ boxed = (*Status)(nil)

	Status_fields = map[string]util.FieldSpec{}
	Status_inline = map[string]util.FieldSpec{}
	Status_attrs  []string
)

func init() {
	t := reflect.TypeOf((*metav1.Status)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *metav1.Status:
			return Status{V: v}
		case metav1.Status:
			return Status{V: &v}
		default:
			return skylark.None
		}
	}
	Status_attrs = setFieldTypes(t, Status_fields, Status_inline)
	Library["Status"] = skylark.NewBuiltin("Status", createStatus)
}

func createStatus(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for Status
}
func (t Status) UnderlyingKind() interface{} { return t.V }
func (t Status) Package() util.Package       { return util.Metav1 }
func (t Status) Type() string                { return "k8s_metav1_Status" }
func (t Status) String() string              { return t.V.String() }
func (t Status) Freeze()                     {} // TODO
func (t Status) Truth() skylark.Bool         { return skylark.True }
func (t Status) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t Status) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*Status)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t Status) AttrNames() []string { return Status_attrs }
func (t Status) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, Status_fields, Status_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type StatusCause struct {
	V *metav1.StatusCause
}

var (
	_ boxed = (*StatusCause)(nil)

	StatusCause_fields = map[string]util.FieldSpec{}
	StatusCause_inline = map[string]util.FieldSpec{}
	StatusCause_attrs  []string
)

func init() {
	t := reflect.TypeOf((*metav1.StatusCause)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *metav1.StatusCause:
			return StatusCause{V: v}
		case metav1.StatusCause:
			return StatusCause{V: &v}
		default:
			return skylark.None
		}
	}
	StatusCause_attrs = setFieldTypes(t, StatusCause_fields, StatusCause_inline)
	Library["StatusCause"] = skylark.NewBuiltin("StatusCause", createStatusCause)
}

func createStatusCause(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for StatusCause
}
func (t StatusCause) UnderlyingKind() interface{} { return t.V }
func (t StatusCause) Package() util.Package       { return util.Metav1 }
func (t StatusCause) Type() string                { return "k8s_metav1_StatusCause" }
func (t StatusCause) String() string              { return t.V.String() }
func (t StatusCause) Freeze()                     {} // TODO
func (t StatusCause) Truth() skylark.Bool         { return skylark.True }
func (t StatusCause) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t StatusCause) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*StatusCause)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t StatusCause) AttrNames() []string { return StatusCause_attrs }
func (t StatusCause) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, StatusCause_fields, StatusCause_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type StatusDetails struct {
	V *metav1.StatusDetails
}

var (
	_ boxed = (*StatusDetails)(nil)

	StatusDetails_fields = map[string]util.FieldSpec{}
	StatusDetails_inline = map[string]util.FieldSpec{}
	StatusDetails_attrs  []string
)

func init() {
	t := reflect.TypeOf((*metav1.StatusDetails)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *metav1.StatusDetails:
			return StatusDetails{V: v}
		case metav1.StatusDetails:
			return StatusDetails{V: &v}
		default:
			return skylark.None
		}
	}
	StatusDetails_attrs = setFieldTypes(t, StatusDetails_fields, StatusDetails_inline)
	Library["StatusDetails"] = skylark.NewBuiltin("StatusDetails", createStatusDetails)
}

func createStatusDetails(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for StatusDetails
}
func (t StatusDetails) UnderlyingKind() interface{} { return t.V }
func (t StatusDetails) Package() util.Package       { return util.Metav1 }
func (t StatusDetails) Type() string                { return "k8s_metav1_StatusDetails" }
func (t StatusDetails) String() string              { return t.V.String() }
func (t StatusDetails) Freeze()                     {} // TODO
func (t StatusDetails) Truth() skylark.Bool         { return skylark.True }
func (t StatusDetails) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t StatusDetails) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*StatusDetails)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t StatusDetails) AttrNames() []string { return StatusDetails_attrs }
func (t StatusDetails) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, StatusDetails_fields, StatusDetails_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type TypeMeta struct {
	V *metav1.TypeMeta
}

var (
	_ boxed = (*TypeMeta)(nil)

	TypeMeta_fields = map[string]util.FieldSpec{}
	TypeMeta_inline = map[string]util.FieldSpec{}
	TypeMeta_attrs  []string
)

func init() {
	t := reflect.TypeOf((*metav1.TypeMeta)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *metav1.TypeMeta:
			return TypeMeta{V: v}
		case metav1.TypeMeta:
			return TypeMeta{V: &v}
		default:
			return skylark.None
		}
	}
	TypeMeta_attrs = setFieldTypes(t, TypeMeta_fields, TypeMeta_inline)
	Library["TypeMeta"] = skylark.NewBuiltin("TypeMeta", createTypeMeta)
}

func createTypeMeta(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for TypeMeta
}
func (t TypeMeta) UnderlyingKind() interface{} { return t.V }
func (t TypeMeta) Package() util.Package       { return util.Metav1 }
func (t TypeMeta) Type() string                { return "k8s_metav1_TypeMeta" }
func (t TypeMeta) String() string              { return t.V.String() }
func (t TypeMeta) Freeze()                     {} // TODO
func (t TypeMeta) Truth() skylark.Bool         { return skylark.True }
func (t TypeMeta) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t TypeMeta) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*TypeMeta)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t TypeMeta) AttrNames() []string { return TypeMeta_attrs }
func (t TypeMeta) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, TypeMeta_fields, TypeMeta_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type UpdateOptions struct {
	V *metav1.UpdateOptions
}

var (
	_ boxed = (*UpdateOptions)(nil)

	UpdateOptions_fields = map[string]util.FieldSpec{}
	UpdateOptions_inline = map[string]util.FieldSpec{}
	UpdateOptions_attrs  []string
)

func init() {
	t := reflect.TypeOf((*metav1.UpdateOptions)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *metav1.UpdateOptions:
			return UpdateOptions{V: v}
		case metav1.UpdateOptions:
			return UpdateOptions{V: &v}
		default:
			return skylark.None
		}
	}
	UpdateOptions_attrs = setFieldTypes(t, UpdateOptions_fields, UpdateOptions_inline)
	Library["UpdateOptions"] = skylark.NewBuiltin("UpdateOptions", createUpdateOptions)
}

func createUpdateOptions(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for UpdateOptions
}
func (t UpdateOptions) UnderlyingKind() interface{} { return t.V }
func (t UpdateOptions) Package() util.Package       { return util.Metav1 }
func (t UpdateOptions) Type() string                { return "k8s_metav1_UpdateOptions" }
func (t UpdateOptions) String() string              { return t.V.String() }
func (t UpdateOptions) Freeze()                     {} // TODO
func (t UpdateOptions) Truth() skylark.Bool         { return skylark.True }
func (t UpdateOptions) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t UpdateOptions) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*UpdateOptions)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t UpdateOptions) AttrNames() []string { return UpdateOptions_attrs }
func (t UpdateOptions) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, UpdateOptions_fields, UpdateOptions_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}

type WatchEvent struct {
	V *metav1.WatchEvent
}

var (
	_ boxed = (*WatchEvent)(nil)

	WatchEvent_fields = map[string]util.FieldSpec{}
	WatchEvent_inline = map[string]util.FieldSpec{}
	WatchEvent_attrs  []string
)

func init() {
	t := reflect.TypeOf((*metav1.WatchEvent)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *metav1.WatchEvent:
			return WatchEvent{V: v}
		case metav1.WatchEvent:
			return WatchEvent{V: &v}
		default:
			return skylark.None
		}
	}
	WatchEvent_attrs = setFieldTypes(t, WatchEvent_fields, WatchEvent_inline)
	Library["WatchEvent"] = skylark.NewBuiltin("WatchEvent", createWatchEvent)
}

func createWatchEvent(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	return nil, nil // TODO: add constructor for WatchEvent
}
func (t WatchEvent) UnderlyingKind() interface{} { return t.V }
func (t WatchEvent) Package() util.Package       { return util.Metav1 }
func (t WatchEvent) Type() string                { return "k8s_metav1_WatchEvent" }
func (t WatchEvent) String() string              { return t.V.String() }
func (t WatchEvent) Freeze()                     {} // TODO
func (t WatchEvent) Truth() skylark.Bool         { return skylark.True }
func (t WatchEvent) Hash() (uint32, error)       { return 0, unhashable(t.Type()) }
func (t WatchEvent) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*WatchEvent)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t WatchEvent) AttrNames() []string { return WatchEvent_attrs }
func (t WatchEvent) Attr(name string) (skylark.Value, error) {
	if u := t.V; u != nil {
		return getAttr(reflect.ValueOf(u), name, WatchEvent_fields, WatchEvent_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
