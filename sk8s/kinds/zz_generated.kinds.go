// Copyright 2018 West Damron. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package kinds

// Code generated by sk8s/gen. DO NOT EDIT

import (
	"reflect"

	"github.com/google/skylark"
	"github.com/google/skylark/sk8s/util"
	"github.com/google/skylark/syntax"
	apps "k8s.io/api/apps/v1"
	authentication "k8s.io/api/authentication/v1"
	authorization "k8s.io/api/authorization/v1"
	autoscaling "k8s.io/api/autoscaling/v1"
	batch "k8s.io/api/batch/v1"
	core "k8s.io/api/core/v1"
	networking "k8s.io/api/networking/v1"
	rbac "k8s.io/api/rbac/v1"
	storage "k8s.io/api/storage/v1"
	meta "k8s.io/apimachinery/pkg/apis/meta/v1"
)

type AWSElasticBlockStoreVolumeSource struct {
	V *core.AWSElasticBlockStoreVolumeSource
}

var (
	_ boxed = (*AWSElasticBlockStoreVolumeSource)(nil)

	AWSElasticBlockStoreVolumeSource_fields = map[string]util.FieldSpec{}
	AWSElasticBlockStoreVolumeSource_inline = map[string]util.FieldSpec{}
	AWSElasticBlockStoreVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.AWSElasticBlockStoreVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.AWSElasticBlockStoreVolumeSource:
			return AWSElasticBlockStoreVolumeSource{V: v}
		case core.AWSElasticBlockStoreVolumeSource:
			return AWSElasticBlockStoreVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	AWSElasticBlockStoreVolumeSource_attrs = setFieldTypes(t, AWSElasticBlockStoreVolumeSource_fields, AWSElasticBlockStoreVolumeSource_inline)
	Library["AWSElasticBlockStoreVolumeSource"] = skylark.NewBuiltin("AWSElasticBlockStoreVolumeSource", createAWSElasticBlockStoreVolumeSource)
}

func createAWSElasticBlockStoreVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := AWSElasticBlockStoreVolumeSource{V: &core.AWSElasticBlockStoreVolumeSource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t AWSElasticBlockStoreVolumeSource) Underlying() interface{} { return t.V }
func (t AWSElasticBlockStoreVolumeSource) DeepCopy() boxed {
	return AWSElasticBlockStoreVolumeSource{V: t.V.DeepCopy()}
}
func (t AWSElasticBlockStoreVolumeSource) Package() util.Package { return util.Core }
func (t AWSElasticBlockStoreVolumeSource) Type() string {
	return "k8s_core_AWSElasticBlockStoreVolumeSource"
}
func (t AWSElasticBlockStoreVolumeSource) String() string        { return t.V.String() }
func (t AWSElasticBlockStoreVolumeSource) Freeze()               {} // TODO
func (t AWSElasticBlockStoreVolumeSource) Truth() skylark.Bool   { return skylark.True }
func (t AWSElasticBlockStoreVolumeSource) Hash() (uint32, error) { return 0, unhashable(t.Type()) }
func (t AWSElasticBlockStoreVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*AWSElasticBlockStoreVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t AWSElasticBlockStoreVolumeSource) AttrNames() []string {
	return AWSElasticBlockStoreVolumeSource_attrs
}
func (t AWSElasticBlockStoreVolumeSource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, AWSElasticBlockStoreVolumeSource_fields, AWSElasticBlockStoreVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t AWSElasticBlockStoreVolumeSource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, AWSElasticBlockStoreVolumeSource_fields, AWSElasticBlockStoreVolumeSource_inline)
}

type Affinity struct {
	V *core.Affinity
}

var (
	_ boxed = (*Affinity)(nil)

	Affinity_fields = map[string]util.FieldSpec{}
	Affinity_inline = map[string]util.FieldSpec{}
	Affinity_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.Affinity)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.Affinity:
			return Affinity{V: v}
		case core.Affinity:
			return Affinity{V: &v}
		default:
			return skylark.None
		}
	}
	Affinity_attrs = setFieldTypes(t, Affinity_fields, Affinity_inline)
	Library["Affinity"] = skylark.NewBuiltin("Affinity", createAffinity)
}

func createAffinity(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := Affinity{V: &core.Affinity{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t Affinity) Underlying() interface{} { return t.V }
func (t Affinity) DeepCopy() boxed         { return Affinity{V: t.V.DeepCopy()} }
func (t Affinity) Package() util.Package   { return util.Core }
func (t Affinity) Type() string            { return "k8s_core_Affinity" }
func (t Affinity) String() string          { return t.V.String() }
func (t Affinity) Freeze()                 {} // TODO
func (t Affinity) Truth() skylark.Bool     { return skylark.True }
func (t Affinity) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t Affinity) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*Affinity)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t Affinity) AttrNames() []string { return Affinity_attrs }
func (t Affinity) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, Affinity_fields, Affinity_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t Affinity) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, Affinity_fields, Affinity_inline)
}

type AttachedVolume struct {
	V *core.AttachedVolume
}

var (
	_ boxed = (*AttachedVolume)(nil)

	AttachedVolume_fields = map[string]util.FieldSpec{}
	AttachedVolume_inline = map[string]util.FieldSpec{}
	AttachedVolume_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.AttachedVolume)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.AttachedVolume:
			return AttachedVolume{V: v}
		case core.AttachedVolume:
			return AttachedVolume{V: &v}
		default:
			return skylark.None
		}
	}
	AttachedVolume_attrs = setFieldTypes(t, AttachedVolume_fields, AttachedVolume_inline)
	Library["AttachedVolume"] = skylark.NewBuiltin("AttachedVolume", createAttachedVolume)
}

func createAttachedVolume(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := AttachedVolume{V: &core.AttachedVolume{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t AttachedVolume) Underlying() interface{} { return t.V }
func (t AttachedVolume) DeepCopy() boxed         { return AttachedVolume{V: t.V.DeepCopy()} }
func (t AttachedVolume) Package() util.Package   { return util.Core }
func (t AttachedVolume) Type() string            { return "k8s_core_AttachedVolume" }
func (t AttachedVolume) String() string          { return t.V.String() }
func (t AttachedVolume) Freeze()                 {} // TODO
func (t AttachedVolume) Truth() skylark.Bool     { return skylark.True }
func (t AttachedVolume) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t AttachedVolume) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*AttachedVolume)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t AttachedVolume) AttrNames() []string { return AttachedVolume_attrs }
func (t AttachedVolume) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, AttachedVolume_fields, AttachedVolume_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t AttachedVolume) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, AttachedVolume_fields, AttachedVolume_inline)
}

type AvoidPods struct {
	V *core.AvoidPods
}

var (
	_ boxed = (*AvoidPods)(nil)

	AvoidPods_fields = map[string]util.FieldSpec{}
	AvoidPods_inline = map[string]util.FieldSpec{}
	AvoidPods_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.AvoidPods)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.AvoidPods:
			return AvoidPods{V: v}
		case core.AvoidPods:
			return AvoidPods{V: &v}
		default:
			return skylark.None
		}
	}
	AvoidPods_attrs = setFieldTypes(t, AvoidPods_fields, AvoidPods_inline)
	Library["AvoidPods"] = skylark.NewBuiltin("AvoidPods", createAvoidPods)
}

func createAvoidPods(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := AvoidPods{V: &core.AvoidPods{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t AvoidPods) Underlying() interface{} { return t.V }
func (t AvoidPods) DeepCopy() boxed         { return AvoidPods{V: t.V.DeepCopy()} }
func (t AvoidPods) Package() util.Package   { return util.Core }
func (t AvoidPods) Type() string            { return "k8s_core_AvoidPods" }
func (t AvoidPods) String() string          { return t.V.String() }
func (t AvoidPods) Freeze()                 {} // TODO
func (t AvoidPods) Truth() skylark.Bool     { return skylark.True }
func (t AvoidPods) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t AvoidPods) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*AvoidPods)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t AvoidPods) AttrNames() []string { return AvoidPods_attrs }
func (t AvoidPods) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, AvoidPods_fields, AvoidPods_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t AvoidPods) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, AvoidPods_fields, AvoidPods_inline)
}

type AzureDiskVolumeSource struct {
	V *core.AzureDiskVolumeSource
}

var (
	_ boxed = (*AzureDiskVolumeSource)(nil)

	AzureDiskVolumeSource_fields = map[string]util.FieldSpec{}
	AzureDiskVolumeSource_inline = map[string]util.FieldSpec{}
	AzureDiskVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.AzureDiskVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.AzureDiskVolumeSource:
			return AzureDiskVolumeSource{V: v}
		case core.AzureDiskVolumeSource:
			return AzureDiskVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	AzureDiskVolumeSource_attrs = setFieldTypes(t, AzureDiskVolumeSource_fields, AzureDiskVolumeSource_inline)
	Library["AzureDiskVolumeSource"] = skylark.NewBuiltin("AzureDiskVolumeSource", createAzureDiskVolumeSource)
}

func createAzureDiskVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := AzureDiskVolumeSource{V: &core.AzureDiskVolumeSource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t AzureDiskVolumeSource) Underlying() interface{} { return t.V }
func (t AzureDiskVolumeSource) DeepCopy() boxed         { return AzureDiskVolumeSource{V: t.V.DeepCopy()} }
func (t AzureDiskVolumeSource) Package() util.Package   { return util.Core }
func (t AzureDiskVolumeSource) Type() string            { return "k8s_core_AzureDiskVolumeSource" }
func (t AzureDiskVolumeSource) String() string          { return t.V.String() }
func (t AzureDiskVolumeSource) Freeze()                 {} // TODO
func (t AzureDiskVolumeSource) Truth() skylark.Bool     { return skylark.True }
func (t AzureDiskVolumeSource) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t AzureDiskVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*AzureDiskVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t AzureDiskVolumeSource) AttrNames() []string { return AzureDiskVolumeSource_attrs }
func (t AzureDiskVolumeSource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, AzureDiskVolumeSource_fields, AzureDiskVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t AzureDiskVolumeSource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, AzureDiskVolumeSource_fields, AzureDiskVolumeSource_inline)
}

type AzureFilePersistentVolumeSource struct {
	V *core.AzureFilePersistentVolumeSource
}

var (
	_ boxed = (*AzureFilePersistentVolumeSource)(nil)

	AzureFilePersistentVolumeSource_fields = map[string]util.FieldSpec{}
	AzureFilePersistentVolumeSource_inline = map[string]util.FieldSpec{}
	AzureFilePersistentVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.AzureFilePersistentVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.AzureFilePersistentVolumeSource:
			return AzureFilePersistentVolumeSource{V: v}
		case core.AzureFilePersistentVolumeSource:
			return AzureFilePersistentVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	AzureFilePersistentVolumeSource_attrs = setFieldTypes(t, AzureFilePersistentVolumeSource_fields, AzureFilePersistentVolumeSource_inline)
	Library["AzureFilePersistentVolumeSource"] = skylark.NewBuiltin("AzureFilePersistentVolumeSource", createAzureFilePersistentVolumeSource)
}

func createAzureFilePersistentVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := AzureFilePersistentVolumeSource{V: &core.AzureFilePersistentVolumeSource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t AzureFilePersistentVolumeSource) Underlying() interface{} { return t.V }
func (t AzureFilePersistentVolumeSource) DeepCopy() boxed {
	return AzureFilePersistentVolumeSource{V: t.V.DeepCopy()}
}
func (t AzureFilePersistentVolumeSource) Package() util.Package { return util.Core }
func (t AzureFilePersistentVolumeSource) Type() string {
	return "k8s_core_AzureFilePersistentVolumeSource"
}
func (t AzureFilePersistentVolumeSource) String() string        { return t.V.String() }
func (t AzureFilePersistentVolumeSource) Freeze()               {} // TODO
func (t AzureFilePersistentVolumeSource) Truth() skylark.Bool   { return skylark.True }
func (t AzureFilePersistentVolumeSource) Hash() (uint32, error) { return 0, unhashable(t.Type()) }
func (t AzureFilePersistentVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*AzureFilePersistentVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t AzureFilePersistentVolumeSource) AttrNames() []string {
	return AzureFilePersistentVolumeSource_attrs
}
func (t AzureFilePersistentVolumeSource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, AzureFilePersistentVolumeSource_fields, AzureFilePersistentVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t AzureFilePersistentVolumeSource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, AzureFilePersistentVolumeSource_fields, AzureFilePersistentVolumeSource_inline)
}

type AzureFileVolumeSource struct {
	V *core.AzureFileVolumeSource
}

var (
	_ boxed = (*AzureFileVolumeSource)(nil)

	AzureFileVolumeSource_fields = map[string]util.FieldSpec{}
	AzureFileVolumeSource_inline = map[string]util.FieldSpec{}
	AzureFileVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.AzureFileVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.AzureFileVolumeSource:
			return AzureFileVolumeSource{V: v}
		case core.AzureFileVolumeSource:
			return AzureFileVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	AzureFileVolumeSource_attrs = setFieldTypes(t, AzureFileVolumeSource_fields, AzureFileVolumeSource_inline)
	Library["AzureFileVolumeSource"] = skylark.NewBuiltin("AzureFileVolumeSource", createAzureFileVolumeSource)
}

func createAzureFileVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := AzureFileVolumeSource{V: &core.AzureFileVolumeSource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t AzureFileVolumeSource) Underlying() interface{} { return t.V }
func (t AzureFileVolumeSource) DeepCopy() boxed         { return AzureFileVolumeSource{V: t.V.DeepCopy()} }
func (t AzureFileVolumeSource) Package() util.Package   { return util.Core }
func (t AzureFileVolumeSource) Type() string            { return "k8s_core_AzureFileVolumeSource" }
func (t AzureFileVolumeSource) String() string          { return t.V.String() }
func (t AzureFileVolumeSource) Freeze()                 {} // TODO
func (t AzureFileVolumeSource) Truth() skylark.Bool     { return skylark.True }
func (t AzureFileVolumeSource) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t AzureFileVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*AzureFileVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t AzureFileVolumeSource) AttrNames() []string { return AzureFileVolumeSource_attrs }
func (t AzureFileVolumeSource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, AzureFileVolumeSource_fields, AzureFileVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t AzureFileVolumeSource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, AzureFileVolumeSource_fields, AzureFileVolumeSource_inline)
}

type Binding struct {
	V *core.Binding
}

var (
	_ boxed = (*Binding)(nil)

	Binding_fields = map[string]util.FieldSpec{}
	Binding_inline = map[string]util.FieldSpec{}
	Binding_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.Binding)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.Binding:
			return Binding{V: v}
		case core.Binding:
			return Binding{V: &v}
		default:
			return skylark.None
		}
	}
	Binding_attrs = setFieldTypes(t, Binding_fields, Binding_inline)
	Library["Binding"] = skylark.NewBuiltin("Binding", createBinding)
}

func createBinding(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := Binding{V: &core.Binding{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t Binding) Underlying() interface{} { return t.V }
func (t Binding) DeepCopy() boxed         { return Binding{V: t.V.DeepCopy()} }
func (t Binding) Package() util.Package   { return util.Core }
func (t Binding) Type() string            { return "k8s_core_Binding" }
func (t Binding) String() string          { return t.V.String() }
func (t Binding) Freeze()                 {} // TODO
func (t Binding) Truth() skylark.Bool     { return skylark.True }
func (t Binding) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t Binding) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*Binding)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t Binding) AttrNames() []string { return Binding_attrs }
func (t Binding) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, Binding_fields, Binding_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t Binding) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, Binding_fields, Binding_inline)
}

type CSIPersistentVolumeSource struct {
	V *core.CSIPersistentVolumeSource
}

var (
	_ boxed = (*CSIPersistentVolumeSource)(nil)

	CSIPersistentVolumeSource_fields = map[string]util.FieldSpec{}
	CSIPersistentVolumeSource_inline = map[string]util.FieldSpec{}
	CSIPersistentVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.CSIPersistentVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.CSIPersistentVolumeSource:
			return CSIPersistentVolumeSource{V: v}
		case core.CSIPersistentVolumeSource:
			return CSIPersistentVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	CSIPersistentVolumeSource_attrs = setFieldTypes(t, CSIPersistentVolumeSource_fields, CSIPersistentVolumeSource_inline)
	Library["CSIPersistentVolumeSource"] = skylark.NewBuiltin("CSIPersistentVolumeSource", createCSIPersistentVolumeSource)
}

func createCSIPersistentVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := CSIPersistentVolumeSource{V: &core.CSIPersistentVolumeSource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t CSIPersistentVolumeSource) Underlying() interface{} { return t.V }
func (t CSIPersistentVolumeSource) DeepCopy() boxed {
	return CSIPersistentVolumeSource{V: t.V.DeepCopy()}
}
func (t CSIPersistentVolumeSource) Package() util.Package { return util.Core }
func (t CSIPersistentVolumeSource) Type() string          { return "k8s_core_CSIPersistentVolumeSource" }
func (t CSIPersistentVolumeSource) String() string        { return t.V.String() }
func (t CSIPersistentVolumeSource) Freeze()               {} // TODO
func (t CSIPersistentVolumeSource) Truth() skylark.Bool   { return skylark.True }
func (t CSIPersistentVolumeSource) Hash() (uint32, error) { return 0, unhashable(t.Type()) }
func (t CSIPersistentVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*CSIPersistentVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t CSIPersistentVolumeSource) AttrNames() []string { return CSIPersistentVolumeSource_attrs }
func (t CSIPersistentVolumeSource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, CSIPersistentVolumeSource_fields, CSIPersistentVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t CSIPersistentVolumeSource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, CSIPersistentVolumeSource_fields, CSIPersistentVolumeSource_inline)
}

type Capabilities struct {
	V *core.Capabilities
}

var (
	_ boxed = (*Capabilities)(nil)

	Capabilities_fields = map[string]util.FieldSpec{}
	Capabilities_inline = map[string]util.FieldSpec{}
	Capabilities_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.Capabilities)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.Capabilities:
			return Capabilities{V: v}
		case core.Capabilities:
			return Capabilities{V: &v}
		default:
			return skylark.None
		}
	}
	Capabilities_attrs = setFieldTypes(t, Capabilities_fields, Capabilities_inline)
	Library["Capabilities"] = skylark.NewBuiltin("Capabilities", createCapabilities)
}

func createCapabilities(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := Capabilities{V: &core.Capabilities{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t Capabilities) Underlying() interface{} { return t.V }
func (t Capabilities) DeepCopy() boxed         { return Capabilities{V: t.V.DeepCopy()} }
func (t Capabilities) Package() util.Package   { return util.Core }
func (t Capabilities) Type() string            { return "k8s_core_Capabilities" }
func (t Capabilities) String() string          { return t.V.String() }
func (t Capabilities) Freeze()                 {} // TODO
func (t Capabilities) Truth() skylark.Bool     { return skylark.True }
func (t Capabilities) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t Capabilities) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*Capabilities)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t Capabilities) AttrNames() []string { return Capabilities_attrs }
func (t Capabilities) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, Capabilities_fields, Capabilities_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t Capabilities) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, Capabilities_fields, Capabilities_inline)
}

type CephFSPersistentVolumeSource struct {
	V *core.CephFSPersistentVolumeSource
}

var (
	_ boxed = (*CephFSPersistentVolumeSource)(nil)

	CephFSPersistentVolumeSource_fields = map[string]util.FieldSpec{}
	CephFSPersistentVolumeSource_inline = map[string]util.FieldSpec{}
	CephFSPersistentVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.CephFSPersistentVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.CephFSPersistentVolumeSource:
			return CephFSPersistentVolumeSource{V: v}
		case core.CephFSPersistentVolumeSource:
			return CephFSPersistentVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	CephFSPersistentVolumeSource_attrs = setFieldTypes(t, CephFSPersistentVolumeSource_fields, CephFSPersistentVolumeSource_inline)
	Library["CephFSPersistentVolumeSource"] = skylark.NewBuiltin("CephFSPersistentVolumeSource", createCephFSPersistentVolumeSource)
}

func createCephFSPersistentVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := CephFSPersistentVolumeSource{V: &core.CephFSPersistentVolumeSource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t CephFSPersistentVolumeSource) Underlying() interface{} { return t.V }
func (t CephFSPersistentVolumeSource) DeepCopy() boxed {
	return CephFSPersistentVolumeSource{V: t.V.DeepCopy()}
}
func (t CephFSPersistentVolumeSource) Package() util.Package { return util.Core }
func (t CephFSPersistentVolumeSource) Type() string          { return "k8s_core_CephFSPersistentVolumeSource" }
func (t CephFSPersistentVolumeSource) String() string        { return t.V.String() }
func (t CephFSPersistentVolumeSource) Freeze()               {} // TODO
func (t CephFSPersistentVolumeSource) Truth() skylark.Bool   { return skylark.True }
func (t CephFSPersistentVolumeSource) Hash() (uint32, error) { return 0, unhashable(t.Type()) }
func (t CephFSPersistentVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*CephFSPersistentVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t CephFSPersistentVolumeSource) AttrNames() []string { return CephFSPersistentVolumeSource_attrs }
func (t CephFSPersistentVolumeSource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, CephFSPersistentVolumeSource_fields, CephFSPersistentVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t CephFSPersistentVolumeSource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, CephFSPersistentVolumeSource_fields, CephFSPersistentVolumeSource_inline)
}

type CephFSVolumeSource struct {
	V *core.CephFSVolumeSource
}

var (
	_ boxed = (*CephFSVolumeSource)(nil)

	CephFSVolumeSource_fields = map[string]util.FieldSpec{}
	CephFSVolumeSource_inline = map[string]util.FieldSpec{}
	CephFSVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.CephFSVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.CephFSVolumeSource:
			return CephFSVolumeSource{V: v}
		case core.CephFSVolumeSource:
			return CephFSVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	CephFSVolumeSource_attrs = setFieldTypes(t, CephFSVolumeSource_fields, CephFSVolumeSource_inline)
	Library["CephFSVolumeSource"] = skylark.NewBuiltin("CephFSVolumeSource", createCephFSVolumeSource)
}

func createCephFSVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := CephFSVolumeSource{V: &core.CephFSVolumeSource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t CephFSVolumeSource) Underlying() interface{} { return t.V }
func (t CephFSVolumeSource) DeepCopy() boxed         { return CephFSVolumeSource{V: t.V.DeepCopy()} }
func (t CephFSVolumeSource) Package() util.Package   { return util.Core }
func (t CephFSVolumeSource) Type() string            { return "k8s_core_CephFSVolumeSource" }
func (t CephFSVolumeSource) String() string          { return t.V.String() }
func (t CephFSVolumeSource) Freeze()                 {} // TODO
func (t CephFSVolumeSource) Truth() skylark.Bool     { return skylark.True }
func (t CephFSVolumeSource) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t CephFSVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*CephFSVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t CephFSVolumeSource) AttrNames() []string { return CephFSVolumeSource_attrs }
func (t CephFSVolumeSource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, CephFSVolumeSource_fields, CephFSVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t CephFSVolumeSource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, CephFSVolumeSource_fields, CephFSVolumeSource_inline)
}

type CinderPersistentVolumeSource struct {
	V *core.CinderPersistentVolumeSource
}

var (
	_ boxed = (*CinderPersistentVolumeSource)(nil)

	CinderPersistentVolumeSource_fields = map[string]util.FieldSpec{}
	CinderPersistentVolumeSource_inline = map[string]util.FieldSpec{}
	CinderPersistentVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.CinderPersistentVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.CinderPersistentVolumeSource:
			return CinderPersistentVolumeSource{V: v}
		case core.CinderPersistentVolumeSource:
			return CinderPersistentVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	CinderPersistentVolumeSource_attrs = setFieldTypes(t, CinderPersistentVolumeSource_fields, CinderPersistentVolumeSource_inline)
	Library["CinderPersistentVolumeSource"] = skylark.NewBuiltin("CinderPersistentVolumeSource", createCinderPersistentVolumeSource)
}

func createCinderPersistentVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := CinderPersistentVolumeSource{V: &core.CinderPersistentVolumeSource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t CinderPersistentVolumeSource) Underlying() interface{} { return t.V }
func (t CinderPersistentVolumeSource) DeepCopy() boxed {
	return CinderPersistentVolumeSource{V: t.V.DeepCopy()}
}
func (t CinderPersistentVolumeSource) Package() util.Package { return util.Core }
func (t CinderPersistentVolumeSource) Type() string          { return "k8s_core_CinderPersistentVolumeSource" }
func (t CinderPersistentVolumeSource) String() string        { return t.V.String() }
func (t CinderPersistentVolumeSource) Freeze()               {} // TODO
func (t CinderPersistentVolumeSource) Truth() skylark.Bool   { return skylark.True }
func (t CinderPersistentVolumeSource) Hash() (uint32, error) { return 0, unhashable(t.Type()) }
func (t CinderPersistentVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*CinderPersistentVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t CinderPersistentVolumeSource) AttrNames() []string { return CinderPersistentVolumeSource_attrs }
func (t CinderPersistentVolumeSource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, CinderPersistentVolumeSource_fields, CinderPersistentVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t CinderPersistentVolumeSource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, CinderPersistentVolumeSource_fields, CinderPersistentVolumeSource_inline)
}

type CinderVolumeSource struct {
	V *core.CinderVolumeSource
}

var (
	_ boxed = (*CinderVolumeSource)(nil)

	CinderVolumeSource_fields = map[string]util.FieldSpec{}
	CinderVolumeSource_inline = map[string]util.FieldSpec{}
	CinderVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.CinderVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.CinderVolumeSource:
			return CinderVolumeSource{V: v}
		case core.CinderVolumeSource:
			return CinderVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	CinderVolumeSource_attrs = setFieldTypes(t, CinderVolumeSource_fields, CinderVolumeSource_inline)
	Library["CinderVolumeSource"] = skylark.NewBuiltin("CinderVolumeSource", createCinderVolumeSource)
}

func createCinderVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := CinderVolumeSource{V: &core.CinderVolumeSource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t CinderVolumeSource) Underlying() interface{} { return t.V }
func (t CinderVolumeSource) DeepCopy() boxed         { return CinderVolumeSource{V: t.V.DeepCopy()} }
func (t CinderVolumeSource) Package() util.Package   { return util.Core }
func (t CinderVolumeSource) Type() string            { return "k8s_core_CinderVolumeSource" }
func (t CinderVolumeSource) String() string          { return t.V.String() }
func (t CinderVolumeSource) Freeze()                 {} // TODO
func (t CinderVolumeSource) Truth() skylark.Bool     { return skylark.True }
func (t CinderVolumeSource) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t CinderVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*CinderVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t CinderVolumeSource) AttrNames() []string { return CinderVolumeSource_attrs }
func (t CinderVolumeSource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, CinderVolumeSource_fields, CinderVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t CinderVolumeSource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, CinderVolumeSource_fields, CinderVolumeSource_inline)
}

type ClientIPConfig struct {
	V *core.ClientIPConfig
}

var (
	_ boxed = (*ClientIPConfig)(nil)

	ClientIPConfig_fields = map[string]util.FieldSpec{}
	ClientIPConfig_inline = map[string]util.FieldSpec{}
	ClientIPConfig_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.ClientIPConfig)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.ClientIPConfig:
			return ClientIPConfig{V: v}
		case core.ClientIPConfig:
			return ClientIPConfig{V: &v}
		default:
			return skylark.None
		}
	}
	ClientIPConfig_attrs = setFieldTypes(t, ClientIPConfig_fields, ClientIPConfig_inline)
	Library["ClientIPConfig"] = skylark.NewBuiltin("ClientIPConfig", createClientIPConfig)
}

func createClientIPConfig(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ClientIPConfig{V: &core.ClientIPConfig{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ClientIPConfig) Underlying() interface{} { return t.V }
func (t ClientIPConfig) DeepCopy() boxed         { return ClientIPConfig{V: t.V.DeepCopy()} }
func (t ClientIPConfig) Package() util.Package   { return util.Core }
func (t ClientIPConfig) Type() string            { return "k8s_core_ClientIPConfig" }
func (t ClientIPConfig) String() string          { return t.V.String() }
func (t ClientIPConfig) Freeze()                 {} // TODO
func (t ClientIPConfig) Truth() skylark.Bool     { return skylark.True }
func (t ClientIPConfig) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ClientIPConfig) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ClientIPConfig)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ClientIPConfig) AttrNames() []string { return ClientIPConfig_attrs }
func (t ClientIPConfig) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ClientIPConfig_fields, ClientIPConfig_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ClientIPConfig) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ClientIPConfig_fields, ClientIPConfig_inline)
}

type ComponentCondition struct {
	V *core.ComponentCondition
}

var (
	_ boxed = (*ComponentCondition)(nil)

	ComponentCondition_fields = map[string]util.FieldSpec{}
	ComponentCondition_inline = map[string]util.FieldSpec{}
	ComponentCondition_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.ComponentCondition)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.ComponentCondition:
			return ComponentCondition{V: v}
		case core.ComponentCondition:
			return ComponentCondition{V: &v}
		default:
			return skylark.None
		}
	}
	ComponentCondition_attrs = setFieldTypes(t, ComponentCondition_fields, ComponentCondition_inline)
	Library["ComponentCondition"] = skylark.NewBuiltin("ComponentCondition", createComponentCondition)
}

func createComponentCondition(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ComponentCondition{V: &core.ComponentCondition{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ComponentCondition) Underlying() interface{} { return t.V }
func (t ComponentCondition) DeepCopy() boxed         { return ComponentCondition{V: t.V.DeepCopy()} }
func (t ComponentCondition) Package() util.Package   { return util.Core }
func (t ComponentCondition) Type() string            { return "k8s_core_ComponentCondition" }
func (t ComponentCondition) String() string          { return t.V.String() }
func (t ComponentCondition) Freeze()                 {} // TODO
func (t ComponentCondition) Truth() skylark.Bool     { return skylark.True }
func (t ComponentCondition) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ComponentCondition) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ComponentCondition)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ComponentCondition) AttrNames() []string { return ComponentCondition_attrs }
func (t ComponentCondition) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ComponentCondition_fields, ComponentCondition_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ComponentCondition) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ComponentCondition_fields, ComponentCondition_inline)
}

type ComponentStatus struct {
	V *core.ComponentStatus
}

var (
	_ boxed = (*ComponentStatus)(nil)

	ComponentStatus_fields = map[string]util.FieldSpec{}
	ComponentStatus_inline = map[string]util.FieldSpec{}
	ComponentStatus_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.ComponentStatus)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.ComponentStatus:
			return ComponentStatus{V: v}
		case core.ComponentStatus:
			return ComponentStatus{V: &v}
		default:
			return skylark.None
		}
	}
	ComponentStatus_attrs = setFieldTypes(t, ComponentStatus_fields, ComponentStatus_inline)
	Library["ComponentStatus"] = skylark.NewBuiltin("ComponentStatus", createComponentStatus)
}

func createComponentStatus(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ComponentStatus{V: &core.ComponentStatus{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ComponentStatus) Underlying() interface{} { return t.V }
func (t ComponentStatus) DeepCopy() boxed         { return ComponentStatus{V: t.V.DeepCopy()} }
func (t ComponentStatus) Package() util.Package   { return util.Core }
func (t ComponentStatus) Type() string            { return "k8s_core_ComponentStatus" }
func (t ComponentStatus) String() string          { return t.V.String() }
func (t ComponentStatus) Freeze()                 {} // TODO
func (t ComponentStatus) Truth() skylark.Bool     { return skylark.True }
func (t ComponentStatus) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ComponentStatus) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ComponentStatus)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ComponentStatus) AttrNames() []string { return ComponentStatus_attrs }
func (t ComponentStatus) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ComponentStatus_fields, ComponentStatus_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ComponentStatus) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ComponentStatus_fields, ComponentStatus_inline)
}

type ComponentStatusList struct {
	V *core.ComponentStatusList
}

var (
	_ boxed = (*ComponentStatusList)(nil)

	ComponentStatusList_fields = map[string]util.FieldSpec{}
	ComponentStatusList_inline = map[string]util.FieldSpec{}
	ComponentStatusList_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.ComponentStatusList)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.ComponentStatusList:
			return ComponentStatusList{V: v}
		case core.ComponentStatusList:
			return ComponentStatusList{V: &v}
		default:
			return skylark.None
		}
	}
	ComponentStatusList_attrs = setFieldTypes(t, ComponentStatusList_fields, ComponentStatusList_inline)
	Library["ComponentStatusList"] = skylark.NewBuiltin("ComponentStatusList", createComponentStatusList)
}

func createComponentStatusList(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ComponentStatusList{V: &core.ComponentStatusList{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ComponentStatusList) Underlying() interface{} { return t.V }
func (t ComponentStatusList) DeepCopy() boxed         { return ComponentStatusList{V: t.V.DeepCopy()} }
func (t ComponentStatusList) Package() util.Package   { return util.Core }
func (t ComponentStatusList) Type() string            { return "k8s_core_ComponentStatusList" }
func (t ComponentStatusList) String() string          { return t.V.String() }
func (t ComponentStatusList) Freeze()                 {} // TODO
func (t ComponentStatusList) Truth() skylark.Bool     { return skylark.True }
func (t ComponentStatusList) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ComponentStatusList) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ComponentStatusList)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ComponentStatusList) AttrNames() []string { return ComponentStatusList_attrs }
func (t ComponentStatusList) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ComponentStatusList_fields, ComponentStatusList_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ComponentStatusList) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ComponentStatusList_fields, ComponentStatusList_inline)
}

type ConfigMap struct {
	V *core.ConfigMap
}

var (
	_ boxed = (*ConfigMap)(nil)

	ConfigMap_fields = map[string]util.FieldSpec{}
	ConfigMap_inline = map[string]util.FieldSpec{}
	ConfigMap_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.ConfigMap)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.ConfigMap:
			return ConfigMap{V: v}
		case core.ConfigMap:
			return ConfigMap{V: &v}
		default:
			return skylark.None
		}
	}
	ConfigMap_attrs = setFieldTypes(t, ConfigMap_fields, ConfigMap_inline)
	Library["ConfigMap"] = skylark.NewBuiltin("ConfigMap", createConfigMap)
}

func createConfigMap(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ConfigMap{V: &core.ConfigMap{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ConfigMap) Underlying() interface{} { return t.V }
func (t ConfigMap) DeepCopy() boxed         { return ConfigMap{V: t.V.DeepCopy()} }
func (t ConfigMap) Package() util.Package   { return util.Core }
func (t ConfigMap) Type() string            { return "k8s_core_ConfigMap" }
func (t ConfigMap) String() string          { return t.V.String() }
func (t ConfigMap) Freeze()                 {} // TODO
func (t ConfigMap) Truth() skylark.Bool     { return skylark.True }
func (t ConfigMap) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ConfigMap) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ConfigMap)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ConfigMap) AttrNames() []string { return ConfigMap_attrs }
func (t ConfigMap) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ConfigMap_fields, ConfigMap_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ConfigMap) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ConfigMap_fields, ConfigMap_inline)
}

type ConfigMapEnvSource struct {
	V *core.ConfigMapEnvSource
}

var (
	_ boxed = (*ConfigMapEnvSource)(nil)

	ConfigMapEnvSource_fields = map[string]util.FieldSpec{}
	ConfigMapEnvSource_inline = map[string]util.FieldSpec{}
	ConfigMapEnvSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.ConfigMapEnvSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.ConfigMapEnvSource:
			return ConfigMapEnvSource{V: v}
		case core.ConfigMapEnvSource:
			return ConfigMapEnvSource{V: &v}
		default:
			return skylark.None
		}
	}
	ConfigMapEnvSource_attrs = setFieldTypes(t, ConfigMapEnvSource_fields, ConfigMapEnvSource_inline)
	Library["ConfigMapEnvSource"] = skylark.NewBuiltin("ConfigMapEnvSource", createConfigMapEnvSource)
}

func createConfigMapEnvSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ConfigMapEnvSource{V: &core.ConfigMapEnvSource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ConfigMapEnvSource) Underlying() interface{} { return t.V }
func (t ConfigMapEnvSource) DeepCopy() boxed         { return ConfigMapEnvSource{V: t.V.DeepCopy()} }
func (t ConfigMapEnvSource) Package() util.Package   { return util.Core }
func (t ConfigMapEnvSource) Type() string            { return "k8s_core_ConfigMapEnvSource" }
func (t ConfigMapEnvSource) String() string          { return t.V.String() }
func (t ConfigMapEnvSource) Freeze()                 {} // TODO
func (t ConfigMapEnvSource) Truth() skylark.Bool     { return skylark.True }
func (t ConfigMapEnvSource) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ConfigMapEnvSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ConfigMapEnvSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ConfigMapEnvSource) AttrNames() []string { return ConfigMapEnvSource_attrs }
func (t ConfigMapEnvSource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ConfigMapEnvSource_fields, ConfigMapEnvSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ConfigMapEnvSource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ConfigMapEnvSource_fields, ConfigMapEnvSource_inline)
}

type ConfigMapKeySelector struct {
	V *core.ConfigMapKeySelector
}

var (
	_ boxed = (*ConfigMapKeySelector)(nil)

	ConfigMapKeySelector_fields = map[string]util.FieldSpec{}
	ConfigMapKeySelector_inline = map[string]util.FieldSpec{}
	ConfigMapKeySelector_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.ConfigMapKeySelector)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.ConfigMapKeySelector:
			return ConfigMapKeySelector{V: v}
		case core.ConfigMapKeySelector:
			return ConfigMapKeySelector{V: &v}
		default:
			return skylark.None
		}
	}
	ConfigMapKeySelector_attrs = setFieldTypes(t, ConfigMapKeySelector_fields, ConfigMapKeySelector_inline)
	Library["ConfigMapKeySelector"] = skylark.NewBuiltin("ConfigMapKeySelector", createConfigMapKeySelector)
}

func createConfigMapKeySelector(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ConfigMapKeySelector{V: &core.ConfigMapKeySelector{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ConfigMapKeySelector) Underlying() interface{} { return t.V }
func (t ConfigMapKeySelector) DeepCopy() boxed         { return ConfigMapKeySelector{V: t.V.DeepCopy()} }
func (t ConfigMapKeySelector) Package() util.Package   { return util.Core }
func (t ConfigMapKeySelector) Type() string            { return "k8s_core_ConfigMapKeySelector" }
func (t ConfigMapKeySelector) String() string          { return t.V.String() }
func (t ConfigMapKeySelector) Freeze()                 {} // TODO
func (t ConfigMapKeySelector) Truth() skylark.Bool     { return skylark.True }
func (t ConfigMapKeySelector) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ConfigMapKeySelector) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ConfigMapKeySelector)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ConfigMapKeySelector) AttrNames() []string { return ConfigMapKeySelector_attrs }
func (t ConfigMapKeySelector) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ConfigMapKeySelector_fields, ConfigMapKeySelector_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ConfigMapKeySelector) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ConfigMapKeySelector_fields, ConfigMapKeySelector_inline)
}

type ConfigMapList struct {
	V *core.ConfigMapList
}

var (
	_ boxed = (*ConfigMapList)(nil)

	ConfigMapList_fields = map[string]util.FieldSpec{}
	ConfigMapList_inline = map[string]util.FieldSpec{}
	ConfigMapList_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.ConfigMapList)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.ConfigMapList:
			return ConfigMapList{V: v}
		case core.ConfigMapList:
			return ConfigMapList{V: &v}
		default:
			return skylark.None
		}
	}
	ConfigMapList_attrs = setFieldTypes(t, ConfigMapList_fields, ConfigMapList_inline)
	Library["ConfigMapList"] = skylark.NewBuiltin("ConfigMapList", createConfigMapList)
}

func createConfigMapList(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ConfigMapList{V: &core.ConfigMapList{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ConfigMapList) Underlying() interface{} { return t.V }
func (t ConfigMapList) DeepCopy() boxed         { return ConfigMapList{V: t.V.DeepCopy()} }
func (t ConfigMapList) Package() util.Package   { return util.Core }
func (t ConfigMapList) Type() string            { return "k8s_core_ConfigMapList" }
func (t ConfigMapList) String() string          { return t.V.String() }
func (t ConfigMapList) Freeze()                 {} // TODO
func (t ConfigMapList) Truth() skylark.Bool     { return skylark.True }
func (t ConfigMapList) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ConfigMapList) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ConfigMapList)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ConfigMapList) AttrNames() []string { return ConfigMapList_attrs }
func (t ConfigMapList) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ConfigMapList_fields, ConfigMapList_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ConfigMapList) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ConfigMapList_fields, ConfigMapList_inline)
}

type ConfigMapNodeConfigSource struct {
	V *core.ConfigMapNodeConfigSource
}

var (
	_ boxed = (*ConfigMapNodeConfigSource)(nil)

	ConfigMapNodeConfigSource_fields = map[string]util.FieldSpec{}
	ConfigMapNodeConfigSource_inline = map[string]util.FieldSpec{}
	ConfigMapNodeConfigSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.ConfigMapNodeConfigSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.ConfigMapNodeConfigSource:
			return ConfigMapNodeConfigSource{V: v}
		case core.ConfigMapNodeConfigSource:
			return ConfigMapNodeConfigSource{V: &v}
		default:
			return skylark.None
		}
	}
	ConfigMapNodeConfigSource_attrs = setFieldTypes(t, ConfigMapNodeConfigSource_fields, ConfigMapNodeConfigSource_inline)
	Library["ConfigMapNodeConfigSource"] = skylark.NewBuiltin("ConfigMapNodeConfigSource", createConfigMapNodeConfigSource)
}

func createConfigMapNodeConfigSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ConfigMapNodeConfigSource{V: &core.ConfigMapNodeConfigSource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ConfigMapNodeConfigSource) Underlying() interface{} { return t.V }
func (t ConfigMapNodeConfigSource) DeepCopy() boxed {
	return ConfigMapNodeConfigSource{V: t.V.DeepCopy()}
}
func (t ConfigMapNodeConfigSource) Package() util.Package { return util.Core }
func (t ConfigMapNodeConfigSource) Type() string          { return "k8s_core_ConfigMapNodeConfigSource" }
func (t ConfigMapNodeConfigSource) String() string        { return t.V.String() }
func (t ConfigMapNodeConfigSource) Freeze()               {} // TODO
func (t ConfigMapNodeConfigSource) Truth() skylark.Bool   { return skylark.True }
func (t ConfigMapNodeConfigSource) Hash() (uint32, error) { return 0, unhashable(t.Type()) }
func (t ConfigMapNodeConfigSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ConfigMapNodeConfigSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ConfigMapNodeConfigSource) AttrNames() []string { return ConfigMapNodeConfigSource_attrs }
func (t ConfigMapNodeConfigSource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ConfigMapNodeConfigSource_fields, ConfigMapNodeConfigSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ConfigMapNodeConfigSource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ConfigMapNodeConfigSource_fields, ConfigMapNodeConfigSource_inline)
}

type ConfigMapProjection struct {
	V *core.ConfigMapProjection
}

var (
	_ boxed = (*ConfigMapProjection)(nil)

	ConfigMapProjection_fields = map[string]util.FieldSpec{}
	ConfigMapProjection_inline = map[string]util.FieldSpec{}
	ConfigMapProjection_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.ConfigMapProjection)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.ConfigMapProjection:
			return ConfigMapProjection{V: v}
		case core.ConfigMapProjection:
			return ConfigMapProjection{V: &v}
		default:
			return skylark.None
		}
	}
	ConfigMapProjection_attrs = setFieldTypes(t, ConfigMapProjection_fields, ConfigMapProjection_inline)
	Library["ConfigMapProjection"] = skylark.NewBuiltin("ConfigMapProjection", createConfigMapProjection)
}

func createConfigMapProjection(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ConfigMapProjection{V: &core.ConfigMapProjection{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ConfigMapProjection) Underlying() interface{} { return t.V }
func (t ConfigMapProjection) DeepCopy() boxed         { return ConfigMapProjection{V: t.V.DeepCopy()} }
func (t ConfigMapProjection) Package() util.Package   { return util.Core }
func (t ConfigMapProjection) Type() string            { return "k8s_core_ConfigMapProjection" }
func (t ConfigMapProjection) String() string          { return t.V.String() }
func (t ConfigMapProjection) Freeze()                 {} // TODO
func (t ConfigMapProjection) Truth() skylark.Bool     { return skylark.True }
func (t ConfigMapProjection) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ConfigMapProjection) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ConfigMapProjection)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ConfigMapProjection) AttrNames() []string { return ConfigMapProjection_attrs }
func (t ConfigMapProjection) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ConfigMapProjection_fields, ConfigMapProjection_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ConfigMapProjection) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ConfigMapProjection_fields, ConfigMapProjection_inline)
}

type ConfigMapVolumeSource struct {
	V *core.ConfigMapVolumeSource
}

var (
	_ boxed = (*ConfigMapVolumeSource)(nil)

	ConfigMapVolumeSource_fields = map[string]util.FieldSpec{}
	ConfigMapVolumeSource_inline = map[string]util.FieldSpec{}
	ConfigMapVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.ConfigMapVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.ConfigMapVolumeSource:
			return ConfigMapVolumeSource{V: v}
		case core.ConfigMapVolumeSource:
			return ConfigMapVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	ConfigMapVolumeSource_attrs = setFieldTypes(t, ConfigMapVolumeSource_fields, ConfigMapVolumeSource_inline)
	Library["ConfigMapVolumeSource"] = skylark.NewBuiltin("ConfigMapVolumeSource", createConfigMapVolumeSource)
}

func createConfigMapVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ConfigMapVolumeSource{V: &core.ConfigMapVolumeSource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ConfigMapVolumeSource) Underlying() interface{} { return t.V }
func (t ConfigMapVolumeSource) DeepCopy() boxed         { return ConfigMapVolumeSource{V: t.V.DeepCopy()} }
func (t ConfigMapVolumeSource) Package() util.Package   { return util.Core }
func (t ConfigMapVolumeSource) Type() string            { return "k8s_core_ConfigMapVolumeSource" }
func (t ConfigMapVolumeSource) String() string          { return t.V.String() }
func (t ConfigMapVolumeSource) Freeze()                 {} // TODO
func (t ConfigMapVolumeSource) Truth() skylark.Bool     { return skylark.True }
func (t ConfigMapVolumeSource) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ConfigMapVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ConfigMapVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ConfigMapVolumeSource) AttrNames() []string { return ConfigMapVolumeSource_attrs }
func (t ConfigMapVolumeSource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ConfigMapVolumeSource_fields, ConfigMapVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ConfigMapVolumeSource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ConfigMapVolumeSource_fields, ConfigMapVolumeSource_inline)
}

type Container struct {
	V *core.Container
}

var (
	_ boxed = (*Container)(nil)

	Container_fields = map[string]util.FieldSpec{}
	Container_inline = map[string]util.FieldSpec{}
	Container_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.Container)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.Container:
			return Container{V: v}
		case core.Container:
			return Container{V: &v}
		default:
			return skylark.None
		}
	}
	Container_attrs = setFieldTypes(t, Container_fields, Container_inline)
	Library["Container"] = skylark.NewBuiltin("Container", createContainer)
}

func createContainer(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := Container{V: &core.Container{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t Container) Underlying() interface{} { return t.V }
func (t Container) DeepCopy() boxed         { return Container{V: t.V.DeepCopy()} }
func (t Container) Package() util.Package   { return util.Core }
func (t Container) Type() string            { return "k8s_core_Container" }
func (t Container) String() string          { return t.V.String() }
func (t Container) Freeze()                 {} // TODO
func (t Container) Truth() skylark.Bool     { return skylark.True }
func (t Container) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t Container) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*Container)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t Container) AttrNames() []string { return Container_attrs }
func (t Container) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, Container_fields, Container_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t Container) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, Container_fields, Container_inline)
}

type ContainerImage struct {
	V *core.ContainerImage
}

var (
	_ boxed = (*ContainerImage)(nil)

	ContainerImage_fields = map[string]util.FieldSpec{}
	ContainerImage_inline = map[string]util.FieldSpec{}
	ContainerImage_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.ContainerImage)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.ContainerImage:
			return ContainerImage{V: v}
		case core.ContainerImage:
			return ContainerImage{V: &v}
		default:
			return skylark.None
		}
	}
	ContainerImage_attrs = setFieldTypes(t, ContainerImage_fields, ContainerImage_inline)
	Library["ContainerImage"] = skylark.NewBuiltin("ContainerImage", createContainerImage)
}

func createContainerImage(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ContainerImage{V: &core.ContainerImage{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ContainerImage) Underlying() interface{} { return t.V }
func (t ContainerImage) DeepCopy() boxed         { return ContainerImage{V: t.V.DeepCopy()} }
func (t ContainerImage) Package() util.Package   { return util.Core }
func (t ContainerImage) Type() string            { return "k8s_core_ContainerImage" }
func (t ContainerImage) String() string          { return t.V.String() }
func (t ContainerImage) Freeze()                 {} // TODO
func (t ContainerImage) Truth() skylark.Bool     { return skylark.True }
func (t ContainerImage) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ContainerImage) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ContainerImage)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ContainerImage) AttrNames() []string { return ContainerImage_attrs }
func (t ContainerImage) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ContainerImage_fields, ContainerImage_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ContainerImage) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ContainerImage_fields, ContainerImage_inline)
}

type ContainerPort struct {
	V *core.ContainerPort
}

var (
	_ boxed = (*ContainerPort)(nil)

	ContainerPort_fields = map[string]util.FieldSpec{}
	ContainerPort_inline = map[string]util.FieldSpec{}
	ContainerPort_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.ContainerPort)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.ContainerPort:
			return ContainerPort{V: v}
		case core.ContainerPort:
			return ContainerPort{V: &v}
		default:
			return skylark.None
		}
	}
	ContainerPort_attrs = setFieldTypes(t, ContainerPort_fields, ContainerPort_inline)
	Library["ContainerPort"] = skylark.NewBuiltin("ContainerPort", createContainerPort)
}

func createContainerPort(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ContainerPort{V: &core.ContainerPort{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ContainerPort) Underlying() interface{} { return t.V }
func (t ContainerPort) DeepCopy() boxed         { return ContainerPort{V: t.V.DeepCopy()} }
func (t ContainerPort) Package() util.Package   { return util.Core }
func (t ContainerPort) Type() string            { return "k8s_core_ContainerPort" }
func (t ContainerPort) String() string          { return t.V.String() }
func (t ContainerPort) Freeze()                 {} // TODO
func (t ContainerPort) Truth() skylark.Bool     { return skylark.True }
func (t ContainerPort) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ContainerPort) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ContainerPort)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ContainerPort) AttrNames() []string { return ContainerPort_attrs }
func (t ContainerPort) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ContainerPort_fields, ContainerPort_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ContainerPort) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ContainerPort_fields, ContainerPort_inline)
}

type ContainerState struct {
	V *core.ContainerState
}

var (
	_ boxed = (*ContainerState)(nil)

	ContainerState_fields = map[string]util.FieldSpec{}
	ContainerState_inline = map[string]util.FieldSpec{}
	ContainerState_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.ContainerState)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.ContainerState:
			return ContainerState{V: v}
		case core.ContainerState:
			return ContainerState{V: &v}
		default:
			return skylark.None
		}
	}
	ContainerState_attrs = setFieldTypes(t, ContainerState_fields, ContainerState_inline)
	Library["ContainerState"] = skylark.NewBuiltin("ContainerState", createContainerState)
}

func createContainerState(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ContainerState{V: &core.ContainerState{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ContainerState) Underlying() interface{} { return t.V }
func (t ContainerState) DeepCopy() boxed         { return ContainerState{V: t.V.DeepCopy()} }
func (t ContainerState) Package() util.Package   { return util.Core }
func (t ContainerState) Type() string            { return "k8s_core_ContainerState" }
func (t ContainerState) String() string          { return t.V.String() }
func (t ContainerState) Freeze()                 {} // TODO
func (t ContainerState) Truth() skylark.Bool     { return skylark.True }
func (t ContainerState) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ContainerState) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ContainerState)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ContainerState) AttrNames() []string { return ContainerState_attrs }
func (t ContainerState) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ContainerState_fields, ContainerState_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ContainerState) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ContainerState_fields, ContainerState_inline)
}

type ContainerStateRunning struct {
	V *core.ContainerStateRunning
}

var (
	_ boxed = (*ContainerStateRunning)(nil)

	ContainerStateRunning_fields = map[string]util.FieldSpec{}
	ContainerStateRunning_inline = map[string]util.FieldSpec{}
	ContainerStateRunning_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.ContainerStateRunning)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.ContainerStateRunning:
			return ContainerStateRunning{V: v}
		case core.ContainerStateRunning:
			return ContainerStateRunning{V: &v}
		default:
			return skylark.None
		}
	}
	ContainerStateRunning_attrs = setFieldTypes(t, ContainerStateRunning_fields, ContainerStateRunning_inline)
	Library["ContainerStateRunning"] = skylark.NewBuiltin("ContainerStateRunning", createContainerStateRunning)
}

func createContainerStateRunning(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ContainerStateRunning{V: &core.ContainerStateRunning{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ContainerStateRunning) Underlying() interface{} { return t.V }
func (t ContainerStateRunning) DeepCopy() boxed         { return ContainerStateRunning{V: t.V.DeepCopy()} }
func (t ContainerStateRunning) Package() util.Package   { return util.Core }
func (t ContainerStateRunning) Type() string            { return "k8s_core_ContainerStateRunning" }
func (t ContainerStateRunning) String() string          { return t.V.String() }
func (t ContainerStateRunning) Freeze()                 {} // TODO
func (t ContainerStateRunning) Truth() skylark.Bool     { return skylark.True }
func (t ContainerStateRunning) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ContainerStateRunning) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ContainerStateRunning)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ContainerStateRunning) AttrNames() []string { return ContainerStateRunning_attrs }
func (t ContainerStateRunning) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ContainerStateRunning_fields, ContainerStateRunning_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ContainerStateRunning) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ContainerStateRunning_fields, ContainerStateRunning_inline)
}

type ContainerStateTerminated struct {
	V *core.ContainerStateTerminated
}

var (
	_ boxed = (*ContainerStateTerminated)(nil)

	ContainerStateTerminated_fields = map[string]util.FieldSpec{}
	ContainerStateTerminated_inline = map[string]util.FieldSpec{}
	ContainerStateTerminated_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.ContainerStateTerminated)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.ContainerStateTerminated:
			return ContainerStateTerminated{V: v}
		case core.ContainerStateTerminated:
			return ContainerStateTerminated{V: &v}
		default:
			return skylark.None
		}
	}
	ContainerStateTerminated_attrs = setFieldTypes(t, ContainerStateTerminated_fields, ContainerStateTerminated_inline)
	Library["ContainerStateTerminated"] = skylark.NewBuiltin("ContainerStateTerminated", createContainerStateTerminated)
}

func createContainerStateTerminated(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ContainerStateTerminated{V: &core.ContainerStateTerminated{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ContainerStateTerminated) Underlying() interface{} { return t.V }
func (t ContainerStateTerminated) DeepCopy() boxed         { return ContainerStateTerminated{V: t.V.DeepCopy()} }
func (t ContainerStateTerminated) Package() util.Package   { return util.Core }
func (t ContainerStateTerminated) Type() string            { return "k8s_core_ContainerStateTerminated" }
func (t ContainerStateTerminated) String() string          { return t.V.String() }
func (t ContainerStateTerminated) Freeze()                 {} // TODO
func (t ContainerStateTerminated) Truth() skylark.Bool     { return skylark.True }
func (t ContainerStateTerminated) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ContainerStateTerminated) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ContainerStateTerminated)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ContainerStateTerminated) AttrNames() []string { return ContainerStateTerminated_attrs }
func (t ContainerStateTerminated) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ContainerStateTerminated_fields, ContainerStateTerminated_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ContainerStateTerminated) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ContainerStateTerminated_fields, ContainerStateTerminated_inline)
}

type ContainerStateWaiting struct {
	V *core.ContainerStateWaiting
}

var (
	_ boxed = (*ContainerStateWaiting)(nil)

	ContainerStateWaiting_fields = map[string]util.FieldSpec{}
	ContainerStateWaiting_inline = map[string]util.FieldSpec{}
	ContainerStateWaiting_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.ContainerStateWaiting)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.ContainerStateWaiting:
			return ContainerStateWaiting{V: v}
		case core.ContainerStateWaiting:
			return ContainerStateWaiting{V: &v}
		default:
			return skylark.None
		}
	}
	ContainerStateWaiting_attrs = setFieldTypes(t, ContainerStateWaiting_fields, ContainerStateWaiting_inline)
	Library["ContainerStateWaiting"] = skylark.NewBuiltin("ContainerStateWaiting", createContainerStateWaiting)
}

func createContainerStateWaiting(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ContainerStateWaiting{V: &core.ContainerStateWaiting{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ContainerStateWaiting) Underlying() interface{} { return t.V }
func (t ContainerStateWaiting) DeepCopy() boxed         { return ContainerStateWaiting{V: t.V.DeepCopy()} }
func (t ContainerStateWaiting) Package() util.Package   { return util.Core }
func (t ContainerStateWaiting) Type() string            { return "k8s_core_ContainerStateWaiting" }
func (t ContainerStateWaiting) String() string          { return t.V.String() }
func (t ContainerStateWaiting) Freeze()                 {} // TODO
func (t ContainerStateWaiting) Truth() skylark.Bool     { return skylark.True }
func (t ContainerStateWaiting) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ContainerStateWaiting) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ContainerStateWaiting)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ContainerStateWaiting) AttrNames() []string { return ContainerStateWaiting_attrs }
func (t ContainerStateWaiting) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ContainerStateWaiting_fields, ContainerStateWaiting_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ContainerStateWaiting) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ContainerStateWaiting_fields, ContainerStateWaiting_inline)
}

type ContainerStatus struct {
	V *core.ContainerStatus
}

var (
	_ boxed = (*ContainerStatus)(nil)

	ContainerStatus_fields = map[string]util.FieldSpec{}
	ContainerStatus_inline = map[string]util.FieldSpec{}
	ContainerStatus_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.ContainerStatus)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.ContainerStatus:
			return ContainerStatus{V: v}
		case core.ContainerStatus:
			return ContainerStatus{V: &v}
		default:
			return skylark.None
		}
	}
	ContainerStatus_attrs = setFieldTypes(t, ContainerStatus_fields, ContainerStatus_inline)
	Library["ContainerStatus"] = skylark.NewBuiltin("ContainerStatus", createContainerStatus)
}

func createContainerStatus(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ContainerStatus{V: &core.ContainerStatus{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ContainerStatus) Underlying() interface{} { return t.V }
func (t ContainerStatus) DeepCopy() boxed         { return ContainerStatus{V: t.V.DeepCopy()} }
func (t ContainerStatus) Package() util.Package   { return util.Core }
func (t ContainerStatus) Type() string            { return "k8s_core_ContainerStatus" }
func (t ContainerStatus) String() string          { return t.V.String() }
func (t ContainerStatus) Freeze()                 {} // TODO
func (t ContainerStatus) Truth() skylark.Bool     { return skylark.True }
func (t ContainerStatus) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ContainerStatus) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ContainerStatus)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ContainerStatus) AttrNames() []string { return ContainerStatus_attrs }
func (t ContainerStatus) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ContainerStatus_fields, ContainerStatus_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ContainerStatus) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ContainerStatus_fields, ContainerStatus_inline)
}

type DaemonEndpoint struct {
	V *core.DaemonEndpoint
}

var (
	_ boxed = (*DaemonEndpoint)(nil)

	DaemonEndpoint_fields = map[string]util.FieldSpec{}
	DaemonEndpoint_inline = map[string]util.FieldSpec{}
	DaemonEndpoint_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.DaemonEndpoint)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.DaemonEndpoint:
			return DaemonEndpoint{V: v}
		case core.DaemonEndpoint:
			return DaemonEndpoint{V: &v}
		default:
			return skylark.None
		}
	}
	DaemonEndpoint_attrs = setFieldTypes(t, DaemonEndpoint_fields, DaemonEndpoint_inline)
	Library["DaemonEndpoint"] = skylark.NewBuiltin("DaemonEndpoint", createDaemonEndpoint)
}

func createDaemonEndpoint(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := DaemonEndpoint{V: &core.DaemonEndpoint{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t DaemonEndpoint) Underlying() interface{} { return t.V }
func (t DaemonEndpoint) DeepCopy() boxed         { return DaemonEndpoint{V: t.V.DeepCopy()} }
func (t DaemonEndpoint) Package() util.Package   { return util.Core }
func (t DaemonEndpoint) Type() string            { return "k8s_core_DaemonEndpoint" }
func (t DaemonEndpoint) String() string          { return t.V.String() }
func (t DaemonEndpoint) Freeze()                 {} // TODO
func (t DaemonEndpoint) Truth() skylark.Bool     { return skylark.True }
func (t DaemonEndpoint) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t DaemonEndpoint) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*DaemonEndpoint)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t DaemonEndpoint) AttrNames() []string { return DaemonEndpoint_attrs }
func (t DaemonEndpoint) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, DaemonEndpoint_fields, DaemonEndpoint_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t DaemonEndpoint) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, DaemonEndpoint_fields, DaemonEndpoint_inline)
}

type DownwardAPIProjection struct {
	V *core.DownwardAPIProjection
}

var (
	_ boxed = (*DownwardAPIProjection)(nil)

	DownwardAPIProjection_fields = map[string]util.FieldSpec{}
	DownwardAPIProjection_inline = map[string]util.FieldSpec{}
	DownwardAPIProjection_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.DownwardAPIProjection)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.DownwardAPIProjection:
			return DownwardAPIProjection{V: v}
		case core.DownwardAPIProjection:
			return DownwardAPIProjection{V: &v}
		default:
			return skylark.None
		}
	}
	DownwardAPIProjection_attrs = setFieldTypes(t, DownwardAPIProjection_fields, DownwardAPIProjection_inline)
	Library["DownwardAPIProjection"] = skylark.NewBuiltin("DownwardAPIProjection", createDownwardAPIProjection)
}

func createDownwardAPIProjection(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := DownwardAPIProjection{V: &core.DownwardAPIProjection{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t DownwardAPIProjection) Underlying() interface{} { return t.V }
func (t DownwardAPIProjection) DeepCopy() boxed         { return DownwardAPIProjection{V: t.V.DeepCopy()} }
func (t DownwardAPIProjection) Package() util.Package   { return util.Core }
func (t DownwardAPIProjection) Type() string            { return "k8s_core_DownwardAPIProjection" }
func (t DownwardAPIProjection) String() string          { return t.V.String() }
func (t DownwardAPIProjection) Freeze()                 {} // TODO
func (t DownwardAPIProjection) Truth() skylark.Bool     { return skylark.True }
func (t DownwardAPIProjection) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t DownwardAPIProjection) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*DownwardAPIProjection)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t DownwardAPIProjection) AttrNames() []string { return DownwardAPIProjection_attrs }
func (t DownwardAPIProjection) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, DownwardAPIProjection_fields, DownwardAPIProjection_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t DownwardAPIProjection) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, DownwardAPIProjection_fields, DownwardAPIProjection_inline)
}

type DownwardAPIVolumeFile struct {
	V *core.DownwardAPIVolumeFile
}

var (
	_ boxed = (*DownwardAPIVolumeFile)(nil)

	DownwardAPIVolumeFile_fields = map[string]util.FieldSpec{}
	DownwardAPIVolumeFile_inline = map[string]util.FieldSpec{}
	DownwardAPIVolumeFile_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.DownwardAPIVolumeFile)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.DownwardAPIVolumeFile:
			return DownwardAPIVolumeFile{V: v}
		case core.DownwardAPIVolumeFile:
			return DownwardAPIVolumeFile{V: &v}
		default:
			return skylark.None
		}
	}
	DownwardAPIVolumeFile_attrs = setFieldTypes(t, DownwardAPIVolumeFile_fields, DownwardAPIVolumeFile_inline)
	Library["DownwardAPIVolumeFile"] = skylark.NewBuiltin("DownwardAPIVolumeFile", createDownwardAPIVolumeFile)
}

func createDownwardAPIVolumeFile(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := DownwardAPIVolumeFile{V: &core.DownwardAPIVolumeFile{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t DownwardAPIVolumeFile) Underlying() interface{} { return t.V }
func (t DownwardAPIVolumeFile) DeepCopy() boxed         { return DownwardAPIVolumeFile{V: t.V.DeepCopy()} }
func (t DownwardAPIVolumeFile) Package() util.Package   { return util.Core }
func (t DownwardAPIVolumeFile) Type() string            { return "k8s_core_DownwardAPIVolumeFile" }
func (t DownwardAPIVolumeFile) String() string          { return t.V.String() }
func (t DownwardAPIVolumeFile) Freeze()                 {} // TODO
func (t DownwardAPIVolumeFile) Truth() skylark.Bool     { return skylark.True }
func (t DownwardAPIVolumeFile) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t DownwardAPIVolumeFile) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*DownwardAPIVolumeFile)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t DownwardAPIVolumeFile) AttrNames() []string { return DownwardAPIVolumeFile_attrs }
func (t DownwardAPIVolumeFile) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, DownwardAPIVolumeFile_fields, DownwardAPIVolumeFile_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t DownwardAPIVolumeFile) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, DownwardAPIVolumeFile_fields, DownwardAPIVolumeFile_inline)
}

type DownwardAPIVolumeSource struct {
	V *core.DownwardAPIVolumeSource
}

var (
	_ boxed = (*DownwardAPIVolumeSource)(nil)

	DownwardAPIVolumeSource_fields = map[string]util.FieldSpec{}
	DownwardAPIVolumeSource_inline = map[string]util.FieldSpec{}
	DownwardAPIVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.DownwardAPIVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.DownwardAPIVolumeSource:
			return DownwardAPIVolumeSource{V: v}
		case core.DownwardAPIVolumeSource:
			return DownwardAPIVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	DownwardAPIVolumeSource_attrs = setFieldTypes(t, DownwardAPIVolumeSource_fields, DownwardAPIVolumeSource_inline)
	Library["DownwardAPIVolumeSource"] = skylark.NewBuiltin("DownwardAPIVolumeSource", createDownwardAPIVolumeSource)
}

func createDownwardAPIVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := DownwardAPIVolumeSource{V: &core.DownwardAPIVolumeSource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t DownwardAPIVolumeSource) Underlying() interface{} { return t.V }
func (t DownwardAPIVolumeSource) DeepCopy() boxed         { return DownwardAPIVolumeSource{V: t.V.DeepCopy()} }
func (t DownwardAPIVolumeSource) Package() util.Package   { return util.Core }
func (t DownwardAPIVolumeSource) Type() string            { return "k8s_core_DownwardAPIVolumeSource" }
func (t DownwardAPIVolumeSource) String() string          { return t.V.String() }
func (t DownwardAPIVolumeSource) Freeze()                 {} // TODO
func (t DownwardAPIVolumeSource) Truth() skylark.Bool     { return skylark.True }
func (t DownwardAPIVolumeSource) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t DownwardAPIVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*DownwardAPIVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t DownwardAPIVolumeSource) AttrNames() []string { return DownwardAPIVolumeSource_attrs }
func (t DownwardAPIVolumeSource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, DownwardAPIVolumeSource_fields, DownwardAPIVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t DownwardAPIVolumeSource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, DownwardAPIVolumeSource_fields, DownwardAPIVolumeSource_inline)
}

type EmptyDirVolumeSource struct {
	V *core.EmptyDirVolumeSource
}

var (
	_ boxed = (*EmptyDirVolumeSource)(nil)

	EmptyDirVolumeSource_fields = map[string]util.FieldSpec{}
	EmptyDirVolumeSource_inline = map[string]util.FieldSpec{}
	EmptyDirVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.EmptyDirVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.EmptyDirVolumeSource:
			return EmptyDirVolumeSource{V: v}
		case core.EmptyDirVolumeSource:
			return EmptyDirVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	EmptyDirVolumeSource_attrs = setFieldTypes(t, EmptyDirVolumeSource_fields, EmptyDirVolumeSource_inline)
	Library["EmptyDirVolumeSource"] = skylark.NewBuiltin("EmptyDirVolumeSource", createEmptyDirVolumeSource)
}

func createEmptyDirVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := EmptyDirVolumeSource{V: &core.EmptyDirVolumeSource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t EmptyDirVolumeSource) Underlying() interface{} { return t.V }
func (t EmptyDirVolumeSource) DeepCopy() boxed         { return EmptyDirVolumeSource{V: t.V.DeepCopy()} }
func (t EmptyDirVolumeSource) Package() util.Package   { return util.Core }
func (t EmptyDirVolumeSource) Type() string            { return "k8s_core_EmptyDirVolumeSource" }
func (t EmptyDirVolumeSource) String() string          { return t.V.String() }
func (t EmptyDirVolumeSource) Freeze()                 {} // TODO
func (t EmptyDirVolumeSource) Truth() skylark.Bool     { return skylark.True }
func (t EmptyDirVolumeSource) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t EmptyDirVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*EmptyDirVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t EmptyDirVolumeSource) AttrNames() []string { return EmptyDirVolumeSource_attrs }
func (t EmptyDirVolumeSource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, EmptyDirVolumeSource_fields, EmptyDirVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t EmptyDirVolumeSource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, EmptyDirVolumeSource_fields, EmptyDirVolumeSource_inline)
}

type EndpointAddress struct {
	V *core.EndpointAddress
}

var (
	_ boxed = (*EndpointAddress)(nil)

	EndpointAddress_fields = map[string]util.FieldSpec{}
	EndpointAddress_inline = map[string]util.FieldSpec{}
	EndpointAddress_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.EndpointAddress)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.EndpointAddress:
			return EndpointAddress{V: v}
		case core.EndpointAddress:
			return EndpointAddress{V: &v}
		default:
			return skylark.None
		}
	}
	EndpointAddress_attrs = setFieldTypes(t, EndpointAddress_fields, EndpointAddress_inline)
	Library["EndpointAddress"] = skylark.NewBuiltin("EndpointAddress", createEndpointAddress)
}

func createEndpointAddress(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := EndpointAddress{V: &core.EndpointAddress{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t EndpointAddress) Underlying() interface{} { return t.V }
func (t EndpointAddress) DeepCopy() boxed         { return EndpointAddress{V: t.V.DeepCopy()} }
func (t EndpointAddress) Package() util.Package   { return util.Core }
func (t EndpointAddress) Type() string            { return "k8s_core_EndpointAddress" }
func (t EndpointAddress) String() string          { return t.V.String() }
func (t EndpointAddress) Freeze()                 {} // TODO
func (t EndpointAddress) Truth() skylark.Bool     { return skylark.True }
func (t EndpointAddress) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t EndpointAddress) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*EndpointAddress)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t EndpointAddress) AttrNames() []string { return EndpointAddress_attrs }
func (t EndpointAddress) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, EndpointAddress_fields, EndpointAddress_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t EndpointAddress) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, EndpointAddress_fields, EndpointAddress_inline)
}

type EndpointPort struct {
	V *core.EndpointPort
}

var (
	_ boxed = (*EndpointPort)(nil)

	EndpointPort_fields = map[string]util.FieldSpec{}
	EndpointPort_inline = map[string]util.FieldSpec{}
	EndpointPort_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.EndpointPort)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.EndpointPort:
			return EndpointPort{V: v}
		case core.EndpointPort:
			return EndpointPort{V: &v}
		default:
			return skylark.None
		}
	}
	EndpointPort_attrs = setFieldTypes(t, EndpointPort_fields, EndpointPort_inline)
	Library["EndpointPort"] = skylark.NewBuiltin("EndpointPort", createEndpointPort)
}

func createEndpointPort(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := EndpointPort{V: &core.EndpointPort{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t EndpointPort) Underlying() interface{} { return t.V }
func (t EndpointPort) DeepCopy() boxed         { return EndpointPort{V: t.V.DeepCopy()} }
func (t EndpointPort) Package() util.Package   { return util.Core }
func (t EndpointPort) Type() string            { return "k8s_core_EndpointPort" }
func (t EndpointPort) String() string          { return t.V.String() }
func (t EndpointPort) Freeze()                 {} // TODO
func (t EndpointPort) Truth() skylark.Bool     { return skylark.True }
func (t EndpointPort) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t EndpointPort) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*EndpointPort)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t EndpointPort) AttrNames() []string { return EndpointPort_attrs }
func (t EndpointPort) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, EndpointPort_fields, EndpointPort_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t EndpointPort) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, EndpointPort_fields, EndpointPort_inline)
}

type EndpointSubset struct {
	V *core.EndpointSubset
}

var (
	_ boxed = (*EndpointSubset)(nil)

	EndpointSubset_fields = map[string]util.FieldSpec{}
	EndpointSubset_inline = map[string]util.FieldSpec{}
	EndpointSubset_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.EndpointSubset)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.EndpointSubset:
			return EndpointSubset{V: v}
		case core.EndpointSubset:
			return EndpointSubset{V: &v}
		default:
			return skylark.None
		}
	}
	EndpointSubset_attrs = setFieldTypes(t, EndpointSubset_fields, EndpointSubset_inline)
	Library["EndpointSubset"] = skylark.NewBuiltin("EndpointSubset", createEndpointSubset)
}

func createEndpointSubset(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := EndpointSubset{V: &core.EndpointSubset{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t EndpointSubset) Underlying() interface{} { return t.V }
func (t EndpointSubset) DeepCopy() boxed         { return EndpointSubset{V: t.V.DeepCopy()} }
func (t EndpointSubset) Package() util.Package   { return util.Core }
func (t EndpointSubset) Type() string            { return "k8s_core_EndpointSubset" }
func (t EndpointSubset) String() string          { return t.V.String() }
func (t EndpointSubset) Freeze()                 {} // TODO
func (t EndpointSubset) Truth() skylark.Bool     { return skylark.True }
func (t EndpointSubset) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t EndpointSubset) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*EndpointSubset)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t EndpointSubset) AttrNames() []string { return EndpointSubset_attrs }
func (t EndpointSubset) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, EndpointSubset_fields, EndpointSubset_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t EndpointSubset) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, EndpointSubset_fields, EndpointSubset_inline)
}

type Endpoints struct {
	V *core.Endpoints
}

var (
	_ boxed = (*Endpoints)(nil)

	Endpoints_fields = map[string]util.FieldSpec{}
	Endpoints_inline = map[string]util.FieldSpec{}
	Endpoints_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.Endpoints)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.Endpoints:
			return Endpoints{V: v}
		case core.Endpoints:
			return Endpoints{V: &v}
		default:
			return skylark.None
		}
	}
	Endpoints_attrs = setFieldTypes(t, Endpoints_fields, Endpoints_inline)
	Library["Endpoints"] = skylark.NewBuiltin("Endpoints", createEndpoints)
}

func createEndpoints(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := Endpoints{V: &core.Endpoints{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t Endpoints) Underlying() interface{} { return t.V }
func (t Endpoints) DeepCopy() boxed         { return Endpoints{V: t.V.DeepCopy()} }
func (t Endpoints) Package() util.Package   { return util.Core }
func (t Endpoints) Type() string            { return "k8s_core_Endpoints" }
func (t Endpoints) String() string          { return t.V.String() }
func (t Endpoints) Freeze()                 {} // TODO
func (t Endpoints) Truth() skylark.Bool     { return skylark.True }
func (t Endpoints) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t Endpoints) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*Endpoints)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t Endpoints) AttrNames() []string { return Endpoints_attrs }
func (t Endpoints) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, Endpoints_fields, Endpoints_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t Endpoints) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, Endpoints_fields, Endpoints_inline)
}

type EndpointsList struct {
	V *core.EndpointsList
}

var (
	_ boxed = (*EndpointsList)(nil)

	EndpointsList_fields = map[string]util.FieldSpec{}
	EndpointsList_inline = map[string]util.FieldSpec{}
	EndpointsList_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.EndpointsList)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.EndpointsList:
			return EndpointsList{V: v}
		case core.EndpointsList:
			return EndpointsList{V: &v}
		default:
			return skylark.None
		}
	}
	EndpointsList_attrs = setFieldTypes(t, EndpointsList_fields, EndpointsList_inline)
	Library["EndpointsList"] = skylark.NewBuiltin("EndpointsList", createEndpointsList)
}

func createEndpointsList(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := EndpointsList{V: &core.EndpointsList{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t EndpointsList) Underlying() interface{} { return t.V }
func (t EndpointsList) DeepCopy() boxed         { return EndpointsList{V: t.V.DeepCopy()} }
func (t EndpointsList) Package() util.Package   { return util.Core }
func (t EndpointsList) Type() string            { return "k8s_core_EndpointsList" }
func (t EndpointsList) String() string          { return t.V.String() }
func (t EndpointsList) Freeze()                 {} // TODO
func (t EndpointsList) Truth() skylark.Bool     { return skylark.True }
func (t EndpointsList) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t EndpointsList) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*EndpointsList)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t EndpointsList) AttrNames() []string { return EndpointsList_attrs }
func (t EndpointsList) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, EndpointsList_fields, EndpointsList_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t EndpointsList) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, EndpointsList_fields, EndpointsList_inline)
}

type EnvFromSource struct {
	V *core.EnvFromSource
}

var (
	_ boxed = (*EnvFromSource)(nil)

	EnvFromSource_fields = map[string]util.FieldSpec{}
	EnvFromSource_inline = map[string]util.FieldSpec{}
	EnvFromSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.EnvFromSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.EnvFromSource:
			return EnvFromSource{V: v}
		case core.EnvFromSource:
			return EnvFromSource{V: &v}
		default:
			return skylark.None
		}
	}
	EnvFromSource_attrs = setFieldTypes(t, EnvFromSource_fields, EnvFromSource_inline)
	Library["EnvFromSource"] = skylark.NewBuiltin("EnvFromSource", createEnvFromSource)
}

func createEnvFromSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := EnvFromSource{V: &core.EnvFromSource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t EnvFromSource) Underlying() interface{} { return t.V }
func (t EnvFromSource) DeepCopy() boxed         { return EnvFromSource{V: t.V.DeepCopy()} }
func (t EnvFromSource) Package() util.Package   { return util.Core }
func (t EnvFromSource) Type() string            { return "k8s_core_EnvFromSource" }
func (t EnvFromSource) String() string          { return t.V.String() }
func (t EnvFromSource) Freeze()                 {} // TODO
func (t EnvFromSource) Truth() skylark.Bool     { return skylark.True }
func (t EnvFromSource) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t EnvFromSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*EnvFromSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t EnvFromSource) AttrNames() []string { return EnvFromSource_attrs }
func (t EnvFromSource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, EnvFromSource_fields, EnvFromSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t EnvFromSource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, EnvFromSource_fields, EnvFromSource_inline)
}

type EnvVar struct {
	V *core.EnvVar
}

var (
	_ boxed = (*EnvVar)(nil)

	EnvVar_fields = map[string]util.FieldSpec{}
	EnvVar_inline = map[string]util.FieldSpec{}
	EnvVar_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.EnvVar)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.EnvVar:
			return EnvVar{V: v}
		case core.EnvVar:
			return EnvVar{V: &v}
		default:
			return skylark.None
		}
	}
	EnvVar_attrs = setFieldTypes(t, EnvVar_fields, EnvVar_inline)
	Library["EnvVar"] = skylark.NewBuiltin("EnvVar", createEnvVar)
}

func createEnvVar(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := EnvVar{V: &core.EnvVar{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t EnvVar) Underlying() interface{} { return t.V }
func (t EnvVar) DeepCopy() boxed         { return EnvVar{V: t.V.DeepCopy()} }
func (t EnvVar) Package() util.Package   { return util.Core }
func (t EnvVar) Type() string            { return "k8s_core_EnvVar" }
func (t EnvVar) String() string          { return t.V.String() }
func (t EnvVar) Freeze()                 {} // TODO
func (t EnvVar) Truth() skylark.Bool     { return skylark.True }
func (t EnvVar) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t EnvVar) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*EnvVar)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t EnvVar) AttrNames() []string { return EnvVar_attrs }
func (t EnvVar) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, EnvVar_fields, EnvVar_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t EnvVar) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, EnvVar_fields, EnvVar_inline)
}

type EnvVarSource struct {
	V *core.EnvVarSource
}

var (
	_ boxed = (*EnvVarSource)(nil)

	EnvVarSource_fields = map[string]util.FieldSpec{}
	EnvVarSource_inline = map[string]util.FieldSpec{}
	EnvVarSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.EnvVarSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.EnvVarSource:
			return EnvVarSource{V: v}
		case core.EnvVarSource:
			return EnvVarSource{V: &v}
		default:
			return skylark.None
		}
	}
	EnvVarSource_attrs = setFieldTypes(t, EnvVarSource_fields, EnvVarSource_inline)
	Library["EnvVarSource"] = skylark.NewBuiltin("EnvVarSource", createEnvVarSource)
}

func createEnvVarSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := EnvVarSource{V: &core.EnvVarSource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t EnvVarSource) Underlying() interface{} { return t.V }
func (t EnvVarSource) DeepCopy() boxed         { return EnvVarSource{V: t.V.DeepCopy()} }
func (t EnvVarSource) Package() util.Package   { return util.Core }
func (t EnvVarSource) Type() string            { return "k8s_core_EnvVarSource" }
func (t EnvVarSource) String() string          { return t.V.String() }
func (t EnvVarSource) Freeze()                 {} // TODO
func (t EnvVarSource) Truth() skylark.Bool     { return skylark.True }
func (t EnvVarSource) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t EnvVarSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*EnvVarSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t EnvVarSource) AttrNames() []string { return EnvVarSource_attrs }
func (t EnvVarSource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, EnvVarSource_fields, EnvVarSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t EnvVarSource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, EnvVarSource_fields, EnvVarSource_inline)
}

type Event struct {
	V *core.Event
}

var (
	_ boxed = (*Event)(nil)

	Event_fields = map[string]util.FieldSpec{}
	Event_inline = map[string]util.FieldSpec{}
	Event_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.Event)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.Event:
			return Event{V: v}
		case core.Event:
			return Event{V: &v}
		default:
			return skylark.None
		}
	}
	Event_attrs = setFieldTypes(t, Event_fields, Event_inline)
	Library["Event"] = skylark.NewBuiltin("Event", createEvent)
}

func createEvent(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := Event{V: &core.Event{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t Event) Underlying() interface{} { return t.V }
func (t Event) DeepCopy() boxed         { return Event{V: t.V.DeepCopy()} }
func (t Event) Package() util.Package   { return util.Core }
func (t Event) Type() string            { return "k8s_core_Event" }
func (t Event) String() string          { return t.V.String() }
func (t Event) Freeze()                 {} // TODO
func (t Event) Truth() skylark.Bool     { return skylark.True }
func (t Event) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t Event) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*Event)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t Event) AttrNames() []string { return Event_attrs }
func (t Event) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, Event_fields, Event_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t Event) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, Event_fields, Event_inline)
}

type EventList struct {
	V *core.EventList
}

var (
	_ boxed = (*EventList)(nil)

	EventList_fields = map[string]util.FieldSpec{}
	EventList_inline = map[string]util.FieldSpec{}
	EventList_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.EventList)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.EventList:
			return EventList{V: v}
		case core.EventList:
			return EventList{V: &v}
		default:
			return skylark.None
		}
	}
	EventList_attrs = setFieldTypes(t, EventList_fields, EventList_inline)
	Library["EventList"] = skylark.NewBuiltin("EventList", createEventList)
}

func createEventList(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := EventList{V: &core.EventList{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t EventList) Underlying() interface{} { return t.V }
func (t EventList) DeepCopy() boxed         { return EventList{V: t.V.DeepCopy()} }
func (t EventList) Package() util.Package   { return util.Core }
func (t EventList) Type() string            { return "k8s_core_EventList" }
func (t EventList) String() string          { return t.V.String() }
func (t EventList) Freeze()                 {} // TODO
func (t EventList) Truth() skylark.Bool     { return skylark.True }
func (t EventList) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t EventList) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*EventList)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t EventList) AttrNames() []string { return EventList_attrs }
func (t EventList) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, EventList_fields, EventList_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t EventList) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, EventList_fields, EventList_inline)
}

type EventSeries struct {
	V *core.EventSeries
}

var (
	_ boxed = (*EventSeries)(nil)

	EventSeries_fields = map[string]util.FieldSpec{}
	EventSeries_inline = map[string]util.FieldSpec{}
	EventSeries_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.EventSeries)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.EventSeries:
			return EventSeries{V: v}
		case core.EventSeries:
			return EventSeries{V: &v}
		default:
			return skylark.None
		}
	}
	EventSeries_attrs = setFieldTypes(t, EventSeries_fields, EventSeries_inline)
	Library["EventSeries"] = skylark.NewBuiltin("EventSeries", createEventSeries)
}

func createEventSeries(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := EventSeries{V: &core.EventSeries{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t EventSeries) Underlying() interface{} { return t.V }
func (t EventSeries) DeepCopy() boxed         { return EventSeries{V: t.V.DeepCopy()} }
func (t EventSeries) Package() util.Package   { return util.Core }
func (t EventSeries) Type() string            { return "k8s_core_EventSeries" }
func (t EventSeries) String() string          { return t.V.String() }
func (t EventSeries) Freeze()                 {} // TODO
func (t EventSeries) Truth() skylark.Bool     { return skylark.True }
func (t EventSeries) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t EventSeries) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*EventSeries)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t EventSeries) AttrNames() []string { return EventSeries_attrs }
func (t EventSeries) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, EventSeries_fields, EventSeries_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t EventSeries) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, EventSeries_fields, EventSeries_inline)
}

type EventSource struct {
	V *core.EventSource
}

var (
	_ boxed = (*EventSource)(nil)

	EventSource_fields = map[string]util.FieldSpec{}
	EventSource_inline = map[string]util.FieldSpec{}
	EventSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.EventSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.EventSource:
			return EventSource{V: v}
		case core.EventSource:
			return EventSource{V: &v}
		default:
			return skylark.None
		}
	}
	EventSource_attrs = setFieldTypes(t, EventSource_fields, EventSource_inline)
	Library["EventSource"] = skylark.NewBuiltin("EventSource", createEventSource)
}

func createEventSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := EventSource{V: &core.EventSource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t EventSource) Underlying() interface{} { return t.V }
func (t EventSource) DeepCopy() boxed         { return EventSource{V: t.V.DeepCopy()} }
func (t EventSource) Package() util.Package   { return util.Core }
func (t EventSource) Type() string            { return "k8s_core_EventSource" }
func (t EventSource) String() string          { return t.V.String() }
func (t EventSource) Freeze()                 {} // TODO
func (t EventSource) Truth() skylark.Bool     { return skylark.True }
func (t EventSource) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t EventSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*EventSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t EventSource) AttrNames() []string { return EventSource_attrs }
func (t EventSource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, EventSource_fields, EventSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t EventSource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, EventSource_fields, EventSource_inline)
}

type ExecAction struct {
	V *core.ExecAction
}

var (
	_ boxed = (*ExecAction)(nil)

	ExecAction_fields = map[string]util.FieldSpec{}
	ExecAction_inline = map[string]util.FieldSpec{}
	ExecAction_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.ExecAction)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.ExecAction:
			return ExecAction{V: v}
		case core.ExecAction:
			return ExecAction{V: &v}
		default:
			return skylark.None
		}
	}
	ExecAction_attrs = setFieldTypes(t, ExecAction_fields, ExecAction_inline)
	Library["ExecAction"] = skylark.NewBuiltin("ExecAction", createExecAction)
}

func createExecAction(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ExecAction{V: &core.ExecAction{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ExecAction) Underlying() interface{} { return t.V }
func (t ExecAction) DeepCopy() boxed         { return ExecAction{V: t.V.DeepCopy()} }
func (t ExecAction) Package() util.Package   { return util.Core }
func (t ExecAction) Type() string            { return "k8s_core_ExecAction" }
func (t ExecAction) String() string          { return t.V.String() }
func (t ExecAction) Freeze()                 {} // TODO
func (t ExecAction) Truth() skylark.Bool     { return skylark.True }
func (t ExecAction) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ExecAction) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ExecAction)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ExecAction) AttrNames() []string { return ExecAction_attrs }
func (t ExecAction) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ExecAction_fields, ExecAction_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ExecAction) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ExecAction_fields, ExecAction_inline)
}

type FCVolumeSource struct {
	V *core.FCVolumeSource
}

var (
	_ boxed = (*FCVolumeSource)(nil)

	FCVolumeSource_fields = map[string]util.FieldSpec{}
	FCVolumeSource_inline = map[string]util.FieldSpec{}
	FCVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.FCVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.FCVolumeSource:
			return FCVolumeSource{V: v}
		case core.FCVolumeSource:
			return FCVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	FCVolumeSource_attrs = setFieldTypes(t, FCVolumeSource_fields, FCVolumeSource_inline)
	Library["FCVolumeSource"] = skylark.NewBuiltin("FCVolumeSource", createFCVolumeSource)
}

func createFCVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := FCVolumeSource{V: &core.FCVolumeSource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t FCVolumeSource) Underlying() interface{} { return t.V }
func (t FCVolumeSource) DeepCopy() boxed         { return FCVolumeSource{V: t.V.DeepCopy()} }
func (t FCVolumeSource) Package() util.Package   { return util.Core }
func (t FCVolumeSource) Type() string            { return "k8s_core_FCVolumeSource" }
func (t FCVolumeSource) String() string          { return t.V.String() }
func (t FCVolumeSource) Freeze()                 {} // TODO
func (t FCVolumeSource) Truth() skylark.Bool     { return skylark.True }
func (t FCVolumeSource) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t FCVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*FCVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t FCVolumeSource) AttrNames() []string { return FCVolumeSource_attrs }
func (t FCVolumeSource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, FCVolumeSource_fields, FCVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t FCVolumeSource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, FCVolumeSource_fields, FCVolumeSource_inline)
}

type FlexPersistentVolumeSource struct {
	V *core.FlexPersistentVolumeSource
}

var (
	_ boxed = (*FlexPersistentVolumeSource)(nil)

	FlexPersistentVolumeSource_fields = map[string]util.FieldSpec{}
	FlexPersistentVolumeSource_inline = map[string]util.FieldSpec{}
	FlexPersistentVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.FlexPersistentVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.FlexPersistentVolumeSource:
			return FlexPersistentVolumeSource{V: v}
		case core.FlexPersistentVolumeSource:
			return FlexPersistentVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	FlexPersistentVolumeSource_attrs = setFieldTypes(t, FlexPersistentVolumeSource_fields, FlexPersistentVolumeSource_inline)
	Library["FlexPersistentVolumeSource"] = skylark.NewBuiltin("FlexPersistentVolumeSource", createFlexPersistentVolumeSource)
}

func createFlexPersistentVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := FlexPersistentVolumeSource{V: &core.FlexPersistentVolumeSource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t FlexPersistentVolumeSource) Underlying() interface{} { return t.V }
func (t FlexPersistentVolumeSource) DeepCopy() boxed {
	return FlexPersistentVolumeSource{V: t.V.DeepCopy()}
}
func (t FlexPersistentVolumeSource) Package() util.Package { return util.Core }
func (t FlexPersistentVolumeSource) Type() string          { return "k8s_core_FlexPersistentVolumeSource" }
func (t FlexPersistentVolumeSource) String() string        { return t.V.String() }
func (t FlexPersistentVolumeSource) Freeze()               {} // TODO
func (t FlexPersistentVolumeSource) Truth() skylark.Bool   { return skylark.True }
func (t FlexPersistentVolumeSource) Hash() (uint32, error) { return 0, unhashable(t.Type()) }
func (t FlexPersistentVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*FlexPersistentVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t FlexPersistentVolumeSource) AttrNames() []string { return FlexPersistentVolumeSource_attrs }
func (t FlexPersistentVolumeSource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, FlexPersistentVolumeSource_fields, FlexPersistentVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t FlexPersistentVolumeSource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, FlexPersistentVolumeSource_fields, FlexPersistentVolumeSource_inline)
}

type FlexVolumeSource struct {
	V *core.FlexVolumeSource
}

var (
	_ boxed = (*FlexVolumeSource)(nil)

	FlexVolumeSource_fields = map[string]util.FieldSpec{}
	FlexVolumeSource_inline = map[string]util.FieldSpec{}
	FlexVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.FlexVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.FlexVolumeSource:
			return FlexVolumeSource{V: v}
		case core.FlexVolumeSource:
			return FlexVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	FlexVolumeSource_attrs = setFieldTypes(t, FlexVolumeSource_fields, FlexVolumeSource_inline)
	Library["FlexVolumeSource"] = skylark.NewBuiltin("FlexVolumeSource", createFlexVolumeSource)
}

func createFlexVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := FlexVolumeSource{V: &core.FlexVolumeSource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t FlexVolumeSource) Underlying() interface{} { return t.V }
func (t FlexVolumeSource) DeepCopy() boxed         { return FlexVolumeSource{V: t.V.DeepCopy()} }
func (t FlexVolumeSource) Package() util.Package   { return util.Core }
func (t FlexVolumeSource) Type() string            { return "k8s_core_FlexVolumeSource" }
func (t FlexVolumeSource) String() string          { return t.V.String() }
func (t FlexVolumeSource) Freeze()                 {} // TODO
func (t FlexVolumeSource) Truth() skylark.Bool     { return skylark.True }
func (t FlexVolumeSource) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t FlexVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*FlexVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t FlexVolumeSource) AttrNames() []string { return FlexVolumeSource_attrs }
func (t FlexVolumeSource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, FlexVolumeSource_fields, FlexVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t FlexVolumeSource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, FlexVolumeSource_fields, FlexVolumeSource_inline)
}

type FlockerVolumeSource struct {
	V *core.FlockerVolumeSource
}

var (
	_ boxed = (*FlockerVolumeSource)(nil)

	FlockerVolumeSource_fields = map[string]util.FieldSpec{}
	FlockerVolumeSource_inline = map[string]util.FieldSpec{}
	FlockerVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.FlockerVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.FlockerVolumeSource:
			return FlockerVolumeSource{V: v}
		case core.FlockerVolumeSource:
			return FlockerVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	FlockerVolumeSource_attrs = setFieldTypes(t, FlockerVolumeSource_fields, FlockerVolumeSource_inline)
	Library["FlockerVolumeSource"] = skylark.NewBuiltin("FlockerVolumeSource", createFlockerVolumeSource)
}

func createFlockerVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := FlockerVolumeSource{V: &core.FlockerVolumeSource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t FlockerVolumeSource) Underlying() interface{} { return t.V }
func (t FlockerVolumeSource) DeepCopy() boxed         { return FlockerVolumeSource{V: t.V.DeepCopy()} }
func (t FlockerVolumeSource) Package() util.Package   { return util.Core }
func (t FlockerVolumeSource) Type() string            { return "k8s_core_FlockerVolumeSource" }
func (t FlockerVolumeSource) String() string          { return t.V.String() }
func (t FlockerVolumeSource) Freeze()                 {} // TODO
func (t FlockerVolumeSource) Truth() skylark.Bool     { return skylark.True }
func (t FlockerVolumeSource) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t FlockerVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*FlockerVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t FlockerVolumeSource) AttrNames() []string { return FlockerVolumeSource_attrs }
func (t FlockerVolumeSource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, FlockerVolumeSource_fields, FlockerVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t FlockerVolumeSource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, FlockerVolumeSource_fields, FlockerVolumeSource_inline)
}

type GCEPersistentDiskVolumeSource struct {
	V *core.GCEPersistentDiskVolumeSource
}

var (
	_ boxed = (*GCEPersistentDiskVolumeSource)(nil)

	GCEPersistentDiskVolumeSource_fields = map[string]util.FieldSpec{}
	GCEPersistentDiskVolumeSource_inline = map[string]util.FieldSpec{}
	GCEPersistentDiskVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.GCEPersistentDiskVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.GCEPersistentDiskVolumeSource:
			return GCEPersistentDiskVolumeSource{V: v}
		case core.GCEPersistentDiskVolumeSource:
			return GCEPersistentDiskVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	GCEPersistentDiskVolumeSource_attrs = setFieldTypes(t, GCEPersistentDiskVolumeSource_fields, GCEPersistentDiskVolumeSource_inline)
	Library["GCEPersistentDiskVolumeSource"] = skylark.NewBuiltin("GCEPersistentDiskVolumeSource", createGCEPersistentDiskVolumeSource)
}

func createGCEPersistentDiskVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := GCEPersistentDiskVolumeSource{V: &core.GCEPersistentDiskVolumeSource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t GCEPersistentDiskVolumeSource) Underlying() interface{} { return t.V }
func (t GCEPersistentDiskVolumeSource) DeepCopy() boxed {
	return GCEPersistentDiskVolumeSource{V: t.V.DeepCopy()}
}
func (t GCEPersistentDiskVolumeSource) Package() util.Package { return util.Core }
func (t GCEPersistentDiskVolumeSource) Type() string          { return "k8s_core_GCEPersistentDiskVolumeSource" }
func (t GCEPersistentDiskVolumeSource) String() string        { return t.V.String() }
func (t GCEPersistentDiskVolumeSource) Freeze()               {} // TODO
func (t GCEPersistentDiskVolumeSource) Truth() skylark.Bool   { return skylark.True }
func (t GCEPersistentDiskVolumeSource) Hash() (uint32, error) { return 0, unhashable(t.Type()) }
func (t GCEPersistentDiskVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*GCEPersistentDiskVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t GCEPersistentDiskVolumeSource) AttrNames() []string {
	return GCEPersistentDiskVolumeSource_attrs
}
func (t GCEPersistentDiskVolumeSource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, GCEPersistentDiskVolumeSource_fields, GCEPersistentDiskVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t GCEPersistentDiskVolumeSource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, GCEPersistentDiskVolumeSource_fields, GCEPersistentDiskVolumeSource_inline)
}

type GitRepoVolumeSource struct {
	V *core.GitRepoVolumeSource
}

var (
	_ boxed = (*GitRepoVolumeSource)(nil)

	GitRepoVolumeSource_fields = map[string]util.FieldSpec{}
	GitRepoVolumeSource_inline = map[string]util.FieldSpec{}
	GitRepoVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.GitRepoVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.GitRepoVolumeSource:
			return GitRepoVolumeSource{V: v}
		case core.GitRepoVolumeSource:
			return GitRepoVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	GitRepoVolumeSource_attrs = setFieldTypes(t, GitRepoVolumeSource_fields, GitRepoVolumeSource_inline)
	Library["GitRepoVolumeSource"] = skylark.NewBuiltin("GitRepoVolumeSource", createGitRepoVolumeSource)
}

func createGitRepoVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := GitRepoVolumeSource{V: &core.GitRepoVolumeSource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t GitRepoVolumeSource) Underlying() interface{} { return t.V }
func (t GitRepoVolumeSource) DeepCopy() boxed         { return GitRepoVolumeSource{V: t.V.DeepCopy()} }
func (t GitRepoVolumeSource) Package() util.Package   { return util.Core }
func (t GitRepoVolumeSource) Type() string            { return "k8s_core_GitRepoVolumeSource" }
func (t GitRepoVolumeSource) String() string          { return t.V.String() }
func (t GitRepoVolumeSource) Freeze()                 {} // TODO
func (t GitRepoVolumeSource) Truth() skylark.Bool     { return skylark.True }
func (t GitRepoVolumeSource) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t GitRepoVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*GitRepoVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t GitRepoVolumeSource) AttrNames() []string { return GitRepoVolumeSource_attrs }
func (t GitRepoVolumeSource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, GitRepoVolumeSource_fields, GitRepoVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t GitRepoVolumeSource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, GitRepoVolumeSource_fields, GitRepoVolumeSource_inline)
}

type GlusterfsVolumeSource struct {
	V *core.GlusterfsVolumeSource
}

var (
	_ boxed = (*GlusterfsVolumeSource)(nil)

	GlusterfsVolumeSource_fields = map[string]util.FieldSpec{}
	GlusterfsVolumeSource_inline = map[string]util.FieldSpec{}
	GlusterfsVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.GlusterfsVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.GlusterfsVolumeSource:
			return GlusterfsVolumeSource{V: v}
		case core.GlusterfsVolumeSource:
			return GlusterfsVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	GlusterfsVolumeSource_attrs = setFieldTypes(t, GlusterfsVolumeSource_fields, GlusterfsVolumeSource_inline)
	Library["GlusterfsVolumeSource"] = skylark.NewBuiltin("GlusterfsVolumeSource", createGlusterfsVolumeSource)
}

func createGlusterfsVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := GlusterfsVolumeSource{V: &core.GlusterfsVolumeSource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t GlusterfsVolumeSource) Underlying() interface{} { return t.V }
func (t GlusterfsVolumeSource) DeepCopy() boxed         { return GlusterfsVolumeSource{V: t.V.DeepCopy()} }
func (t GlusterfsVolumeSource) Package() util.Package   { return util.Core }
func (t GlusterfsVolumeSource) Type() string            { return "k8s_core_GlusterfsVolumeSource" }
func (t GlusterfsVolumeSource) String() string          { return t.V.String() }
func (t GlusterfsVolumeSource) Freeze()                 {} // TODO
func (t GlusterfsVolumeSource) Truth() skylark.Bool     { return skylark.True }
func (t GlusterfsVolumeSource) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t GlusterfsVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*GlusterfsVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t GlusterfsVolumeSource) AttrNames() []string { return GlusterfsVolumeSource_attrs }
func (t GlusterfsVolumeSource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, GlusterfsVolumeSource_fields, GlusterfsVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t GlusterfsVolumeSource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, GlusterfsVolumeSource_fields, GlusterfsVolumeSource_inline)
}

type HTTPGetAction struct {
	V *core.HTTPGetAction
}

var (
	_ boxed = (*HTTPGetAction)(nil)

	HTTPGetAction_fields = map[string]util.FieldSpec{}
	HTTPGetAction_inline = map[string]util.FieldSpec{}
	HTTPGetAction_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.HTTPGetAction)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.HTTPGetAction:
			return HTTPGetAction{V: v}
		case core.HTTPGetAction:
			return HTTPGetAction{V: &v}
		default:
			return skylark.None
		}
	}
	HTTPGetAction_attrs = setFieldTypes(t, HTTPGetAction_fields, HTTPGetAction_inline)
	Library["HTTPGetAction"] = skylark.NewBuiltin("HTTPGetAction", createHTTPGetAction)
}

func createHTTPGetAction(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := HTTPGetAction{V: &core.HTTPGetAction{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t HTTPGetAction) Underlying() interface{} { return t.V }
func (t HTTPGetAction) DeepCopy() boxed         { return HTTPGetAction{V: t.V.DeepCopy()} }
func (t HTTPGetAction) Package() util.Package   { return util.Core }
func (t HTTPGetAction) Type() string            { return "k8s_core_HTTPGetAction" }
func (t HTTPGetAction) String() string          { return t.V.String() }
func (t HTTPGetAction) Freeze()                 {} // TODO
func (t HTTPGetAction) Truth() skylark.Bool     { return skylark.True }
func (t HTTPGetAction) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t HTTPGetAction) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*HTTPGetAction)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t HTTPGetAction) AttrNames() []string { return HTTPGetAction_attrs }
func (t HTTPGetAction) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, HTTPGetAction_fields, HTTPGetAction_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t HTTPGetAction) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, HTTPGetAction_fields, HTTPGetAction_inline)
}

type HTTPHeader struct {
	V *core.HTTPHeader
}

var (
	_ boxed = (*HTTPHeader)(nil)

	HTTPHeader_fields = map[string]util.FieldSpec{}
	HTTPHeader_inline = map[string]util.FieldSpec{}
	HTTPHeader_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.HTTPHeader)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.HTTPHeader:
			return HTTPHeader{V: v}
		case core.HTTPHeader:
			return HTTPHeader{V: &v}
		default:
			return skylark.None
		}
	}
	HTTPHeader_attrs = setFieldTypes(t, HTTPHeader_fields, HTTPHeader_inline)
	Library["HTTPHeader"] = skylark.NewBuiltin("HTTPHeader", createHTTPHeader)
}

func createHTTPHeader(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := HTTPHeader{V: &core.HTTPHeader{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t HTTPHeader) Underlying() interface{} { return t.V }
func (t HTTPHeader) DeepCopy() boxed         { return HTTPHeader{V: t.V.DeepCopy()} }
func (t HTTPHeader) Package() util.Package   { return util.Core }
func (t HTTPHeader) Type() string            { return "k8s_core_HTTPHeader" }
func (t HTTPHeader) String() string          { return t.V.String() }
func (t HTTPHeader) Freeze()                 {} // TODO
func (t HTTPHeader) Truth() skylark.Bool     { return skylark.True }
func (t HTTPHeader) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t HTTPHeader) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*HTTPHeader)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t HTTPHeader) AttrNames() []string { return HTTPHeader_attrs }
func (t HTTPHeader) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, HTTPHeader_fields, HTTPHeader_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t HTTPHeader) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, HTTPHeader_fields, HTTPHeader_inline)
}

type Handler struct {
	V *core.Handler
}

var (
	_ boxed = (*Handler)(nil)

	Handler_fields = map[string]util.FieldSpec{}
	Handler_inline = map[string]util.FieldSpec{}
	Handler_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.Handler)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.Handler:
			return Handler{V: v}
		case core.Handler:
			return Handler{V: &v}
		default:
			return skylark.None
		}
	}
	Handler_attrs = setFieldTypes(t, Handler_fields, Handler_inline)
	Library["Handler"] = skylark.NewBuiltin("Handler", createHandler)
}

func createHandler(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := Handler{V: &core.Handler{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t Handler) Underlying() interface{} { return t.V }
func (t Handler) DeepCopy() boxed         { return Handler{V: t.V.DeepCopy()} }
func (t Handler) Package() util.Package   { return util.Core }
func (t Handler) Type() string            { return "k8s_core_Handler" }
func (t Handler) String() string          { return t.V.String() }
func (t Handler) Freeze()                 {} // TODO
func (t Handler) Truth() skylark.Bool     { return skylark.True }
func (t Handler) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t Handler) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*Handler)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t Handler) AttrNames() []string { return Handler_attrs }
func (t Handler) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, Handler_fields, Handler_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t Handler) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, Handler_fields, Handler_inline)
}

type HostAlias struct {
	V *core.HostAlias
}

var (
	_ boxed = (*HostAlias)(nil)

	HostAlias_fields = map[string]util.FieldSpec{}
	HostAlias_inline = map[string]util.FieldSpec{}
	HostAlias_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.HostAlias)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.HostAlias:
			return HostAlias{V: v}
		case core.HostAlias:
			return HostAlias{V: &v}
		default:
			return skylark.None
		}
	}
	HostAlias_attrs = setFieldTypes(t, HostAlias_fields, HostAlias_inline)
	Library["HostAlias"] = skylark.NewBuiltin("HostAlias", createHostAlias)
}

func createHostAlias(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := HostAlias{V: &core.HostAlias{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t HostAlias) Underlying() interface{} { return t.V }
func (t HostAlias) DeepCopy() boxed         { return HostAlias{V: t.V.DeepCopy()} }
func (t HostAlias) Package() util.Package   { return util.Core }
func (t HostAlias) Type() string            { return "k8s_core_HostAlias" }
func (t HostAlias) String() string          { return t.V.String() }
func (t HostAlias) Freeze()                 {} // TODO
func (t HostAlias) Truth() skylark.Bool     { return skylark.True }
func (t HostAlias) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t HostAlias) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*HostAlias)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t HostAlias) AttrNames() []string { return HostAlias_attrs }
func (t HostAlias) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, HostAlias_fields, HostAlias_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t HostAlias) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, HostAlias_fields, HostAlias_inline)
}

type HostPathVolumeSource struct {
	V *core.HostPathVolumeSource
}

var (
	_ boxed = (*HostPathVolumeSource)(nil)

	HostPathVolumeSource_fields = map[string]util.FieldSpec{}
	HostPathVolumeSource_inline = map[string]util.FieldSpec{}
	HostPathVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.HostPathVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.HostPathVolumeSource:
			return HostPathVolumeSource{V: v}
		case core.HostPathVolumeSource:
			return HostPathVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	HostPathVolumeSource_attrs = setFieldTypes(t, HostPathVolumeSource_fields, HostPathVolumeSource_inline)
	Library["HostPathVolumeSource"] = skylark.NewBuiltin("HostPathVolumeSource", createHostPathVolumeSource)
}

func createHostPathVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := HostPathVolumeSource{V: &core.HostPathVolumeSource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t HostPathVolumeSource) Underlying() interface{} { return t.V }
func (t HostPathVolumeSource) DeepCopy() boxed         { return HostPathVolumeSource{V: t.V.DeepCopy()} }
func (t HostPathVolumeSource) Package() util.Package   { return util.Core }
func (t HostPathVolumeSource) Type() string            { return "k8s_core_HostPathVolumeSource" }
func (t HostPathVolumeSource) String() string          { return t.V.String() }
func (t HostPathVolumeSource) Freeze()                 {} // TODO
func (t HostPathVolumeSource) Truth() skylark.Bool     { return skylark.True }
func (t HostPathVolumeSource) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t HostPathVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*HostPathVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t HostPathVolumeSource) AttrNames() []string { return HostPathVolumeSource_attrs }
func (t HostPathVolumeSource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, HostPathVolumeSource_fields, HostPathVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t HostPathVolumeSource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, HostPathVolumeSource_fields, HostPathVolumeSource_inline)
}

type ISCSIPersistentVolumeSource struct {
	V *core.ISCSIPersistentVolumeSource
}

var (
	_ boxed = (*ISCSIPersistentVolumeSource)(nil)

	ISCSIPersistentVolumeSource_fields = map[string]util.FieldSpec{}
	ISCSIPersistentVolumeSource_inline = map[string]util.FieldSpec{}
	ISCSIPersistentVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.ISCSIPersistentVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.ISCSIPersistentVolumeSource:
			return ISCSIPersistentVolumeSource{V: v}
		case core.ISCSIPersistentVolumeSource:
			return ISCSIPersistentVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	ISCSIPersistentVolumeSource_attrs = setFieldTypes(t, ISCSIPersistentVolumeSource_fields, ISCSIPersistentVolumeSource_inline)
	Library["ISCSIPersistentVolumeSource"] = skylark.NewBuiltin("ISCSIPersistentVolumeSource", createISCSIPersistentVolumeSource)
}

func createISCSIPersistentVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ISCSIPersistentVolumeSource{V: &core.ISCSIPersistentVolumeSource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ISCSIPersistentVolumeSource) Underlying() interface{} { return t.V }
func (t ISCSIPersistentVolumeSource) DeepCopy() boxed {
	return ISCSIPersistentVolumeSource{V: t.V.DeepCopy()}
}
func (t ISCSIPersistentVolumeSource) Package() util.Package { return util.Core }
func (t ISCSIPersistentVolumeSource) Type() string          { return "k8s_core_ISCSIPersistentVolumeSource" }
func (t ISCSIPersistentVolumeSource) String() string        { return t.V.String() }
func (t ISCSIPersistentVolumeSource) Freeze()               {} // TODO
func (t ISCSIPersistentVolumeSource) Truth() skylark.Bool   { return skylark.True }
func (t ISCSIPersistentVolumeSource) Hash() (uint32, error) { return 0, unhashable(t.Type()) }
func (t ISCSIPersistentVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ISCSIPersistentVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ISCSIPersistentVolumeSource) AttrNames() []string { return ISCSIPersistentVolumeSource_attrs }
func (t ISCSIPersistentVolumeSource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ISCSIPersistentVolumeSource_fields, ISCSIPersistentVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ISCSIPersistentVolumeSource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ISCSIPersistentVolumeSource_fields, ISCSIPersistentVolumeSource_inline)
}

type ISCSIVolumeSource struct {
	V *core.ISCSIVolumeSource
}

var (
	_ boxed = (*ISCSIVolumeSource)(nil)

	ISCSIVolumeSource_fields = map[string]util.FieldSpec{}
	ISCSIVolumeSource_inline = map[string]util.FieldSpec{}
	ISCSIVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.ISCSIVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.ISCSIVolumeSource:
			return ISCSIVolumeSource{V: v}
		case core.ISCSIVolumeSource:
			return ISCSIVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	ISCSIVolumeSource_attrs = setFieldTypes(t, ISCSIVolumeSource_fields, ISCSIVolumeSource_inline)
	Library["ISCSIVolumeSource"] = skylark.NewBuiltin("ISCSIVolumeSource", createISCSIVolumeSource)
}

func createISCSIVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ISCSIVolumeSource{V: &core.ISCSIVolumeSource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ISCSIVolumeSource) Underlying() interface{} { return t.V }
func (t ISCSIVolumeSource) DeepCopy() boxed         { return ISCSIVolumeSource{V: t.V.DeepCopy()} }
func (t ISCSIVolumeSource) Package() util.Package   { return util.Core }
func (t ISCSIVolumeSource) Type() string            { return "k8s_core_ISCSIVolumeSource" }
func (t ISCSIVolumeSource) String() string          { return t.V.String() }
func (t ISCSIVolumeSource) Freeze()                 {} // TODO
func (t ISCSIVolumeSource) Truth() skylark.Bool     { return skylark.True }
func (t ISCSIVolumeSource) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ISCSIVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ISCSIVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ISCSIVolumeSource) AttrNames() []string { return ISCSIVolumeSource_attrs }
func (t ISCSIVolumeSource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ISCSIVolumeSource_fields, ISCSIVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ISCSIVolumeSource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ISCSIVolumeSource_fields, ISCSIVolumeSource_inline)
}

type KeyToPath struct {
	V *core.KeyToPath
}

var (
	_ boxed = (*KeyToPath)(nil)

	KeyToPath_fields = map[string]util.FieldSpec{}
	KeyToPath_inline = map[string]util.FieldSpec{}
	KeyToPath_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.KeyToPath)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.KeyToPath:
			return KeyToPath{V: v}
		case core.KeyToPath:
			return KeyToPath{V: &v}
		default:
			return skylark.None
		}
	}
	KeyToPath_attrs = setFieldTypes(t, KeyToPath_fields, KeyToPath_inline)
	Library["KeyToPath"] = skylark.NewBuiltin("KeyToPath", createKeyToPath)
}

func createKeyToPath(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := KeyToPath{V: &core.KeyToPath{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t KeyToPath) Underlying() interface{} { return t.V }
func (t KeyToPath) DeepCopy() boxed         { return KeyToPath{V: t.V.DeepCopy()} }
func (t KeyToPath) Package() util.Package   { return util.Core }
func (t KeyToPath) Type() string            { return "k8s_core_KeyToPath" }
func (t KeyToPath) String() string          { return t.V.String() }
func (t KeyToPath) Freeze()                 {} // TODO
func (t KeyToPath) Truth() skylark.Bool     { return skylark.True }
func (t KeyToPath) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t KeyToPath) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*KeyToPath)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t KeyToPath) AttrNames() []string { return KeyToPath_attrs }
func (t KeyToPath) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, KeyToPath_fields, KeyToPath_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t KeyToPath) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, KeyToPath_fields, KeyToPath_inline)
}

type Lifecycle struct {
	V *core.Lifecycle
}

var (
	_ boxed = (*Lifecycle)(nil)

	Lifecycle_fields = map[string]util.FieldSpec{}
	Lifecycle_inline = map[string]util.FieldSpec{}
	Lifecycle_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.Lifecycle)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.Lifecycle:
			return Lifecycle{V: v}
		case core.Lifecycle:
			return Lifecycle{V: &v}
		default:
			return skylark.None
		}
	}
	Lifecycle_attrs = setFieldTypes(t, Lifecycle_fields, Lifecycle_inline)
	Library["Lifecycle"] = skylark.NewBuiltin("Lifecycle", createLifecycle)
}

func createLifecycle(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := Lifecycle{V: &core.Lifecycle{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t Lifecycle) Underlying() interface{} { return t.V }
func (t Lifecycle) DeepCopy() boxed         { return Lifecycle{V: t.V.DeepCopy()} }
func (t Lifecycle) Package() util.Package   { return util.Core }
func (t Lifecycle) Type() string            { return "k8s_core_Lifecycle" }
func (t Lifecycle) String() string          { return t.V.String() }
func (t Lifecycle) Freeze()                 {} // TODO
func (t Lifecycle) Truth() skylark.Bool     { return skylark.True }
func (t Lifecycle) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t Lifecycle) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*Lifecycle)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t Lifecycle) AttrNames() []string { return Lifecycle_attrs }
func (t Lifecycle) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, Lifecycle_fields, Lifecycle_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t Lifecycle) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, Lifecycle_fields, Lifecycle_inline)
}

type LimitRange struct {
	V *core.LimitRange
}

var (
	_ boxed = (*LimitRange)(nil)

	LimitRange_fields = map[string]util.FieldSpec{}
	LimitRange_inline = map[string]util.FieldSpec{}
	LimitRange_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.LimitRange)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.LimitRange:
			return LimitRange{V: v}
		case core.LimitRange:
			return LimitRange{V: &v}
		default:
			return skylark.None
		}
	}
	LimitRange_attrs = setFieldTypes(t, LimitRange_fields, LimitRange_inline)
	Library["LimitRange"] = skylark.NewBuiltin("LimitRange", createLimitRange)
}

func createLimitRange(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := LimitRange{V: &core.LimitRange{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t LimitRange) Underlying() interface{} { return t.V }
func (t LimitRange) DeepCopy() boxed         { return LimitRange{V: t.V.DeepCopy()} }
func (t LimitRange) Package() util.Package   { return util.Core }
func (t LimitRange) Type() string            { return "k8s_core_LimitRange" }
func (t LimitRange) String() string          { return t.V.String() }
func (t LimitRange) Freeze()                 {} // TODO
func (t LimitRange) Truth() skylark.Bool     { return skylark.True }
func (t LimitRange) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t LimitRange) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*LimitRange)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t LimitRange) AttrNames() []string { return LimitRange_attrs }
func (t LimitRange) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, LimitRange_fields, LimitRange_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t LimitRange) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, LimitRange_fields, LimitRange_inline)
}

type LimitRangeItem struct {
	V *core.LimitRangeItem
}

var (
	_ boxed = (*LimitRangeItem)(nil)

	LimitRangeItem_fields = map[string]util.FieldSpec{}
	LimitRangeItem_inline = map[string]util.FieldSpec{}
	LimitRangeItem_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.LimitRangeItem)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.LimitRangeItem:
			return LimitRangeItem{V: v}
		case core.LimitRangeItem:
			return LimitRangeItem{V: &v}
		default:
			return skylark.None
		}
	}
	LimitRangeItem_attrs = setFieldTypes(t, LimitRangeItem_fields, LimitRangeItem_inline)
	Library["LimitRangeItem"] = skylark.NewBuiltin("LimitRangeItem", createLimitRangeItem)
}

func createLimitRangeItem(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := LimitRangeItem{V: &core.LimitRangeItem{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t LimitRangeItem) Underlying() interface{} { return t.V }
func (t LimitRangeItem) DeepCopy() boxed         { return LimitRangeItem{V: t.V.DeepCopy()} }
func (t LimitRangeItem) Package() util.Package   { return util.Core }
func (t LimitRangeItem) Type() string            { return "k8s_core_LimitRangeItem" }
func (t LimitRangeItem) String() string          { return t.V.String() }
func (t LimitRangeItem) Freeze()                 {} // TODO
func (t LimitRangeItem) Truth() skylark.Bool     { return skylark.True }
func (t LimitRangeItem) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t LimitRangeItem) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*LimitRangeItem)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t LimitRangeItem) AttrNames() []string { return LimitRangeItem_attrs }
func (t LimitRangeItem) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, LimitRangeItem_fields, LimitRangeItem_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t LimitRangeItem) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, LimitRangeItem_fields, LimitRangeItem_inline)
}

type LimitRangeList struct {
	V *core.LimitRangeList
}

var (
	_ boxed = (*LimitRangeList)(nil)

	LimitRangeList_fields = map[string]util.FieldSpec{}
	LimitRangeList_inline = map[string]util.FieldSpec{}
	LimitRangeList_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.LimitRangeList)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.LimitRangeList:
			return LimitRangeList{V: v}
		case core.LimitRangeList:
			return LimitRangeList{V: &v}
		default:
			return skylark.None
		}
	}
	LimitRangeList_attrs = setFieldTypes(t, LimitRangeList_fields, LimitRangeList_inline)
	Library["LimitRangeList"] = skylark.NewBuiltin("LimitRangeList", createLimitRangeList)
}

func createLimitRangeList(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := LimitRangeList{V: &core.LimitRangeList{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t LimitRangeList) Underlying() interface{} { return t.V }
func (t LimitRangeList) DeepCopy() boxed         { return LimitRangeList{V: t.V.DeepCopy()} }
func (t LimitRangeList) Package() util.Package   { return util.Core }
func (t LimitRangeList) Type() string            { return "k8s_core_LimitRangeList" }
func (t LimitRangeList) String() string          { return t.V.String() }
func (t LimitRangeList) Freeze()                 {} // TODO
func (t LimitRangeList) Truth() skylark.Bool     { return skylark.True }
func (t LimitRangeList) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t LimitRangeList) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*LimitRangeList)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t LimitRangeList) AttrNames() []string { return LimitRangeList_attrs }
func (t LimitRangeList) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, LimitRangeList_fields, LimitRangeList_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t LimitRangeList) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, LimitRangeList_fields, LimitRangeList_inline)
}

type LimitRangeSpec struct {
	V *core.LimitRangeSpec
}

var (
	_ boxed = (*LimitRangeSpec)(nil)

	LimitRangeSpec_fields = map[string]util.FieldSpec{}
	LimitRangeSpec_inline = map[string]util.FieldSpec{}
	LimitRangeSpec_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.LimitRangeSpec)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.LimitRangeSpec:
			return LimitRangeSpec{V: v}
		case core.LimitRangeSpec:
			return LimitRangeSpec{V: &v}
		default:
			return skylark.None
		}
	}
	LimitRangeSpec_attrs = setFieldTypes(t, LimitRangeSpec_fields, LimitRangeSpec_inline)
	Library["LimitRangeSpec"] = skylark.NewBuiltin("LimitRangeSpec", createLimitRangeSpec)
}

func createLimitRangeSpec(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := LimitRangeSpec{V: &core.LimitRangeSpec{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t LimitRangeSpec) Underlying() interface{} { return t.V }
func (t LimitRangeSpec) DeepCopy() boxed         { return LimitRangeSpec{V: t.V.DeepCopy()} }
func (t LimitRangeSpec) Package() util.Package   { return util.Core }
func (t LimitRangeSpec) Type() string            { return "k8s_core_LimitRangeSpec" }
func (t LimitRangeSpec) String() string          { return t.V.String() }
func (t LimitRangeSpec) Freeze()                 {} // TODO
func (t LimitRangeSpec) Truth() skylark.Bool     { return skylark.True }
func (t LimitRangeSpec) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t LimitRangeSpec) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*LimitRangeSpec)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t LimitRangeSpec) AttrNames() []string { return LimitRangeSpec_attrs }
func (t LimitRangeSpec) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, LimitRangeSpec_fields, LimitRangeSpec_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t LimitRangeSpec) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, LimitRangeSpec_fields, LimitRangeSpec_inline)
}

type List struct {
	V *core.List
}

var (
	_ boxed = (*List)(nil)

	List_fields = map[string]util.FieldSpec{}
	List_inline = map[string]util.FieldSpec{}
	List_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.List)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.List:
			return List{V: v}
		case core.List:
			return List{V: &v}
		default:
			return skylark.None
		}
	}
	List_attrs = setFieldTypes(t, List_fields, List_inline)
	Library["List"] = skylark.NewBuiltin("List", createList)
}

func createList(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := List{V: &core.List{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t List) Underlying() interface{} { return t.V }
func (t List) DeepCopy() boxed         { return List{V: t.V.DeepCopy()} }
func (t List) Package() util.Package   { return util.Core }
func (t List) Type() string            { return "k8s_core_List" }
func (t List) String() string          { return t.V.String() }
func (t List) Freeze()                 {} // TODO
func (t List) Truth() skylark.Bool     { return skylark.True }
func (t List) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t List) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*List)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t List) AttrNames() []string { return List_attrs }
func (t List) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, List_fields, List_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t List) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, List_fields, List_inline)
}

type LoadBalancerIngress struct {
	V *core.LoadBalancerIngress
}

var (
	_ boxed = (*LoadBalancerIngress)(nil)

	LoadBalancerIngress_fields = map[string]util.FieldSpec{}
	LoadBalancerIngress_inline = map[string]util.FieldSpec{}
	LoadBalancerIngress_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.LoadBalancerIngress)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.LoadBalancerIngress:
			return LoadBalancerIngress{V: v}
		case core.LoadBalancerIngress:
			return LoadBalancerIngress{V: &v}
		default:
			return skylark.None
		}
	}
	LoadBalancerIngress_attrs = setFieldTypes(t, LoadBalancerIngress_fields, LoadBalancerIngress_inline)
	Library["LoadBalancerIngress"] = skylark.NewBuiltin("LoadBalancerIngress", createLoadBalancerIngress)
}

func createLoadBalancerIngress(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := LoadBalancerIngress{V: &core.LoadBalancerIngress{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t LoadBalancerIngress) Underlying() interface{} { return t.V }
func (t LoadBalancerIngress) DeepCopy() boxed         { return LoadBalancerIngress{V: t.V.DeepCopy()} }
func (t LoadBalancerIngress) Package() util.Package   { return util.Core }
func (t LoadBalancerIngress) Type() string            { return "k8s_core_LoadBalancerIngress" }
func (t LoadBalancerIngress) String() string          { return t.V.String() }
func (t LoadBalancerIngress) Freeze()                 {} // TODO
func (t LoadBalancerIngress) Truth() skylark.Bool     { return skylark.True }
func (t LoadBalancerIngress) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t LoadBalancerIngress) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*LoadBalancerIngress)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t LoadBalancerIngress) AttrNames() []string { return LoadBalancerIngress_attrs }
func (t LoadBalancerIngress) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, LoadBalancerIngress_fields, LoadBalancerIngress_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t LoadBalancerIngress) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, LoadBalancerIngress_fields, LoadBalancerIngress_inline)
}

type LoadBalancerStatus struct {
	V *core.LoadBalancerStatus
}

var (
	_ boxed = (*LoadBalancerStatus)(nil)

	LoadBalancerStatus_fields = map[string]util.FieldSpec{}
	LoadBalancerStatus_inline = map[string]util.FieldSpec{}
	LoadBalancerStatus_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.LoadBalancerStatus)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.LoadBalancerStatus:
			return LoadBalancerStatus{V: v}
		case core.LoadBalancerStatus:
			return LoadBalancerStatus{V: &v}
		default:
			return skylark.None
		}
	}
	LoadBalancerStatus_attrs = setFieldTypes(t, LoadBalancerStatus_fields, LoadBalancerStatus_inline)
	Library["LoadBalancerStatus"] = skylark.NewBuiltin("LoadBalancerStatus", createLoadBalancerStatus)
}

func createLoadBalancerStatus(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := LoadBalancerStatus{V: &core.LoadBalancerStatus{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t LoadBalancerStatus) Underlying() interface{} { return t.V }
func (t LoadBalancerStatus) DeepCopy() boxed         { return LoadBalancerStatus{V: t.V.DeepCopy()} }
func (t LoadBalancerStatus) Package() util.Package   { return util.Core }
func (t LoadBalancerStatus) Type() string            { return "k8s_core_LoadBalancerStatus" }
func (t LoadBalancerStatus) String() string          { return t.V.String() }
func (t LoadBalancerStatus) Freeze()                 {} // TODO
func (t LoadBalancerStatus) Truth() skylark.Bool     { return skylark.True }
func (t LoadBalancerStatus) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t LoadBalancerStatus) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*LoadBalancerStatus)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t LoadBalancerStatus) AttrNames() []string { return LoadBalancerStatus_attrs }
func (t LoadBalancerStatus) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, LoadBalancerStatus_fields, LoadBalancerStatus_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t LoadBalancerStatus) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, LoadBalancerStatus_fields, LoadBalancerStatus_inline)
}

type LocalObjectReference struct {
	V *core.LocalObjectReference
}

var (
	_ boxed = (*LocalObjectReference)(nil)

	LocalObjectReference_fields = map[string]util.FieldSpec{}
	LocalObjectReference_inline = map[string]util.FieldSpec{}
	LocalObjectReference_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.LocalObjectReference)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.LocalObjectReference:
			return LocalObjectReference{V: v}
		case core.LocalObjectReference:
			return LocalObjectReference{V: &v}
		default:
			return skylark.None
		}
	}
	LocalObjectReference_attrs = setFieldTypes(t, LocalObjectReference_fields, LocalObjectReference_inline)
	Library["LocalObjectReference"] = skylark.NewBuiltin("LocalObjectReference", createLocalObjectReference)
}

func createLocalObjectReference(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := LocalObjectReference{V: &core.LocalObjectReference{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t LocalObjectReference) Underlying() interface{} { return t.V }
func (t LocalObjectReference) DeepCopy() boxed         { return LocalObjectReference{V: t.V.DeepCopy()} }
func (t LocalObjectReference) Package() util.Package   { return util.Core }
func (t LocalObjectReference) Type() string            { return "k8s_core_LocalObjectReference" }
func (t LocalObjectReference) String() string          { return t.V.String() }
func (t LocalObjectReference) Freeze()                 {} // TODO
func (t LocalObjectReference) Truth() skylark.Bool     { return skylark.True }
func (t LocalObjectReference) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t LocalObjectReference) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*LocalObjectReference)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t LocalObjectReference) AttrNames() []string { return LocalObjectReference_attrs }
func (t LocalObjectReference) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, LocalObjectReference_fields, LocalObjectReference_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t LocalObjectReference) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, LocalObjectReference_fields, LocalObjectReference_inline)
}

type LocalVolumeSource struct {
	V *core.LocalVolumeSource
}

var (
	_ boxed = (*LocalVolumeSource)(nil)

	LocalVolumeSource_fields = map[string]util.FieldSpec{}
	LocalVolumeSource_inline = map[string]util.FieldSpec{}
	LocalVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.LocalVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.LocalVolumeSource:
			return LocalVolumeSource{V: v}
		case core.LocalVolumeSource:
			return LocalVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	LocalVolumeSource_attrs = setFieldTypes(t, LocalVolumeSource_fields, LocalVolumeSource_inline)
	Library["LocalVolumeSource"] = skylark.NewBuiltin("LocalVolumeSource", createLocalVolumeSource)
}

func createLocalVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := LocalVolumeSource{V: &core.LocalVolumeSource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t LocalVolumeSource) Underlying() interface{} { return t.V }
func (t LocalVolumeSource) DeepCopy() boxed         { return LocalVolumeSource{V: t.V.DeepCopy()} }
func (t LocalVolumeSource) Package() util.Package   { return util.Core }
func (t LocalVolumeSource) Type() string            { return "k8s_core_LocalVolumeSource" }
func (t LocalVolumeSource) String() string          { return t.V.String() }
func (t LocalVolumeSource) Freeze()                 {} // TODO
func (t LocalVolumeSource) Truth() skylark.Bool     { return skylark.True }
func (t LocalVolumeSource) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t LocalVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*LocalVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t LocalVolumeSource) AttrNames() []string { return LocalVolumeSource_attrs }
func (t LocalVolumeSource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, LocalVolumeSource_fields, LocalVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t LocalVolumeSource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, LocalVolumeSource_fields, LocalVolumeSource_inline)
}

type NFSVolumeSource struct {
	V *core.NFSVolumeSource
}

var (
	_ boxed = (*NFSVolumeSource)(nil)

	NFSVolumeSource_fields = map[string]util.FieldSpec{}
	NFSVolumeSource_inline = map[string]util.FieldSpec{}
	NFSVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.NFSVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.NFSVolumeSource:
			return NFSVolumeSource{V: v}
		case core.NFSVolumeSource:
			return NFSVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	NFSVolumeSource_attrs = setFieldTypes(t, NFSVolumeSource_fields, NFSVolumeSource_inline)
	Library["NFSVolumeSource"] = skylark.NewBuiltin("NFSVolumeSource", createNFSVolumeSource)
}

func createNFSVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := NFSVolumeSource{V: &core.NFSVolumeSource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t NFSVolumeSource) Underlying() interface{} { return t.V }
func (t NFSVolumeSource) DeepCopy() boxed         { return NFSVolumeSource{V: t.V.DeepCopy()} }
func (t NFSVolumeSource) Package() util.Package   { return util.Core }
func (t NFSVolumeSource) Type() string            { return "k8s_core_NFSVolumeSource" }
func (t NFSVolumeSource) String() string          { return t.V.String() }
func (t NFSVolumeSource) Freeze()                 {} // TODO
func (t NFSVolumeSource) Truth() skylark.Bool     { return skylark.True }
func (t NFSVolumeSource) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t NFSVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*NFSVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t NFSVolumeSource) AttrNames() []string { return NFSVolumeSource_attrs }
func (t NFSVolumeSource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, NFSVolumeSource_fields, NFSVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t NFSVolumeSource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, NFSVolumeSource_fields, NFSVolumeSource_inline)
}

type Namespace struct {
	V *core.Namespace
}

var (
	_ boxed = (*Namespace)(nil)

	Namespace_fields = map[string]util.FieldSpec{}
	Namespace_inline = map[string]util.FieldSpec{}
	Namespace_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.Namespace)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.Namespace:
			return Namespace{V: v}
		case core.Namespace:
			return Namespace{V: &v}
		default:
			return skylark.None
		}
	}
	Namespace_attrs = setFieldTypes(t, Namespace_fields, Namespace_inline)
	Library["Namespace"] = skylark.NewBuiltin("Namespace", createNamespace)
}

func createNamespace(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := Namespace{V: &core.Namespace{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t Namespace) Underlying() interface{} { return t.V }
func (t Namespace) DeepCopy() boxed         { return Namespace{V: t.V.DeepCopy()} }
func (t Namespace) Package() util.Package   { return util.Core }
func (t Namespace) Type() string            { return "k8s_core_Namespace" }
func (t Namespace) String() string          { return t.V.String() }
func (t Namespace) Freeze()                 {} // TODO
func (t Namespace) Truth() skylark.Bool     { return skylark.True }
func (t Namespace) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t Namespace) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*Namespace)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t Namespace) AttrNames() []string { return Namespace_attrs }
func (t Namespace) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, Namespace_fields, Namespace_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t Namespace) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, Namespace_fields, Namespace_inline)
}

type NamespaceList struct {
	V *core.NamespaceList
}

var (
	_ boxed = (*NamespaceList)(nil)

	NamespaceList_fields = map[string]util.FieldSpec{}
	NamespaceList_inline = map[string]util.FieldSpec{}
	NamespaceList_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.NamespaceList)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.NamespaceList:
			return NamespaceList{V: v}
		case core.NamespaceList:
			return NamespaceList{V: &v}
		default:
			return skylark.None
		}
	}
	NamespaceList_attrs = setFieldTypes(t, NamespaceList_fields, NamespaceList_inline)
	Library["NamespaceList"] = skylark.NewBuiltin("NamespaceList", createNamespaceList)
}

func createNamespaceList(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := NamespaceList{V: &core.NamespaceList{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t NamespaceList) Underlying() interface{} { return t.V }
func (t NamespaceList) DeepCopy() boxed         { return NamespaceList{V: t.V.DeepCopy()} }
func (t NamespaceList) Package() util.Package   { return util.Core }
func (t NamespaceList) Type() string            { return "k8s_core_NamespaceList" }
func (t NamespaceList) String() string          { return t.V.String() }
func (t NamespaceList) Freeze()                 {} // TODO
func (t NamespaceList) Truth() skylark.Bool     { return skylark.True }
func (t NamespaceList) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t NamespaceList) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*NamespaceList)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t NamespaceList) AttrNames() []string { return NamespaceList_attrs }
func (t NamespaceList) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, NamespaceList_fields, NamespaceList_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t NamespaceList) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, NamespaceList_fields, NamespaceList_inline)
}

type NamespaceSpec struct {
	V *core.NamespaceSpec
}

var (
	_ boxed = (*NamespaceSpec)(nil)

	NamespaceSpec_fields = map[string]util.FieldSpec{}
	NamespaceSpec_inline = map[string]util.FieldSpec{}
	NamespaceSpec_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.NamespaceSpec)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.NamespaceSpec:
			return NamespaceSpec{V: v}
		case core.NamespaceSpec:
			return NamespaceSpec{V: &v}
		default:
			return skylark.None
		}
	}
	NamespaceSpec_attrs = setFieldTypes(t, NamespaceSpec_fields, NamespaceSpec_inline)
	Library["NamespaceSpec"] = skylark.NewBuiltin("NamespaceSpec", createNamespaceSpec)
}

func createNamespaceSpec(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := NamespaceSpec{V: &core.NamespaceSpec{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t NamespaceSpec) Underlying() interface{} { return t.V }
func (t NamespaceSpec) DeepCopy() boxed         { return NamespaceSpec{V: t.V.DeepCopy()} }
func (t NamespaceSpec) Package() util.Package   { return util.Core }
func (t NamespaceSpec) Type() string            { return "k8s_core_NamespaceSpec" }
func (t NamespaceSpec) String() string          { return t.V.String() }
func (t NamespaceSpec) Freeze()                 {} // TODO
func (t NamespaceSpec) Truth() skylark.Bool     { return skylark.True }
func (t NamespaceSpec) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t NamespaceSpec) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*NamespaceSpec)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t NamespaceSpec) AttrNames() []string { return NamespaceSpec_attrs }
func (t NamespaceSpec) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, NamespaceSpec_fields, NamespaceSpec_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t NamespaceSpec) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, NamespaceSpec_fields, NamespaceSpec_inline)
}

type NamespaceStatus struct {
	V *core.NamespaceStatus
}

var (
	_ boxed = (*NamespaceStatus)(nil)

	NamespaceStatus_fields = map[string]util.FieldSpec{}
	NamespaceStatus_inline = map[string]util.FieldSpec{}
	NamespaceStatus_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.NamespaceStatus)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.NamespaceStatus:
			return NamespaceStatus{V: v}
		case core.NamespaceStatus:
			return NamespaceStatus{V: &v}
		default:
			return skylark.None
		}
	}
	NamespaceStatus_attrs = setFieldTypes(t, NamespaceStatus_fields, NamespaceStatus_inline)
	Library["NamespaceStatus"] = skylark.NewBuiltin("NamespaceStatus", createNamespaceStatus)
}

func createNamespaceStatus(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := NamespaceStatus{V: &core.NamespaceStatus{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t NamespaceStatus) Underlying() interface{} { return t.V }
func (t NamespaceStatus) DeepCopy() boxed         { return NamespaceStatus{V: t.V.DeepCopy()} }
func (t NamespaceStatus) Package() util.Package   { return util.Core }
func (t NamespaceStatus) Type() string            { return "k8s_core_NamespaceStatus" }
func (t NamespaceStatus) String() string          { return t.V.String() }
func (t NamespaceStatus) Freeze()                 {} // TODO
func (t NamespaceStatus) Truth() skylark.Bool     { return skylark.True }
func (t NamespaceStatus) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t NamespaceStatus) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*NamespaceStatus)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t NamespaceStatus) AttrNames() []string { return NamespaceStatus_attrs }
func (t NamespaceStatus) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, NamespaceStatus_fields, NamespaceStatus_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t NamespaceStatus) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, NamespaceStatus_fields, NamespaceStatus_inline)
}

type Node struct {
	V *core.Node
}

var (
	_ boxed = (*Node)(nil)

	Node_fields = map[string]util.FieldSpec{}
	Node_inline = map[string]util.FieldSpec{}
	Node_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.Node)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.Node:
			return Node{V: v}
		case core.Node:
			return Node{V: &v}
		default:
			return skylark.None
		}
	}
	Node_attrs = setFieldTypes(t, Node_fields, Node_inline)
	Library["Node"] = skylark.NewBuiltin("Node", createNode)
}

func createNode(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := Node{V: &core.Node{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t Node) Underlying() interface{} { return t.V }
func (t Node) DeepCopy() boxed         { return Node{V: t.V.DeepCopy()} }
func (t Node) Package() util.Package   { return util.Core }
func (t Node) Type() string            { return "k8s_core_Node" }
func (t Node) String() string          { return t.V.String() }
func (t Node) Freeze()                 {} // TODO
func (t Node) Truth() skylark.Bool     { return skylark.True }
func (t Node) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t Node) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*Node)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t Node) AttrNames() []string { return Node_attrs }
func (t Node) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, Node_fields, Node_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t Node) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, Node_fields, Node_inline)
}

type NodeAddress struct {
	V *core.NodeAddress
}

var (
	_ boxed = (*NodeAddress)(nil)

	NodeAddress_fields = map[string]util.FieldSpec{}
	NodeAddress_inline = map[string]util.FieldSpec{}
	NodeAddress_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.NodeAddress)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.NodeAddress:
			return NodeAddress{V: v}
		case core.NodeAddress:
			return NodeAddress{V: &v}
		default:
			return skylark.None
		}
	}
	NodeAddress_attrs = setFieldTypes(t, NodeAddress_fields, NodeAddress_inline)
	Library["NodeAddress"] = skylark.NewBuiltin("NodeAddress", createNodeAddress)
}

func createNodeAddress(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := NodeAddress{V: &core.NodeAddress{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t NodeAddress) Underlying() interface{} { return t.V }
func (t NodeAddress) DeepCopy() boxed         { return NodeAddress{V: t.V.DeepCopy()} }
func (t NodeAddress) Package() util.Package   { return util.Core }
func (t NodeAddress) Type() string            { return "k8s_core_NodeAddress" }
func (t NodeAddress) String() string          { return t.V.String() }
func (t NodeAddress) Freeze()                 {} // TODO
func (t NodeAddress) Truth() skylark.Bool     { return skylark.True }
func (t NodeAddress) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t NodeAddress) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*NodeAddress)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t NodeAddress) AttrNames() []string { return NodeAddress_attrs }
func (t NodeAddress) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, NodeAddress_fields, NodeAddress_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t NodeAddress) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, NodeAddress_fields, NodeAddress_inline)
}

type NodeAffinity struct {
	V *core.NodeAffinity
}

var (
	_ boxed = (*NodeAffinity)(nil)

	NodeAffinity_fields = map[string]util.FieldSpec{}
	NodeAffinity_inline = map[string]util.FieldSpec{}
	NodeAffinity_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.NodeAffinity)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.NodeAffinity:
			return NodeAffinity{V: v}
		case core.NodeAffinity:
			return NodeAffinity{V: &v}
		default:
			return skylark.None
		}
	}
	NodeAffinity_attrs = setFieldTypes(t, NodeAffinity_fields, NodeAffinity_inline)
	Library["NodeAffinity"] = skylark.NewBuiltin("NodeAffinity", createNodeAffinity)
}

func createNodeAffinity(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := NodeAffinity{V: &core.NodeAffinity{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t NodeAffinity) Underlying() interface{} { return t.V }
func (t NodeAffinity) DeepCopy() boxed         { return NodeAffinity{V: t.V.DeepCopy()} }
func (t NodeAffinity) Package() util.Package   { return util.Core }
func (t NodeAffinity) Type() string            { return "k8s_core_NodeAffinity" }
func (t NodeAffinity) String() string          { return t.V.String() }
func (t NodeAffinity) Freeze()                 {} // TODO
func (t NodeAffinity) Truth() skylark.Bool     { return skylark.True }
func (t NodeAffinity) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t NodeAffinity) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*NodeAffinity)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t NodeAffinity) AttrNames() []string { return NodeAffinity_attrs }
func (t NodeAffinity) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, NodeAffinity_fields, NodeAffinity_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t NodeAffinity) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, NodeAffinity_fields, NodeAffinity_inline)
}

type NodeCondition struct {
	V *core.NodeCondition
}

var (
	_ boxed = (*NodeCondition)(nil)

	NodeCondition_fields = map[string]util.FieldSpec{}
	NodeCondition_inline = map[string]util.FieldSpec{}
	NodeCondition_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.NodeCondition)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.NodeCondition:
			return NodeCondition{V: v}
		case core.NodeCondition:
			return NodeCondition{V: &v}
		default:
			return skylark.None
		}
	}
	NodeCondition_attrs = setFieldTypes(t, NodeCondition_fields, NodeCondition_inline)
	Library["NodeCondition"] = skylark.NewBuiltin("NodeCondition", createNodeCondition)
}

func createNodeCondition(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := NodeCondition{V: &core.NodeCondition{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t NodeCondition) Underlying() interface{} { return t.V }
func (t NodeCondition) DeepCopy() boxed         { return NodeCondition{V: t.V.DeepCopy()} }
func (t NodeCondition) Package() util.Package   { return util.Core }
func (t NodeCondition) Type() string            { return "k8s_core_NodeCondition" }
func (t NodeCondition) String() string          { return t.V.String() }
func (t NodeCondition) Freeze()                 {} // TODO
func (t NodeCondition) Truth() skylark.Bool     { return skylark.True }
func (t NodeCondition) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t NodeCondition) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*NodeCondition)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t NodeCondition) AttrNames() []string { return NodeCondition_attrs }
func (t NodeCondition) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, NodeCondition_fields, NodeCondition_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t NodeCondition) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, NodeCondition_fields, NodeCondition_inline)
}

type NodeConfigSource struct {
	V *core.NodeConfigSource
}

var (
	_ boxed = (*NodeConfigSource)(nil)

	NodeConfigSource_fields = map[string]util.FieldSpec{}
	NodeConfigSource_inline = map[string]util.FieldSpec{}
	NodeConfigSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.NodeConfigSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.NodeConfigSource:
			return NodeConfigSource{V: v}
		case core.NodeConfigSource:
			return NodeConfigSource{V: &v}
		default:
			return skylark.None
		}
	}
	NodeConfigSource_attrs = setFieldTypes(t, NodeConfigSource_fields, NodeConfigSource_inline)
	Library["NodeConfigSource"] = skylark.NewBuiltin("NodeConfigSource", createNodeConfigSource)
}

func createNodeConfigSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := NodeConfigSource{V: &core.NodeConfigSource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t NodeConfigSource) Underlying() interface{} { return t.V }
func (t NodeConfigSource) DeepCopy() boxed         { return NodeConfigSource{V: t.V.DeepCopy()} }
func (t NodeConfigSource) Package() util.Package   { return util.Core }
func (t NodeConfigSource) Type() string            { return "k8s_core_NodeConfigSource" }
func (t NodeConfigSource) String() string          { return t.V.String() }
func (t NodeConfigSource) Freeze()                 {} // TODO
func (t NodeConfigSource) Truth() skylark.Bool     { return skylark.True }
func (t NodeConfigSource) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t NodeConfigSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*NodeConfigSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t NodeConfigSource) AttrNames() []string { return NodeConfigSource_attrs }
func (t NodeConfigSource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, NodeConfigSource_fields, NodeConfigSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t NodeConfigSource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, NodeConfigSource_fields, NodeConfigSource_inline)
}

type NodeConfigStatus struct {
	V *core.NodeConfigStatus
}

var (
	_ boxed = (*NodeConfigStatus)(nil)

	NodeConfigStatus_fields = map[string]util.FieldSpec{}
	NodeConfigStatus_inline = map[string]util.FieldSpec{}
	NodeConfigStatus_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.NodeConfigStatus)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.NodeConfigStatus:
			return NodeConfigStatus{V: v}
		case core.NodeConfigStatus:
			return NodeConfigStatus{V: &v}
		default:
			return skylark.None
		}
	}
	NodeConfigStatus_attrs = setFieldTypes(t, NodeConfigStatus_fields, NodeConfigStatus_inline)
	Library["NodeConfigStatus"] = skylark.NewBuiltin("NodeConfigStatus", createNodeConfigStatus)
}

func createNodeConfigStatus(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := NodeConfigStatus{V: &core.NodeConfigStatus{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t NodeConfigStatus) Underlying() interface{} { return t.V }
func (t NodeConfigStatus) DeepCopy() boxed         { return NodeConfigStatus{V: t.V.DeepCopy()} }
func (t NodeConfigStatus) Package() util.Package   { return util.Core }
func (t NodeConfigStatus) Type() string            { return "k8s_core_NodeConfigStatus" }
func (t NodeConfigStatus) String() string          { return t.V.String() }
func (t NodeConfigStatus) Freeze()                 {} // TODO
func (t NodeConfigStatus) Truth() skylark.Bool     { return skylark.True }
func (t NodeConfigStatus) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t NodeConfigStatus) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*NodeConfigStatus)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t NodeConfigStatus) AttrNames() []string { return NodeConfigStatus_attrs }
func (t NodeConfigStatus) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, NodeConfigStatus_fields, NodeConfigStatus_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t NodeConfigStatus) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, NodeConfigStatus_fields, NodeConfigStatus_inline)
}

type NodeDaemonEndpoints struct {
	V *core.NodeDaemonEndpoints
}

var (
	_ boxed = (*NodeDaemonEndpoints)(nil)

	NodeDaemonEndpoints_fields = map[string]util.FieldSpec{}
	NodeDaemonEndpoints_inline = map[string]util.FieldSpec{}
	NodeDaemonEndpoints_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.NodeDaemonEndpoints)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.NodeDaemonEndpoints:
			return NodeDaemonEndpoints{V: v}
		case core.NodeDaemonEndpoints:
			return NodeDaemonEndpoints{V: &v}
		default:
			return skylark.None
		}
	}
	NodeDaemonEndpoints_attrs = setFieldTypes(t, NodeDaemonEndpoints_fields, NodeDaemonEndpoints_inline)
	Library["NodeDaemonEndpoints"] = skylark.NewBuiltin("NodeDaemonEndpoints", createNodeDaemonEndpoints)
}

func createNodeDaemonEndpoints(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := NodeDaemonEndpoints{V: &core.NodeDaemonEndpoints{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t NodeDaemonEndpoints) Underlying() interface{} { return t.V }
func (t NodeDaemonEndpoints) DeepCopy() boxed         { return NodeDaemonEndpoints{V: t.V.DeepCopy()} }
func (t NodeDaemonEndpoints) Package() util.Package   { return util.Core }
func (t NodeDaemonEndpoints) Type() string            { return "k8s_core_NodeDaemonEndpoints" }
func (t NodeDaemonEndpoints) String() string          { return t.V.String() }
func (t NodeDaemonEndpoints) Freeze()                 {} // TODO
func (t NodeDaemonEndpoints) Truth() skylark.Bool     { return skylark.True }
func (t NodeDaemonEndpoints) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t NodeDaemonEndpoints) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*NodeDaemonEndpoints)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t NodeDaemonEndpoints) AttrNames() []string { return NodeDaemonEndpoints_attrs }
func (t NodeDaemonEndpoints) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, NodeDaemonEndpoints_fields, NodeDaemonEndpoints_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t NodeDaemonEndpoints) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, NodeDaemonEndpoints_fields, NodeDaemonEndpoints_inline)
}

type NodeList struct {
	V *core.NodeList
}

var (
	_ boxed = (*NodeList)(nil)

	NodeList_fields = map[string]util.FieldSpec{}
	NodeList_inline = map[string]util.FieldSpec{}
	NodeList_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.NodeList)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.NodeList:
			return NodeList{V: v}
		case core.NodeList:
			return NodeList{V: &v}
		default:
			return skylark.None
		}
	}
	NodeList_attrs = setFieldTypes(t, NodeList_fields, NodeList_inline)
	Library["NodeList"] = skylark.NewBuiltin("NodeList", createNodeList)
}

func createNodeList(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := NodeList{V: &core.NodeList{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t NodeList) Underlying() interface{} { return t.V }
func (t NodeList) DeepCopy() boxed         { return NodeList{V: t.V.DeepCopy()} }
func (t NodeList) Package() util.Package   { return util.Core }
func (t NodeList) Type() string            { return "k8s_core_NodeList" }
func (t NodeList) String() string          { return t.V.String() }
func (t NodeList) Freeze()                 {} // TODO
func (t NodeList) Truth() skylark.Bool     { return skylark.True }
func (t NodeList) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t NodeList) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*NodeList)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t NodeList) AttrNames() []string { return NodeList_attrs }
func (t NodeList) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, NodeList_fields, NodeList_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t NodeList) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, NodeList_fields, NodeList_inline)
}

type NodeProxyOptions struct {
	V *core.NodeProxyOptions
}

var (
	_ boxed = (*NodeProxyOptions)(nil)

	NodeProxyOptions_fields = map[string]util.FieldSpec{}
	NodeProxyOptions_inline = map[string]util.FieldSpec{}
	NodeProxyOptions_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.NodeProxyOptions)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.NodeProxyOptions:
			return NodeProxyOptions{V: v}
		case core.NodeProxyOptions:
			return NodeProxyOptions{V: &v}
		default:
			return skylark.None
		}
	}
	NodeProxyOptions_attrs = setFieldTypes(t, NodeProxyOptions_fields, NodeProxyOptions_inline)
	Library["NodeProxyOptions"] = skylark.NewBuiltin("NodeProxyOptions", createNodeProxyOptions)
}

func createNodeProxyOptions(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := NodeProxyOptions{V: &core.NodeProxyOptions{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t NodeProxyOptions) Underlying() interface{} { return t.V }
func (t NodeProxyOptions) DeepCopy() boxed         { return NodeProxyOptions{V: t.V.DeepCopy()} }
func (t NodeProxyOptions) Package() util.Package   { return util.Core }
func (t NodeProxyOptions) Type() string            { return "k8s_core_NodeProxyOptions" }
func (t NodeProxyOptions) String() string          { return t.V.String() }
func (t NodeProxyOptions) Freeze()                 {} // TODO
func (t NodeProxyOptions) Truth() skylark.Bool     { return skylark.True }
func (t NodeProxyOptions) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t NodeProxyOptions) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*NodeProxyOptions)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t NodeProxyOptions) AttrNames() []string { return NodeProxyOptions_attrs }
func (t NodeProxyOptions) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, NodeProxyOptions_fields, NodeProxyOptions_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t NodeProxyOptions) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, NodeProxyOptions_fields, NodeProxyOptions_inline)
}

type NodeResources struct {
	V *core.NodeResources
}

var (
	_ boxed = (*NodeResources)(nil)

	NodeResources_fields = map[string]util.FieldSpec{}
	NodeResources_inline = map[string]util.FieldSpec{}
	NodeResources_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.NodeResources)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.NodeResources:
			return NodeResources{V: v}
		case core.NodeResources:
			return NodeResources{V: &v}
		default:
			return skylark.None
		}
	}
	NodeResources_attrs = setFieldTypes(t, NodeResources_fields, NodeResources_inline)
	Library["NodeResources"] = skylark.NewBuiltin("NodeResources", createNodeResources)
}

func createNodeResources(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := NodeResources{V: &core.NodeResources{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t NodeResources) Underlying() interface{} { return t.V }
func (t NodeResources) DeepCopy() boxed         { return NodeResources{V: t.V.DeepCopy()} }
func (t NodeResources) Package() util.Package   { return util.Core }
func (t NodeResources) Type() string            { return "k8s_core_NodeResources" }
func (t NodeResources) String() string          { return t.V.String() }
func (t NodeResources) Freeze()                 {} // TODO
func (t NodeResources) Truth() skylark.Bool     { return skylark.True }
func (t NodeResources) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t NodeResources) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*NodeResources)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t NodeResources) AttrNames() []string { return NodeResources_attrs }
func (t NodeResources) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, NodeResources_fields, NodeResources_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t NodeResources) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, NodeResources_fields, NodeResources_inline)
}

type NodeSelector struct {
	V *core.NodeSelector
}

var (
	_ boxed = (*NodeSelector)(nil)

	NodeSelector_fields = map[string]util.FieldSpec{}
	NodeSelector_inline = map[string]util.FieldSpec{}
	NodeSelector_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.NodeSelector)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.NodeSelector:
			return NodeSelector{V: v}
		case core.NodeSelector:
			return NodeSelector{V: &v}
		default:
			return skylark.None
		}
	}
	NodeSelector_attrs = setFieldTypes(t, NodeSelector_fields, NodeSelector_inline)
	Library["NodeSelector"] = skylark.NewBuiltin("NodeSelector", createNodeSelector)
}

func createNodeSelector(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := NodeSelector{V: &core.NodeSelector{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t NodeSelector) Underlying() interface{} { return t.V }
func (t NodeSelector) DeepCopy() boxed         { return NodeSelector{V: t.V.DeepCopy()} }
func (t NodeSelector) Package() util.Package   { return util.Core }
func (t NodeSelector) Type() string            { return "k8s_core_NodeSelector" }
func (t NodeSelector) String() string          { return t.V.String() }
func (t NodeSelector) Freeze()                 {} // TODO
func (t NodeSelector) Truth() skylark.Bool     { return skylark.True }
func (t NodeSelector) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t NodeSelector) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*NodeSelector)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t NodeSelector) AttrNames() []string { return NodeSelector_attrs }
func (t NodeSelector) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, NodeSelector_fields, NodeSelector_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t NodeSelector) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, NodeSelector_fields, NodeSelector_inline)
}

type NodeSelectorRequirement struct {
	V *core.NodeSelectorRequirement
}

var (
	_ boxed = (*NodeSelectorRequirement)(nil)

	NodeSelectorRequirement_fields = map[string]util.FieldSpec{}
	NodeSelectorRequirement_inline = map[string]util.FieldSpec{}
	NodeSelectorRequirement_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.NodeSelectorRequirement)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.NodeSelectorRequirement:
			return NodeSelectorRequirement{V: v}
		case core.NodeSelectorRequirement:
			return NodeSelectorRequirement{V: &v}
		default:
			return skylark.None
		}
	}
	NodeSelectorRequirement_attrs = setFieldTypes(t, NodeSelectorRequirement_fields, NodeSelectorRequirement_inline)
	Library["NodeSelectorRequirement"] = skylark.NewBuiltin("NodeSelectorRequirement", createNodeSelectorRequirement)
}

func createNodeSelectorRequirement(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := NodeSelectorRequirement{V: &core.NodeSelectorRequirement{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t NodeSelectorRequirement) Underlying() interface{} { return t.V }
func (t NodeSelectorRequirement) DeepCopy() boxed         { return NodeSelectorRequirement{V: t.V.DeepCopy()} }
func (t NodeSelectorRequirement) Package() util.Package   { return util.Core }
func (t NodeSelectorRequirement) Type() string            { return "k8s_core_NodeSelectorRequirement" }
func (t NodeSelectorRequirement) String() string          { return t.V.String() }
func (t NodeSelectorRequirement) Freeze()                 {} // TODO
func (t NodeSelectorRequirement) Truth() skylark.Bool     { return skylark.True }
func (t NodeSelectorRequirement) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t NodeSelectorRequirement) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*NodeSelectorRequirement)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t NodeSelectorRequirement) AttrNames() []string { return NodeSelectorRequirement_attrs }
func (t NodeSelectorRequirement) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, NodeSelectorRequirement_fields, NodeSelectorRequirement_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t NodeSelectorRequirement) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, NodeSelectorRequirement_fields, NodeSelectorRequirement_inline)
}

type NodeSelectorTerm struct {
	V *core.NodeSelectorTerm
}

var (
	_ boxed = (*NodeSelectorTerm)(nil)

	NodeSelectorTerm_fields = map[string]util.FieldSpec{}
	NodeSelectorTerm_inline = map[string]util.FieldSpec{}
	NodeSelectorTerm_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.NodeSelectorTerm)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.NodeSelectorTerm:
			return NodeSelectorTerm{V: v}
		case core.NodeSelectorTerm:
			return NodeSelectorTerm{V: &v}
		default:
			return skylark.None
		}
	}
	NodeSelectorTerm_attrs = setFieldTypes(t, NodeSelectorTerm_fields, NodeSelectorTerm_inline)
	Library["NodeSelectorTerm"] = skylark.NewBuiltin("NodeSelectorTerm", createNodeSelectorTerm)
}

func createNodeSelectorTerm(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := NodeSelectorTerm{V: &core.NodeSelectorTerm{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t NodeSelectorTerm) Underlying() interface{} { return t.V }
func (t NodeSelectorTerm) DeepCopy() boxed         { return NodeSelectorTerm{V: t.V.DeepCopy()} }
func (t NodeSelectorTerm) Package() util.Package   { return util.Core }
func (t NodeSelectorTerm) Type() string            { return "k8s_core_NodeSelectorTerm" }
func (t NodeSelectorTerm) String() string          { return t.V.String() }
func (t NodeSelectorTerm) Freeze()                 {} // TODO
func (t NodeSelectorTerm) Truth() skylark.Bool     { return skylark.True }
func (t NodeSelectorTerm) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t NodeSelectorTerm) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*NodeSelectorTerm)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t NodeSelectorTerm) AttrNames() []string { return NodeSelectorTerm_attrs }
func (t NodeSelectorTerm) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, NodeSelectorTerm_fields, NodeSelectorTerm_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t NodeSelectorTerm) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, NodeSelectorTerm_fields, NodeSelectorTerm_inline)
}

type NodeSpec struct {
	V *core.NodeSpec
}

var (
	_ boxed = (*NodeSpec)(nil)

	NodeSpec_fields = map[string]util.FieldSpec{}
	NodeSpec_inline = map[string]util.FieldSpec{}
	NodeSpec_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.NodeSpec)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.NodeSpec:
			return NodeSpec{V: v}
		case core.NodeSpec:
			return NodeSpec{V: &v}
		default:
			return skylark.None
		}
	}
	NodeSpec_attrs = setFieldTypes(t, NodeSpec_fields, NodeSpec_inline)
	Library["NodeSpec"] = skylark.NewBuiltin("NodeSpec", createNodeSpec)
}

func createNodeSpec(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := NodeSpec{V: &core.NodeSpec{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t NodeSpec) Underlying() interface{} { return t.V }
func (t NodeSpec) DeepCopy() boxed         { return NodeSpec{V: t.V.DeepCopy()} }
func (t NodeSpec) Package() util.Package   { return util.Core }
func (t NodeSpec) Type() string            { return "k8s_core_NodeSpec" }
func (t NodeSpec) String() string          { return t.V.String() }
func (t NodeSpec) Freeze()                 {} // TODO
func (t NodeSpec) Truth() skylark.Bool     { return skylark.True }
func (t NodeSpec) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t NodeSpec) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*NodeSpec)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t NodeSpec) AttrNames() []string { return NodeSpec_attrs }
func (t NodeSpec) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, NodeSpec_fields, NodeSpec_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t NodeSpec) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, NodeSpec_fields, NodeSpec_inline)
}

type NodeStatus struct {
	V *core.NodeStatus
}

var (
	_ boxed = (*NodeStatus)(nil)

	NodeStatus_fields = map[string]util.FieldSpec{}
	NodeStatus_inline = map[string]util.FieldSpec{}
	NodeStatus_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.NodeStatus)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.NodeStatus:
			return NodeStatus{V: v}
		case core.NodeStatus:
			return NodeStatus{V: &v}
		default:
			return skylark.None
		}
	}
	NodeStatus_attrs = setFieldTypes(t, NodeStatus_fields, NodeStatus_inline)
	Library["NodeStatus"] = skylark.NewBuiltin("NodeStatus", createNodeStatus)
}

func createNodeStatus(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := NodeStatus{V: &core.NodeStatus{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t NodeStatus) Underlying() interface{} { return t.V }
func (t NodeStatus) DeepCopy() boxed         { return NodeStatus{V: t.V.DeepCopy()} }
func (t NodeStatus) Package() util.Package   { return util.Core }
func (t NodeStatus) Type() string            { return "k8s_core_NodeStatus" }
func (t NodeStatus) String() string          { return t.V.String() }
func (t NodeStatus) Freeze()                 {} // TODO
func (t NodeStatus) Truth() skylark.Bool     { return skylark.True }
func (t NodeStatus) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t NodeStatus) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*NodeStatus)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t NodeStatus) AttrNames() []string { return NodeStatus_attrs }
func (t NodeStatus) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, NodeStatus_fields, NodeStatus_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t NodeStatus) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, NodeStatus_fields, NodeStatus_inline)
}

type NodeSystemInfo struct {
	V *core.NodeSystemInfo
}

var (
	_ boxed = (*NodeSystemInfo)(nil)

	NodeSystemInfo_fields = map[string]util.FieldSpec{}
	NodeSystemInfo_inline = map[string]util.FieldSpec{}
	NodeSystemInfo_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.NodeSystemInfo)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.NodeSystemInfo:
			return NodeSystemInfo{V: v}
		case core.NodeSystemInfo:
			return NodeSystemInfo{V: &v}
		default:
			return skylark.None
		}
	}
	NodeSystemInfo_attrs = setFieldTypes(t, NodeSystemInfo_fields, NodeSystemInfo_inline)
	Library["NodeSystemInfo"] = skylark.NewBuiltin("NodeSystemInfo", createNodeSystemInfo)
}

func createNodeSystemInfo(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := NodeSystemInfo{V: &core.NodeSystemInfo{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t NodeSystemInfo) Underlying() interface{} { return t.V }
func (t NodeSystemInfo) DeepCopy() boxed         { return NodeSystemInfo{V: t.V.DeepCopy()} }
func (t NodeSystemInfo) Package() util.Package   { return util.Core }
func (t NodeSystemInfo) Type() string            { return "k8s_core_NodeSystemInfo" }
func (t NodeSystemInfo) String() string          { return t.V.String() }
func (t NodeSystemInfo) Freeze()                 {} // TODO
func (t NodeSystemInfo) Truth() skylark.Bool     { return skylark.True }
func (t NodeSystemInfo) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t NodeSystemInfo) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*NodeSystemInfo)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t NodeSystemInfo) AttrNames() []string { return NodeSystemInfo_attrs }
func (t NodeSystemInfo) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, NodeSystemInfo_fields, NodeSystemInfo_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t NodeSystemInfo) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, NodeSystemInfo_fields, NodeSystemInfo_inline)
}

type ObjectFieldSelector struct {
	V *core.ObjectFieldSelector
}

var (
	_ boxed = (*ObjectFieldSelector)(nil)

	ObjectFieldSelector_fields = map[string]util.FieldSpec{}
	ObjectFieldSelector_inline = map[string]util.FieldSpec{}
	ObjectFieldSelector_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.ObjectFieldSelector)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.ObjectFieldSelector:
			return ObjectFieldSelector{V: v}
		case core.ObjectFieldSelector:
			return ObjectFieldSelector{V: &v}
		default:
			return skylark.None
		}
	}
	ObjectFieldSelector_attrs = setFieldTypes(t, ObjectFieldSelector_fields, ObjectFieldSelector_inline)
	Library["ObjectFieldSelector"] = skylark.NewBuiltin("ObjectFieldSelector", createObjectFieldSelector)
}

func createObjectFieldSelector(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ObjectFieldSelector{V: &core.ObjectFieldSelector{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ObjectFieldSelector) Underlying() interface{} { return t.V }
func (t ObjectFieldSelector) DeepCopy() boxed         { return ObjectFieldSelector{V: t.V.DeepCopy()} }
func (t ObjectFieldSelector) Package() util.Package   { return util.Core }
func (t ObjectFieldSelector) Type() string            { return "k8s_core_ObjectFieldSelector" }
func (t ObjectFieldSelector) String() string          { return t.V.String() }
func (t ObjectFieldSelector) Freeze()                 {} // TODO
func (t ObjectFieldSelector) Truth() skylark.Bool     { return skylark.True }
func (t ObjectFieldSelector) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ObjectFieldSelector) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ObjectFieldSelector)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ObjectFieldSelector) AttrNames() []string { return ObjectFieldSelector_attrs }
func (t ObjectFieldSelector) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ObjectFieldSelector_fields, ObjectFieldSelector_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ObjectFieldSelector) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ObjectFieldSelector_fields, ObjectFieldSelector_inline)
}

type ObjectReference struct {
	V *core.ObjectReference
}

var (
	_ boxed = (*ObjectReference)(nil)

	ObjectReference_fields = map[string]util.FieldSpec{}
	ObjectReference_inline = map[string]util.FieldSpec{}
	ObjectReference_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.ObjectReference)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.ObjectReference:
			return ObjectReference{V: v}
		case core.ObjectReference:
			return ObjectReference{V: &v}
		default:
			return skylark.None
		}
	}
	ObjectReference_attrs = setFieldTypes(t, ObjectReference_fields, ObjectReference_inline)
	Library["ObjectReference"] = skylark.NewBuiltin("ObjectReference", createObjectReference)
}

func createObjectReference(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ObjectReference{V: &core.ObjectReference{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ObjectReference) Underlying() interface{} { return t.V }
func (t ObjectReference) DeepCopy() boxed         { return ObjectReference{V: t.V.DeepCopy()} }
func (t ObjectReference) Package() util.Package   { return util.Core }
func (t ObjectReference) Type() string            { return "k8s_core_ObjectReference" }
func (t ObjectReference) String() string          { return t.V.String() }
func (t ObjectReference) Freeze()                 {} // TODO
func (t ObjectReference) Truth() skylark.Bool     { return skylark.True }
func (t ObjectReference) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ObjectReference) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ObjectReference)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ObjectReference) AttrNames() []string { return ObjectReference_attrs }
func (t ObjectReference) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ObjectReference_fields, ObjectReference_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ObjectReference) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ObjectReference_fields, ObjectReference_inline)
}

type PersistentVolume struct {
	V *core.PersistentVolume
}

var (
	_ boxed = (*PersistentVolume)(nil)

	PersistentVolume_fields = map[string]util.FieldSpec{}
	PersistentVolume_inline = map[string]util.FieldSpec{}
	PersistentVolume_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.PersistentVolume)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.PersistentVolume:
			return PersistentVolume{V: v}
		case core.PersistentVolume:
			return PersistentVolume{V: &v}
		default:
			return skylark.None
		}
	}
	PersistentVolume_attrs = setFieldTypes(t, PersistentVolume_fields, PersistentVolume_inline)
	Library["PersistentVolume"] = skylark.NewBuiltin("PersistentVolume", createPersistentVolume)
}

func createPersistentVolume(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := PersistentVolume{V: &core.PersistentVolume{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t PersistentVolume) Underlying() interface{} { return t.V }
func (t PersistentVolume) DeepCopy() boxed         { return PersistentVolume{V: t.V.DeepCopy()} }
func (t PersistentVolume) Package() util.Package   { return util.Core }
func (t PersistentVolume) Type() string            { return "k8s_core_PersistentVolume" }
func (t PersistentVolume) String() string          { return t.V.String() }
func (t PersistentVolume) Freeze()                 {} // TODO
func (t PersistentVolume) Truth() skylark.Bool     { return skylark.True }
func (t PersistentVolume) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t PersistentVolume) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PersistentVolume)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PersistentVolume) AttrNames() []string { return PersistentVolume_attrs }
func (t PersistentVolume) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, PersistentVolume_fields, PersistentVolume_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t PersistentVolume) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, PersistentVolume_fields, PersistentVolume_inline)
}

type PersistentVolumeClaim struct {
	V *core.PersistentVolumeClaim
}

var (
	_ boxed = (*PersistentVolumeClaim)(nil)

	PersistentVolumeClaim_fields = map[string]util.FieldSpec{}
	PersistentVolumeClaim_inline = map[string]util.FieldSpec{}
	PersistentVolumeClaim_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.PersistentVolumeClaim)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.PersistentVolumeClaim:
			return PersistentVolumeClaim{V: v}
		case core.PersistentVolumeClaim:
			return PersistentVolumeClaim{V: &v}
		default:
			return skylark.None
		}
	}
	PersistentVolumeClaim_attrs = setFieldTypes(t, PersistentVolumeClaim_fields, PersistentVolumeClaim_inline)
	Library["PersistentVolumeClaim"] = skylark.NewBuiltin("PersistentVolumeClaim", createPersistentVolumeClaim)
}

func createPersistentVolumeClaim(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := PersistentVolumeClaim{V: &core.PersistentVolumeClaim{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t PersistentVolumeClaim) Underlying() interface{} { return t.V }
func (t PersistentVolumeClaim) DeepCopy() boxed         { return PersistentVolumeClaim{V: t.V.DeepCopy()} }
func (t PersistentVolumeClaim) Package() util.Package   { return util.Core }
func (t PersistentVolumeClaim) Type() string            { return "k8s_core_PersistentVolumeClaim" }
func (t PersistentVolumeClaim) String() string          { return t.V.String() }
func (t PersistentVolumeClaim) Freeze()                 {} // TODO
func (t PersistentVolumeClaim) Truth() skylark.Bool     { return skylark.True }
func (t PersistentVolumeClaim) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t PersistentVolumeClaim) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PersistentVolumeClaim)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PersistentVolumeClaim) AttrNames() []string { return PersistentVolumeClaim_attrs }
func (t PersistentVolumeClaim) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, PersistentVolumeClaim_fields, PersistentVolumeClaim_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t PersistentVolumeClaim) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, PersistentVolumeClaim_fields, PersistentVolumeClaim_inline)
}

type PersistentVolumeClaimCondition struct {
	V *core.PersistentVolumeClaimCondition
}

var (
	_ boxed = (*PersistentVolumeClaimCondition)(nil)

	PersistentVolumeClaimCondition_fields = map[string]util.FieldSpec{}
	PersistentVolumeClaimCondition_inline = map[string]util.FieldSpec{}
	PersistentVolumeClaimCondition_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.PersistentVolumeClaimCondition)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.PersistentVolumeClaimCondition:
			return PersistentVolumeClaimCondition{V: v}
		case core.PersistentVolumeClaimCondition:
			return PersistentVolumeClaimCondition{V: &v}
		default:
			return skylark.None
		}
	}
	PersistentVolumeClaimCondition_attrs = setFieldTypes(t, PersistentVolumeClaimCondition_fields, PersistentVolumeClaimCondition_inline)
	Library["PersistentVolumeClaimCondition"] = skylark.NewBuiltin("PersistentVolumeClaimCondition", createPersistentVolumeClaimCondition)
}

func createPersistentVolumeClaimCondition(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := PersistentVolumeClaimCondition{V: &core.PersistentVolumeClaimCondition{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t PersistentVolumeClaimCondition) Underlying() interface{} { return t.V }
func (t PersistentVolumeClaimCondition) DeepCopy() boxed {
	return PersistentVolumeClaimCondition{V: t.V.DeepCopy()}
}
func (t PersistentVolumeClaimCondition) Package() util.Package { return util.Core }
func (t PersistentVolumeClaimCondition) Type() string {
	return "k8s_core_PersistentVolumeClaimCondition"
}
func (t PersistentVolumeClaimCondition) String() string        { return t.V.String() }
func (t PersistentVolumeClaimCondition) Freeze()               {} // TODO
func (t PersistentVolumeClaimCondition) Truth() skylark.Bool   { return skylark.True }
func (t PersistentVolumeClaimCondition) Hash() (uint32, error) { return 0, unhashable(t.Type()) }
func (t PersistentVolumeClaimCondition) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PersistentVolumeClaimCondition)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PersistentVolumeClaimCondition) AttrNames() []string {
	return PersistentVolumeClaimCondition_attrs
}
func (t PersistentVolumeClaimCondition) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, PersistentVolumeClaimCondition_fields, PersistentVolumeClaimCondition_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t PersistentVolumeClaimCondition) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, PersistentVolumeClaimCondition_fields, PersistentVolumeClaimCondition_inline)
}

type PersistentVolumeClaimList struct {
	V *core.PersistentVolumeClaimList
}

var (
	_ boxed = (*PersistentVolumeClaimList)(nil)

	PersistentVolumeClaimList_fields = map[string]util.FieldSpec{}
	PersistentVolumeClaimList_inline = map[string]util.FieldSpec{}
	PersistentVolumeClaimList_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.PersistentVolumeClaimList)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.PersistentVolumeClaimList:
			return PersistentVolumeClaimList{V: v}
		case core.PersistentVolumeClaimList:
			return PersistentVolumeClaimList{V: &v}
		default:
			return skylark.None
		}
	}
	PersistentVolumeClaimList_attrs = setFieldTypes(t, PersistentVolumeClaimList_fields, PersistentVolumeClaimList_inline)
	Library["PersistentVolumeClaimList"] = skylark.NewBuiltin("PersistentVolumeClaimList", createPersistentVolumeClaimList)
}

func createPersistentVolumeClaimList(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := PersistentVolumeClaimList{V: &core.PersistentVolumeClaimList{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t PersistentVolumeClaimList) Underlying() interface{} { return t.V }
func (t PersistentVolumeClaimList) DeepCopy() boxed {
	return PersistentVolumeClaimList{V: t.V.DeepCopy()}
}
func (t PersistentVolumeClaimList) Package() util.Package { return util.Core }
func (t PersistentVolumeClaimList) Type() string          { return "k8s_core_PersistentVolumeClaimList" }
func (t PersistentVolumeClaimList) String() string        { return t.V.String() }
func (t PersistentVolumeClaimList) Freeze()               {} // TODO
func (t PersistentVolumeClaimList) Truth() skylark.Bool   { return skylark.True }
func (t PersistentVolumeClaimList) Hash() (uint32, error) { return 0, unhashable(t.Type()) }
func (t PersistentVolumeClaimList) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PersistentVolumeClaimList)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PersistentVolumeClaimList) AttrNames() []string { return PersistentVolumeClaimList_attrs }
func (t PersistentVolumeClaimList) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, PersistentVolumeClaimList_fields, PersistentVolumeClaimList_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t PersistentVolumeClaimList) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, PersistentVolumeClaimList_fields, PersistentVolumeClaimList_inline)
}

type PersistentVolumeClaimSpec struct {
	V *core.PersistentVolumeClaimSpec
}

var (
	_ boxed = (*PersistentVolumeClaimSpec)(nil)

	PersistentVolumeClaimSpec_fields = map[string]util.FieldSpec{}
	PersistentVolumeClaimSpec_inline = map[string]util.FieldSpec{}
	PersistentVolumeClaimSpec_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.PersistentVolumeClaimSpec)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.PersistentVolumeClaimSpec:
			return PersistentVolumeClaimSpec{V: v}
		case core.PersistentVolumeClaimSpec:
			return PersistentVolumeClaimSpec{V: &v}
		default:
			return skylark.None
		}
	}
	PersistentVolumeClaimSpec_attrs = setFieldTypes(t, PersistentVolumeClaimSpec_fields, PersistentVolumeClaimSpec_inline)
	Library["PersistentVolumeClaimSpec"] = skylark.NewBuiltin("PersistentVolumeClaimSpec", createPersistentVolumeClaimSpec)
}

func createPersistentVolumeClaimSpec(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := PersistentVolumeClaimSpec{V: &core.PersistentVolumeClaimSpec{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t PersistentVolumeClaimSpec) Underlying() interface{} { return t.V }
func (t PersistentVolumeClaimSpec) DeepCopy() boxed {
	return PersistentVolumeClaimSpec{V: t.V.DeepCopy()}
}
func (t PersistentVolumeClaimSpec) Package() util.Package { return util.Core }
func (t PersistentVolumeClaimSpec) Type() string          { return "k8s_core_PersistentVolumeClaimSpec" }
func (t PersistentVolumeClaimSpec) String() string        { return t.V.String() }
func (t PersistentVolumeClaimSpec) Freeze()               {} // TODO
func (t PersistentVolumeClaimSpec) Truth() skylark.Bool   { return skylark.True }
func (t PersistentVolumeClaimSpec) Hash() (uint32, error) { return 0, unhashable(t.Type()) }
func (t PersistentVolumeClaimSpec) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PersistentVolumeClaimSpec)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PersistentVolumeClaimSpec) AttrNames() []string { return PersistentVolumeClaimSpec_attrs }
func (t PersistentVolumeClaimSpec) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, PersistentVolumeClaimSpec_fields, PersistentVolumeClaimSpec_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t PersistentVolumeClaimSpec) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, PersistentVolumeClaimSpec_fields, PersistentVolumeClaimSpec_inline)
}

type PersistentVolumeClaimStatus struct {
	V *core.PersistentVolumeClaimStatus
}

var (
	_ boxed = (*PersistentVolumeClaimStatus)(nil)

	PersistentVolumeClaimStatus_fields = map[string]util.FieldSpec{}
	PersistentVolumeClaimStatus_inline = map[string]util.FieldSpec{}
	PersistentVolumeClaimStatus_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.PersistentVolumeClaimStatus)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.PersistentVolumeClaimStatus:
			return PersistentVolumeClaimStatus{V: v}
		case core.PersistentVolumeClaimStatus:
			return PersistentVolumeClaimStatus{V: &v}
		default:
			return skylark.None
		}
	}
	PersistentVolumeClaimStatus_attrs = setFieldTypes(t, PersistentVolumeClaimStatus_fields, PersistentVolumeClaimStatus_inline)
	Library["PersistentVolumeClaimStatus"] = skylark.NewBuiltin("PersistentVolumeClaimStatus", createPersistentVolumeClaimStatus)
}

func createPersistentVolumeClaimStatus(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := PersistentVolumeClaimStatus{V: &core.PersistentVolumeClaimStatus{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t PersistentVolumeClaimStatus) Underlying() interface{} { return t.V }
func (t PersistentVolumeClaimStatus) DeepCopy() boxed {
	return PersistentVolumeClaimStatus{V: t.V.DeepCopy()}
}
func (t PersistentVolumeClaimStatus) Package() util.Package { return util.Core }
func (t PersistentVolumeClaimStatus) Type() string          { return "k8s_core_PersistentVolumeClaimStatus" }
func (t PersistentVolumeClaimStatus) String() string        { return t.V.String() }
func (t PersistentVolumeClaimStatus) Freeze()               {} // TODO
func (t PersistentVolumeClaimStatus) Truth() skylark.Bool   { return skylark.True }
func (t PersistentVolumeClaimStatus) Hash() (uint32, error) { return 0, unhashable(t.Type()) }
func (t PersistentVolumeClaimStatus) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PersistentVolumeClaimStatus)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PersistentVolumeClaimStatus) AttrNames() []string { return PersistentVolumeClaimStatus_attrs }
func (t PersistentVolumeClaimStatus) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, PersistentVolumeClaimStatus_fields, PersistentVolumeClaimStatus_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t PersistentVolumeClaimStatus) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, PersistentVolumeClaimStatus_fields, PersistentVolumeClaimStatus_inline)
}

type PersistentVolumeClaimVolumeSource struct {
	V *core.PersistentVolumeClaimVolumeSource
}

var (
	_ boxed = (*PersistentVolumeClaimVolumeSource)(nil)

	PersistentVolumeClaimVolumeSource_fields = map[string]util.FieldSpec{}
	PersistentVolumeClaimVolumeSource_inline = map[string]util.FieldSpec{}
	PersistentVolumeClaimVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.PersistentVolumeClaimVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.PersistentVolumeClaimVolumeSource:
			return PersistentVolumeClaimVolumeSource{V: v}
		case core.PersistentVolumeClaimVolumeSource:
			return PersistentVolumeClaimVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	PersistentVolumeClaimVolumeSource_attrs = setFieldTypes(t, PersistentVolumeClaimVolumeSource_fields, PersistentVolumeClaimVolumeSource_inline)
	Library["PersistentVolumeClaimVolumeSource"] = skylark.NewBuiltin("PersistentVolumeClaimVolumeSource", createPersistentVolumeClaimVolumeSource)
}

func createPersistentVolumeClaimVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := PersistentVolumeClaimVolumeSource{V: &core.PersistentVolumeClaimVolumeSource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t PersistentVolumeClaimVolumeSource) Underlying() interface{} { return t.V }
func (t PersistentVolumeClaimVolumeSource) DeepCopy() boxed {
	return PersistentVolumeClaimVolumeSource{V: t.V.DeepCopy()}
}
func (t PersistentVolumeClaimVolumeSource) Package() util.Package { return util.Core }
func (t PersistentVolumeClaimVolumeSource) Type() string {
	return "k8s_core_PersistentVolumeClaimVolumeSource"
}
func (t PersistentVolumeClaimVolumeSource) String() string        { return t.V.String() }
func (t PersistentVolumeClaimVolumeSource) Freeze()               {} // TODO
func (t PersistentVolumeClaimVolumeSource) Truth() skylark.Bool   { return skylark.True }
func (t PersistentVolumeClaimVolumeSource) Hash() (uint32, error) { return 0, unhashable(t.Type()) }
func (t PersistentVolumeClaimVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PersistentVolumeClaimVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PersistentVolumeClaimVolumeSource) AttrNames() []string {
	return PersistentVolumeClaimVolumeSource_attrs
}
func (t PersistentVolumeClaimVolumeSource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, PersistentVolumeClaimVolumeSource_fields, PersistentVolumeClaimVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t PersistentVolumeClaimVolumeSource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, PersistentVolumeClaimVolumeSource_fields, PersistentVolumeClaimVolumeSource_inline)
}

type PersistentVolumeList struct {
	V *core.PersistentVolumeList
}

var (
	_ boxed = (*PersistentVolumeList)(nil)

	PersistentVolumeList_fields = map[string]util.FieldSpec{}
	PersistentVolumeList_inline = map[string]util.FieldSpec{}
	PersistentVolumeList_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.PersistentVolumeList)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.PersistentVolumeList:
			return PersistentVolumeList{V: v}
		case core.PersistentVolumeList:
			return PersistentVolumeList{V: &v}
		default:
			return skylark.None
		}
	}
	PersistentVolumeList_attrs = setFieldTypes(t, PersistentVolumeList_fields, PersistentVolumeList_inline)
	Library["PersistentVolumeList"] = skylark.NewBuiltin("PersistentVolumeList", createPersistentVolumeList)
}

func createPersistentVolumeList(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := PersistentVolumeList{V: &core.PersistentVolumeList{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t PersistentVolumeList) Underlying() interface{} { return t.V }
func (t PersistentVolumeList) DeepCopy() boxed         { return PersistentVolumeList{V: t.V.DeepCopy()} }
func (t PersistentVolumeList) Package() util.Package   { return util.Core }
func (t PersistentVolumeList) Type() string            { return "k8s_core_PersistentVolumeList" }
func (t PersistentVolumeList) String() string          { return t.V.String() }
func (t PersistentVolumeList) Freeze()                 {} // TODO
func (t PersistentVolumeList) Truth() skylark.Bool     { return skylark.True }
func (t PersistentVolumeList) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t PersistentVolumeList) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PersistentVolumeList)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PersistentVolumeList) AttrNames() []string { return PersistentVolumeList_attrs }
func (t PersistentVolumeList) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, PersistentVolumeList_fields, PersistentVolumeList_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t PersistentVolumeList) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, PersistentVolumeList_fields, PersistentVolumeList_inline)
}

type PersistentVolumeSource struct {
	V *core.PersistentVolumeSource
}

var (
	_ boxed = (*PersistentVolumeSource)(nil)

	PersistentVolumeSource_fields = map[string]util.FieldSpec{}
	PersistentVolumeSource_inline = map[string]util.FieldSpec{}
	PersistentVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.PersistentVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.PersistentVolumeSource:
			return PersistentVolumeSource{V: v}
		case core.PersistentVolumeSource:
			return PersistentVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	PersistentVolumeSource_attrs = setFieldTypes(t, PersistentVolumeSource_fields, PersistentVolumeSource_inline)
	Library["PersistentVolumeSource"] = skylark.NewBuiltin("PersistentVolumeSource", createPersistentVolumeSource)
}

func createPersistentVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := PersistentVolumeSource{V: &core.PersistentVolumeSource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t PersistentVolumeSource) Underlying() interface{} { return t.V }
func (t PersistentVolumeSource) DeepCopy() boxed         { return PersistentVolumeSource{V: t.V.DeepCopy()} }
func (t PersistentVolumeSource) Package() util.Package   { return util.Core }
func (t PersistentVolumeSource) Type() string            { return "k8s_core_PersistentVolumeSource" }
func (t PersistentVolumeSource) String() string          { return t.V.String() }
func (t PersistentVolumeSource) Freeze()                 {} // TODO
func (t PersistentVolumeSource) Truth() skylark.Bool     { return skylark.True }
func (t PersistentVolumeSource) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t PersistentVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PersistentVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PersistentVolumeSource) AttrNames() []string { return PersistentVolumeSource_attrs }
func (t PersistentVolumeSource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, PersistentVolumeSource_fields, PersistentVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t PersistentVolumeSource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, PersistentVolumeSource_fields, PersistentVolumeSource_inline)
}

type PersistentVolumeSpec struct {
	V *core.PersistentVolumeSpec
}

var (
	_ boxed = (*PersistentVolumeSpec)(nil)

	PersistentVolumeSpec_fields = map[string]util.FieldSpec{}
	PersistentVolumeSpec_inline = map[string]util.FieldSpec{}
	PersistentVolumeSpec_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.PersistentVolumeSpec)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.PersistentVolumeSpec:
			return PersistentVolumeSpec{V: v}
		case core.PersistentVolumeSpec:
			return PersistentVolumeSpec{V: &v}
		default:
			return skylark.None
		}
	}
	PersistentVolumeSpec_attrs = setFieldTypes(t, PersistentVolumeSpec_fields, PersistentVolumeSpec_inline)
	Library["PersistentVolumeSpec"] = skylark.NewBuiltin("PersistentVolumeSpec", createPersistentVolumeSpec)
}

func createPersistentVolumeSpec(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := PersistentVolumeSpec{V: &core.PersistentVolumeSpec{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t PersistentVolumeSpec) Underlying() interface{} { return t.V }
func (t PersistentVolumeSpec) DeepCopy() boxed         { return PersistentVolumeSpec{V: t.V.DeepCopy()} }
func (t PersistentVolumeSpec) Package() util.Package   { return util.Core }
func (t PersistentVolumeSpec) Type() string            { return "k8s_core_PersistentVolumeSpec" }
func (t PersistentVolumeSpec) String() string          { return t.V.String() }
func (t PersistentVolumeSpec) Freeze()                 {} // TODO
func (t PersistentVolumeSpec) Truth() skylark.Bool     { return skylark.True }
func (t PersistentVolumeSpec) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t PersistentVolumeSpec) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PersistentVolumeSpec)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PersistentVolumeSpec) AttrNames() []string { return PersistentVolumeSpec_attrs }
func (t PersistentVolumeSpec) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, PersistentVolumeSpec_fields, PersistentVolumeSpec_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t PersistentVolumeSpec) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, PersistentVolumeSpec_fields, PersistentVolumeSpec_inline)
}

type PersistentVolumeStatus struct {
	V *core.PersistentVolumeStatus
}

var (
	_ boxed = (*PersistentVolumeStatus)(nil)

	PersistentVolumeStatus_fields = map[string]util.FieldSpec{}
	PersistentVolumeStatus_inline = map[string]util.FieldSpec{}
	PersistentVolumeStatus_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.PersistentVolumeStatus)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.PersistentVolumeStatus:
			return PersistentVolumeStatus{V: v}
		case core.PersistentVolumeStatus:
			return PersistentVolumeStatus{V: &v}
		default:
			return skylark.None
		}
	}
	PersistentVolumeStatus_attrs = setFieldTypes(t, PersistentVolumeStatus_fields, PersistentVolumeStatus_inline)
	Library["PersistentVolumeStatus"] = skylark.NewBuiltin("PersistentVolumeStatus", createPersistentVolumeStatus)
}

func createPersistentVolumeStatus(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := PersistentVolumeStatus{V: &core.PersistentVolumeStatus{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t PersistentVolumeStatus) Underlying() interface{} { return t.V }
func (t PersistentVolumeStatus) DeepCopy() boxed         { return PersistentVolumeStatus{V: t.V.DeepCopy()} }
func (t PersistentVolumeStatus) Package() util.Package   { return util.Core }
func (t PersistentVolumeStatus) Type() string            { return "k8s_core_PersistentVolumeStatus" }
func (t PersistentVolumeStatus) String() string          { return t.V.String() }
func (t PersistentVolumeStatus) Freeze()                 {} // TODO
func (t PersistentVolumeStatus) Truth() skylark.Bool     { return skylark.True }
func (t PersistentVolumeStatus) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t PersistentVolumeStatus) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PersistentVolumeStatus)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PersistentVolumeStatus) AttrNames() []string { return PersistentVolumeStatus_attrs }
func (t PersistentVolumeStatus) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, PersistentVolumeStatus_fields, PersistentVolumeStatus_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t PersistentVolumeStatus) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, PersistentVolumeStatus_fields, PersistentVolumeStatus_inline)
}

type PhotonPersistentDiskVolumeSource struct {
	V *core.PhotonPersistentDiskVolumeSource
}

var (
	_ boxed = (*PhotonPersistentDiskVolumeSource)(nil)

	PhotonPersistentDiskVolumeSource_fields = map[string]util.FieldSpec{}
	PhotonPersistentDiskVolumeSource_inline = map[string]util.FieldSpec{}
	PhotonPersistentDiskVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.PhotonPersistentDiskVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.PhotonPersistentDiskVolumeSource:
			return PhotonPersistentDiskVolumeSource{V: v}
		case core.PhotonPersistentDiskVolumeSource:
			return PhotonPersistentDiskVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	PhotonPersistentDiskVolumeSource_attrs = setFieldTypes(t, PhotonPersistentDiskVolumeSource_fields, PhotonPersistentDiskVolumeSource_inline)
	Library["PhotonPersistentDiskVolumeSource"] = skylark.NewBuiltin("PhotonPersistentDiskVolumeSource", createPhotonPersistentDiskVolumeSource)
}

func createPhotonPersistentDiskVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := PhotonPersistentDiskVolumeSource{V: &core.PhotonPersistentDiskVolumeSource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t PhotonPersistentDiskVolumeSource) Underlying() interface{} { return t.V }
func (t PhotonPersistentDiskVolumeSource) DeepCopy() boxed {
	return PhotonPersistentDiskVolumeSource{V: t.V.DeepCopy()}
}
func (t PhotonPersistentDiskVolumeSource) Package() util.Package { return util.Core }
func (t PhotonPersistentDiskVolumeSource) Type() string {
	return "k8s_core_PhotonPersistentDiskVolumeSource"
}
func (t PhotonPersistentDiskVolumeSource) String() string        { return t.V.String() }
func (t PhotonPersistentDiskVolumeSource) Freeze()               {} // TODO
func (t PhotonPersistentDiskVolumeSource) Truth() skylark.Bool   { return skylark.True }
func (t PhotonPersistentDiskVolumeSource) Hash() (uint32, error) { return 0, unhashable(t.Type()) }
func (t PhotonPersistentDiskVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PhotonPersistentDiskVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PhotonPersistentDiskVolumeSource) AttrNames() []string {
	return PhotonPersistentDiskVolumeSource_attrs
}
func (t PhotonPersistentDiskVolumeSource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, PhotonPersistentDiskVolumeSource_fields, PhotonPersistentDiskVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t PhotonPersistentDiskVolumeSource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, PhotonPersistentDiskVolumeSource_fields, PhotonPersistentDiskVolumeSource_inline)
}

type Pod struct {
	V *core.Pod
}

var (
	_ boxed = (*Pod)(nil)

	Pod_fields = map[string]util.FieldSpec{}
	Pod_inline = map[string]util.FieldSpec{}
	Pod_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.Pod)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.Pod:
			return Pod{V: v}
		case core.Pod:
			return Pod{V: &v}
		default:
			return skylark.None
		}
	}
	Pod_attrs = setFieldTypes(t, Pod_fields, Pod_inline)
	Library["Pod"] = skylark.NewBuiltin("Pod", createPod)
}

func createPod(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := Pod{V: &core.Pod{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t Pod) Underlying() interface{} { return t.V }
func (t Pod) DeepCopy() boxed         { return Pod{V: t.V.DeepCopy()} }
func (t Pod) Package() util.Package   { return util.Core }
func (t Pod) Type() string            { return "k8s_core_Pod" }
func (t Pod) String() string          { return t.V.String() }
func (t Pod) Freeze()                 {} // TODO
func (t Pod) Truth() skylark.Bool     { return skylark.True }
func (t Pod) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t Pod) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*Pod)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t Pod) AttrNames() []string { return Pod_attrs }
func (t Pod) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, Pod_fields, Pod_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t Pod) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, Pod_fields, Pod_inline)
}

type PodAffinity struct {
	V *core.PodAffinity
}

var (
	_ boxed = (*PodAffinity)(nil)

	PodAffinity_fields = map[string]util.FieldSpec{}
	PodAffinity_inline = map[string]util.FieldSpec{}
	PodAffinity_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.PodAffinity)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.PodAffinity:
			return PodAffinity{V: v}
		case core.PodAffinity:
			return PodAffinity{V: &v}
		default:
			return skylark.None
		}
	}
	PodAffinity_attrs = setFieldTypes(t, PodAffinity_fields, PodAffinity_inline)
	Library["PodAffinity"] = skylark.NewBuiltin("PodAffinity", createPodAffinity)
}

func createPodAffinity(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := PodAffinity{V: &core.PodAffinity{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t PodAffinity) Underlying() interface{} { return t.V }
func (t PodAffinity) DeepCopy() boxed         { return PodAffinity{V: t.V.DeepCopy()} }
func (t PodAffinity) Package() util.Package   { return util.Core }
func (t PodAffinity) Type() string            { return "k8s_core_PodAffinity" }
func (t PodAffinity) String() string          { return t.V.String() }
func (t PodAffinity) Freeze()                 {} // TODO
func (t PodAffinity) Truth() skylark.Bool     { return skylark.True }
func (t PodAffinity) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t PodAffinity) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PodAffinity)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PodAffinity) AttrNames() []string { return PodAffinity_attrs }
func (t PodAffinity) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, PodAffinity_fields, PodAffinity_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t PodAffinity) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, PodAffinity_fields, PodAffinity_inline)
}

type PodAffinityTerm struct {
	V *core.PodAffinityTerm
}

var (
	_ boxed = (*PodAffinityTerm)(nil)

	PodAffinityTerm_fields = map[string]util.FieldSpec{}
	PodAffinityTerm_inline = map[string]util.FieldSpec{}
	PodAffinityTerm_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.PodAffinityTerm)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.PodAffinityTerm:
			return PodAffinityTerm{V: v}
		case core.PodAffinityTerm:
			return PodAffinityTerm{V: &v}
		default:
			return skylark.None
		}
	}
	PodAffinityTerm_attrs = setFieldTypes(t, PodAffinityTerm_fields, PodAffinityTerm_inline)
	Library["PodAffinityTerm"] = skylark.NewBuiltin("PodAffinityTerm", createPodAffinityTerm)
}

func createPodAffinityTerm(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := PodAffinityTerm{V: &core.PodAffinityTerm{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t PodAffinityTerm) Underlying() interface{} { return t.V }
func (t PodAffinityTerm) DeepCopy() boxed         { return PodAffinityTerm{V: t.V.DeepCopy()} }
func (t PodAffinityTerm) Package() util.Package   { return util.Core }
func (t PodAffinityTerm) Type() string            { return "k8s_core_PodAffinityTerm" }
func (t PodAffinityTerm) String() string          { return t.V.String() }
func (t PodAffinityTerm) Freeze()                 {} // TODO
func (t PodAffinityTerm) Truth() skylark.Bool     { return skylark.True }
func (t PodAffinityTerm) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t PodAffinityTerm) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PodAffinityTerm)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PodAffinityTerm) AttrNames() []string { return PodAffinityTerm_attrs }
func (t PodAffinityTerm) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, PodAffinityTerm_fields, PodAffinityTerm_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t PodAffinityTerm) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, PodAffinityTerm_fields, PodAffinityTerm_inline)
}

type PodAntiAffinity struct {
	V *core.PodAntiAffinity
}

var (
	_ boxed = (*PodAntiAffinity)(nil)

	PodAntiAffinity_fields = map[string]util.FieldSpec{}
	PodAntiAffinity_inline = map[string]util.FieldSpec{}
	PodAntiAffinity_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.PodAntiAffinity)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.PodAntiAffinity:
			return PodAntiAffinity{V: v}
		case core.PodAntiAffinity:
			return PodAntiAffinity{V: &v}
		default:
			return skylark.None
		}
	}
	PodAntiAffinity_attrs = setFieldTypes(t, PodAntiAffinity_fields, PodAntiAffinity_inline)
	Library["PodAntiAffinity"] = skylark.NewBuiltin("PodAntiAffinity", createPodAntiAffinity)
}

func createPodAntiAffinity(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := PodAntiAffinity{V: &core.PodAntiAffinity{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t PodAntiAffinity) Underlying() interface{} { return t.V }
func (t PodAntiAffinity) DeepCopy() boxed         { return PodAntiAffinity{V: t.V.DeepCopy()} }
func (t PodAntiAffinity) Package() util.Package   { return util.Core }
func (t PodAntiAffinity) Type() string            { return "k8s_core_PodAntiAffinity" }
func (t PodAntiAffinity) String() string          { return t.V.String() }
func (t PodAntiAffinity) Freeze()                 {} // TODO
func (t PodAntiAffinity) Truth() skylark.Bool     { return skylark.True }
func (t PodAntiAffinity) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t PodAntiAffinity) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PodAntiAffinity)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PodAntiAffinity) AttrNames() []string { return PodAntiAffinity_attrs }
func (t PodAntiAffinity) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, PodAntiAffinity_fields, PodAntiAffinity_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t PodAntiAffinity) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, PodAntiAffinity_fields, PodAntiAffinity_inline)
}

type PodAttachOptions struct {
	V *core.PodAttachOptions
}

var (
	_ boxed = (*PodAttachOptions)(nil)

	PodAttachOptions_fields = map[string]util.FieldSpec{}
	PodAttachOptions_inline = map[string]util.FieldSpec{}
	PodAttachOptions_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.PodAttachOptions)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.PodAttachOptions:
			return PodAttachOptions{V: v}
		case core.PodAttachOptions:
			return PodAttachOptions{V: &v}
		default:
			return skylark.None
		}
	}
	PodAttachOptions_attrs = setFieldTypes(t, PodAttachOptions_fields, PodAttachOptions_inline)
	Library["PodAttachOptions"] = skylark.NewBuiltin("PodAttachOptions", createPodAttachOptions)
}

func createPodAttachOptions(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := PodAttachOptions{V: &core.PodAttachOptions{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t PodAttachOptions) Underlying() interface{} { return t.V }
func (t PodAttachOptions) DeepCopy() boxed         { return PodAttachOptions{V: t.V.DeepCopy()} }
func (t PodAttachOptions) Package() util.Package   { return util.Core }
func (t PodAttachOptions) Type() string            { return "k8s_core_PodAttachOptions" }
func (t PodAttachOptions) String() string          { return t.V.String() }
func (t PodAttachOptions) Freeze()                 {} // TODO
func (t PodAttachOptions) Truth() skylark.Bool     { return skylark.True }
func (t PodAttachOptions) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t PodAttachOptions) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PodAttachOptions)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PodAttachOptions) AttrNames() []string { return PodAttachOptions_attrs }
func (t PodAttachOptions) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, PodAttachOptions_fields, PodAttachOptions_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t PodAttachOptions) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, PodAttachOptions_fields, PodAttachOptions_inline)
}

type PodCondition struct {
	V *core.PodCondition
}

var (
	_ boxed = (*PodCondition)(nil)

	PodCondition_fields = map[string]util.FieldSpec{}
	PodCondition_inline = map[string]util.FieldSpec{}
	PodCondition_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.PodCondition)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.PodCondition:
			return PodCondition{V: v}
		case core.PodCondition:
			return PodCondition{V: &v}
		default:
			return skylark.None
		}
	}
	PodCondition_attrs = setFieldTypes(t, PodCondition_fields, PodCondition_inline)
	Library["PodCondition"] = skylark.NewBuiltin("PodCondition", createPodCondition)
}

func createPodCondition(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := PodCondition{V: &core.PodCondition{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t PodCondition) Underlying() interface{} { return t.V }
func (t PodCondition) DeepCopy() boxed         { return PodCondition{V: t.V.DeepCopy()} }
func (t PodCondition) Package() util.Package   { return util.Core }
func (t PodCondition) Type() string            { return "k8s_core_PodCondition" }
func (t PodCondition) String() string          { return t.V.String() }
func (t PodCondition) Freeze()                 {} // TODO
func (t PodCondition) Truth() skylark.Bool     { return skylark.True }
func (t PodCondition) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t PodCondition) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PodCondition)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PodCondition) AttrNames() []string { return PodCondition_attrs }
func (t PodCondition) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, PodCondition_fields, PodCondition_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t PodCondition) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, PodCondition_fields, PodCondition_inline)
}

type PodDNSConfig struct {
	V *core.PodDNSConfig
}

var (
	_ boxed = (*PodDNSConfig)(nil)

	PodDNSConfig_fields = map[string]util.FieldSpec{}
	PodDNSConfig_inline = map[string]util.FieldSpec{}
	PodDNSConfig_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.PodDNSConfig)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.PodDNSConfig:
			return PodDNSConfig{V: v}
		case core.PodDNSConfig:
			return PodDNSConfig{V: &v}
		default:
			return skylark.None
		}
	}
	PodDNSConfig_attrs = setFieldTypes(t, PodDNSConfig_fields, PodDNSConfig_inline)
	Library["PodDNSConfig"] = skylark.NewBuiltin("PodDNSConfig", createPodDNSConfig)
}

func createPodDNSConfig(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := PodDNSConfig{V: &core.PodDNSConfig{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t PodDNSConfig) Underlying() interface{} { return t.V }
func (t PodDNSConfig) DeepCopy() boxed         { return PodDNSConfig{V: t.V.DeepCopy()} }
func (t PodDNSConfig) Package() util.Package   { return util.Core }
func (t PodDNSConfig) Type() string            { return "k8s_core_PodDNSConfig" }
func (t PodDNSConfig) String() string          { return t.V.String() }
func (t PodDNSConfig) Freeze()                 {} // TODO
func (t PodDNSConfig) Truth() skylark.Bool     { return skylark.True }
func (t PodDNSConfig) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t PodDNSConfig) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PodDNSConfig)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PodDNSConfig) AttrNames() []string { return PodDNSConfig_attrs }
func (t PodDNSConfig) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, PodDNSConfig_fields, PodDNSConfig_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t PodDNSConfig) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, PodDNSConfig_fields, PodDNSConfig_inline)
}

type PodDNSConfigOption struct {
	V *core.PodDNSConfigOption
}

var (
	_ boxed = (*PodDNSConfigOption)(nil)

	PodDNSConfigOption_fields = map[string]util.FieldSpec{}
	PodDNSConfigOption_inline = map[string]util.FieldSpec{}
	PodDNSConfigOption_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.PodDNSConfigOption)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.PodDNSConfigOption:
			return PodDNSConfigOption{V: v}
		case core.PodDNSConfigOption:
			return PodDNSConfigOption{V: &v}
		default:
			return skylark.None
		}
	}
	PodDNSConfigOption_attrs = setFieldTypes(t, PodDNSConfigOption_fields, PodDNSConfigOption_inline)
	Library["PodDNSConfigOption"] = skylark.NewBuiltin("PodDNSConfigOption", createPodDNSConfigOption)
}

func createPodDNSConfigOption(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := PodDNSConfigOption{V: &core.PodDNSConfigOption{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t PodDNSConfigOption) Underlying() interface{} { return t.V }
func (t PodDNSConfigOption) DeepCopy() boxed         { return PodDNSConfigOption{V: t.V.DeepCopy()} }
func (t PodDNSConfigOption) Package() util.Package   { return util.Core }
func (t PodDNSConfigOption) Type() string            { return "k8s_core_PodDNSConfigOption" }
func (t PodDNSConfigOption) String() string          { return t.V.String() }
func (t PodDNSConfigOption) Freeze()                 {} // TODO
func (t PodDNSConfigOption) Truth() skylark.Bool     { return skylark.True }
func (t PodDNSConfigOption) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t PodDNSConfigOption) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PodDNSConfigOption)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PodDNSConfigOption) AttrNames() []string { return PodDNSConfigOption_attrs }
func (t PodDNSConfigOption) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, PodDNSConfigOption_fields, PodDNSConfigOption_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t PodDNSConfigOption) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, PodDNSConfigOption_fields, PodDNSConfigOption_inline)
}

type PodExecOptions struct {
	V *core.PodExecOptions
}

var (
	_ boxed = (*PodExecOptions)(nil)

	PodExecOptions_fields = map[string]util.FieldSpec{}
	PodExecOptions_inline = map[string]util.FieldSpec{}
	PodExecOptions_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.PodExecOptions)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.PodExecOptions:
			return PodExecOptions{V: v}
		case core.PodExecOptions:
			return PodExecOptions{V: &v}
		default:
			return skylark.None
		}
	}
	PodExecOptions_attrs = setFieldTypes(t, PodExecOptions_fields, PodExecOptions_inline)
	Library["PodExecOptions"] = skylark.NewBuiltin("PodExecOptions", createPodExecOptions)
}

func createPodExecOptions(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := PodExecOptions{V: &core.PodExecOptions{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t PodExecOptions) Underlying() interface{} { return t.V }
func (t PodExecOptions) DeepCopy() boxed         { return PodExecOptions{V: t.V.DeepCopy()} }
func (t PodExecOptions) Package() util.Package   { return util.Core }
func (t PodExecOptions) Type() string            { return "k8s_core_PodExecOptions" }
func (t PodExecOptions) String() string          { return t.V.String() }
func (t PodExecOptions) Freeze()                 {} // TODO
func (t PodExecOptions) Truth() skylark.Bool     { return skylark.True }
func (t PodExecOptions) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t PodExecOptions) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PodExecOptions)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PodExecOptions) AttrNames() []string { return PodExecOptions_attrs }
func (t PodExecOptions) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, PodExecOptions_fields, PodExecOptions_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t PodExecOptions) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, PodExecOptions_fields, PodExecOptions_inline)
}

type PodList struct {
	V *core.PodList
}

var (
	_ boxed = (*PodList)(nil)

	PodList_fields = map[string]util.FieldSpec{}
	PodList_inline = map[string]util.FieldSpec{}
	PodList_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.PodList)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.PodList:
			return PodList{V: v}
		case core.PodList:
			return PodList{V: &v}
		default:
			return skylark.None
		}
	}
	PodList_attrs = setFieldTypes(t, PodList_fields, PodList_inline)
	Library["PodList"] = skylark.NewBuiltin("PodList", createPodList)
}

func createPodList(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := PodList{V: &core.PodList{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t PodList) Underlying() interface{} { return t.V }
func (t PodList) DeepCopy() boxed         { return PodList{V: t.V.DeepCopy()} }
func (t PodList) Package() util.Package   { return util.Core }
func (t PodList) Type() string            { return "k8s_core_PodList" }
func (t PodList) String() string          { return t.V.String() }
func (t PodList) Freeze()                 {} // TODO
func (t PodList) Truth() skylark.Bool     { return skylark.True }
func (t PodList) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t PodList) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PodList)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PodList) AttrNames() []string { return PodList_attrs }
func (t PodList) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, PodList_fields, PodList_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t PodList) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, PodList_fields, PodList_inline)
}

type PodLogOptions struct {
	V *core.PodLogOptions
}

var (
	_ boxed = (*PodLogOptions)(nil)

	PodLogOptions_fields = map[string]util.FieldSpec{}
	PodLogOptions_inline = map[string]util.FieldSpec{}
	PodLogOptions_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.PodLogOptions)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.PodLogOptions:
			return PodLogOptions{V: v}
		case core.PodLogOptions:
			return PodLogOptions{V: &v}
		default:
			return skylark.None
		}
	}
	PodLogOptions_attrs = setFieldTypes(t, PodLogOptions_fields, PodLogOptions_inline)
	Library["PodLogOptions"] = skylark.NewBuiltin("PodLogOptions", createPodLogOptions)
}

func createPodLogOptions(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := PodLogOptions{V: &core.PodLogOptions{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t PodLogOptions) Underlying() interface{} { return t.V }
func (t PodLogOptions) DeepCopy() boxed         { return PodLogOptions{V: t.V.DeepCopy()} }
func (t PodLogOptions) Package() util.Package   { return util.Core }
func (t PodLogOptions) Type() string            { return "k8s_core_PodLogOptions" }
func (t PodLogOptions) String() string          { return t.V.String() }
func (t PodLogOptions) Freeze()                 {} // TODO
func (t PodLogOptions) Truth() skylark.Bool     { return skylark.True }
func (t PodLogOptions) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t PodLogOptions) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PodLogOptions)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PodLogOptions) AttrNames() []string { return PodLogOptions_attrs }
func (t PodLogOptions) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, PodLogOptions_fields, PodLogOptions_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t PodLogOptions) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, PodLogOptions_fields, PodLogOptions_inline)
}

type PodPortForwardOptions struct {
	V *core.PodPortForwardOptions
}

var (
	_ boxed = (*PodPortForwardOptions)(nil)

	PodPortForwardOptions_fields = map[string]util.FieldSpec{}
	PodPortForwardOptions_inline = map[string]util.FieldSpec{}
	PodPortForwardOptions_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.PodPortForwardOptions)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.PodPortForwardOptions:
			return PodPortForwardOptions{V: v}
		case core.PodPortForwardOptions:
			return PodPortForwardOptions{V: &v}
		default:
			return skylark.None
		}
	}
	PodPortForwardOptions_attrs = setFieldTypes(t, PodPortForwardOptions_fields, PodPortForwardOptions_inline)
	Library["PodPortForwardOptions"] = skylark.NewBuiltin("PodPortForwardOptions", createPodPortForwardOptions)
}

func createPodPortForwardOptions(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := PodPortForwardOptions{V: &core.PodPortForwardOptions{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t PodPortForwardOptions) Underlying() interface{} { return t.V }
func (t PodPortForwardOptions) DeepCopy() boxed         { return PodPortForwardOptions{V: t.V.DeepCopy()} }
func (t PodPortForwardOptions) Package() util.Package   { return util.Core }
func (t PodPortForwardOptions) Type() string            { return "k8s_core_PodPortForwardOptions" }
func (t PodPortForwardOptions) String() string          { return t.V.String() }
func (t PodPortForwardOptions) Freeze()                 {} // TODO
func (t PodPortForwardOptions) Truth() skylark.Bool     { return skylark.True }
func (t PodPortForwardOptions) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t PodPortForwardOptions) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PodPortForwardOptions)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PodPortForwardOptions) AttrNames() []string { return PodPortForwardOptions_attrs }
func (t PodPortForwardOptions) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, PodPortForwardOptions_fields, PodPortForwardOptions_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t PodPortForwardOptions) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, PodPortForwardOptions_fields, PodPortForwardOptions_inline)
}

type PodProxyOptions struct {
	V *core.PodProxyOptions
}

var (
	_ boxed = (*PodProxyOptions)(nil)

	PodProxyOptions_fields = map[string]util.FieldSpec{}
	PodProxyOptions_inline = map[string]util.FieldSpec{}
	PodProxyOptions_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.PodProxyOptions)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.PodProxyOptions:
			return PodProxyOptions{V: v}
		case core.PodProxyOptions:
			return PodProxyOptions{V: &v}
		default:
			return skylark.None
		}
	}
	PodProxyOptions_attrs = setFieldTypes(t, PodProxyOptions_fields, PodProxyOptions_inline)
	Library["PodProxyOptions"] = skylark.NewBuiltin("PodProxyOptions", createPodProxyOptions)
}

func createPodProxyOptions(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := PodProxyOptions{V: &core.PodProxyOptions{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t PodProxyOptions) Underlying() interface{} { return t.V }
func (t PodProxyOptions) DeepCopy() boxed         { return PodProxyOptions{V: t.V.DeepCopy()} }
func (t PodProxyOptions) Package() util.Package   { return util.Core }
func (t PodProxyOptions) Type() string            { return "k8s_core_PodProxyOptions" }
func (t PodProxyOptions) String() string          { return t.V.String() }
func (t PodProxyOptions) Freeze()                 {} // TODO
func (t PodProxyOptions) Truth() skylark.Bool     { return skylark.True }
func (t PodProxyOptions) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t PodProxyOptions) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PodProxyOptions)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PodProxyOptions) AttrNames() []string { return PodProxyOptions_attrs }
func (t PodProxyOptions) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, PodProxyOptions_fields, PodProxyOptions_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t PodProxyOptions) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, PodProxyOptions_fields, PodProxyOptions_inline)
}

type PodReadinessGate struct {
	V *core.PodReadinessGate
}

var (
	_ boxed = (*PodReadinessGate)(nil)

	PodReadinessGate_fields = map[string]util.FieldSpec{}
	PodReadinessGate_inline = map[string]util.FieldSpec{}
	PodReadinessGate_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.PodReadinessGate)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.PodReadinessGate:
			return PodReadinessGate{V: v}
		case core.PodReadinessGate:
			return PodReadinessGate{V: &v}
		default:
			return skylark.None
		}
	}
	PodReadinessGate_attrs = setFieldTypes(t, PodReadinessGate_fields, PodReadinessGate_inline)
	Library["PodReadinessGate"] = skylark.NewBuiltin("PodReadinessGate", createPodReadinessGate)
}

func createPodReadinessGate(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := PodReadinessGate{V: &core.PodReadinessGate{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t PodReadinessGate) Underlying() interface{} { return t.V }
func (t PodReadinessGate) DeepCopy() boxed         { return PodReadinessGate{V: t.V.DeepCopy()} }
func (t PodReadinessGate) Package() util.Package   { return util.Core }
func (t PodReadinessGate) Type() string            { return "k8s_core_PodReadinessGate" }
func (t PodReadinessGate) String() string          { return t.V.String() }
func (t PodReadinessGate) Freeze()                 {} // TODO
func (t PodReadinessGate) Truth() skylark.Bool     { return skylark.True }
func (t PodReadinessGate) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t PodReadinessGate) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PodReadinessGate)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PodReadinessGate) AttrNames() []string { return PodReadinessGate_attrs }
func (t PodReadinessGate) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, PodReadinessGate_fields, PodReadinessGate_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t PodReadinessGate) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, PodReadinessGate_fields, PodReadinessGate_inline)
}

type PodSecurityContext struct {
	V *core.PodSecurityContext
}

var (
	_ boxed = (*PodSecurityContext)(nil)

	PodSecurityContext_fields = map[string]util.FieldSpec{}
	PodSecurityContext_inline = map[string]util.FieldSpec{}
	PodSecurityContext_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.PodSecurityContext)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.PodSecurityContext:
			return PodSecurityContext{V: v}
		case core.PodSecurityContext:
			return PodSecurityContext{V: &v}
		default:
			return skylark.None
		}
	}
	PodSecurityContext_attrs = setFieldTypes(t, PodSecurityContext_fields, PodSecurityContext_inline)
	Library["PodSecurityContext"] = skylark.NewBuiltin("PodSecurityContext", createPodSecurityContext)
}

func createPodSecurityContext(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := PodSecurityContext{V: &core.PodSecurityContext{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t PodSecurityContext) Underlying() interface{} { return t.V }
func (t PodSecurityContext) DeepCopy() boxed         { return PodSecurityContext{V: t.V.DeepCopy()} }
func (t PodSecurityContext) Package() util.Package   { return util.Core }
func (t PodSecurityContext) Type() string            { return "k8s_core_PodSecurityContext" }
func (t PodSecurityContext) String() string          { return t.V.String() }
func (t PodSecurityContext) Freeze()                 {} // TODO
func (t PodSecurityContext) Truth() skylark.Bool     { return skylark.True }
func (t PodSecurityContext) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t PodSecurityContext) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PodSecurityContext)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PodSecurityContext) AttrNames() []string { return PodSecurityContext_attrs }
func (t PodSecurityContext) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, PodSecurityContext_fields, PodSecurityContext_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t PodSecurityContext) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, PodSecurityContext_fields, PodSecurityContext_inline)
}

type PodSignature struct {
	V *core.PodSignature
}

var (
	_ boxed = (*PodSignature)(nil)

	PodSignature_fields = map[string]util.FieldSpec{}
	PodSignature_inline = map[string]util.FieldSpec{}
	PodSignature_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.PodSignature)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.PodSignature:
			return PodSignature{V: v}
		case core.PodSignature:
			return PodSignature{V: &v}
		default:
			return skylark.None
		}
	}
	PodSignature_attrs = setFieldTypes(t, PodSignature_fields, PodSignature_inline)
	Library["PodSignature"] = skylark.NewBuiltin("PodSignature", createPodSignature)
}

func createPodSignature(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := PodSignature{V: &core.PodSignature{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t PodSignature) Underlying() interface{} { return t.V }
func (t PodSignature) DeepCopy() boxed         { return PodSignature{V: t.V.DeepCopy()} }
func (t PodSignature) Package() util.Package   { return util.Core }
func (t PodSignature) Type() string            { return "k8s_core_PodSignature" }
func (t PodSignature) String() string          { return t.V.String() }
func (t PodSignature) Freeze()                 {} // TODO
func (t PodSignature) Truth() skylark.Bool     { return skylark.True }
func (t PodSignature) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t PodSignature) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PodSignature)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PodSignature) AttrNames() []string { return PodSignature_attrs }
func (t PodSignature) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, PodSignature_fields, PodSignature_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t PodSignature) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, PodSignature_fields, PodSignature_inline)
}

type PodSpec struct {
	V *core.PodSpec
}

var (
	_ boxed = (*PodSpec)(nil)

	PodSpec_fields = map[string]util.FieldSpec{}
	PodSpec_inline = map[string]util.FieldSpec{}
	PodSpec_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.PodSpec)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.PodSpec:
			return PodSpec{V: v}
		case core.PodSpec:
			return PodSpec{V: &v}
		default:
			return skylark.None
		}
	}
	PodSpec_attrs = setFieldTypes(t, PodSpec_fields, PodSpec_inline)
	Library["PodSpec"] = skylark.NewBuiltin("PodSpec", createPodSpec)
}

func createPodSpec(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := PodSpec{V: &core.PodSpec{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t PodSpec) Underlying() interface{} { return t.V }
func (t PodSpec) DeepCopy() boxed         { return PodSpec{V: t.V.DeepCopy()} }
func (t PodSpec) Package() util.Package   { return util.Core }
func (t PodSpec) Type() string            { return "k8s_core_PodSpec" }
func (t PodSpec) String() string          { return t.V.String() }
func (t PodSpec) Freeze()                 {} // TODO
func (t PodSpec) Truth() skylark.Bool     { return skylark.True }
func (t PodSpec) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t PodSpec) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PodSpec)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PodSpec) AttrNames() []string { return PodSpec_attrs }
func (t PodSpec) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, PodSpec_fields, PodSpec_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t PodSpec) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, PodSpec_fields, PodSpec_inline)
}

type PodStatus struct {
	V *core.PodStatus
}

var (
	_ boxed = (*PodStatus)(nil)

	PodStatus_fields = map[string]util.FieldSpec{}
	PodStatus_inline = map[string]util.FieldSpec{}
	PodStatus_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.PodStatus)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.PodStatus:
			return PodStatus{V: v}
		case core.PodStatus:
			return PodStatus{V: &v}
		default:
			return skylark.None
		}
	}
	PodStatus_attrs = setFieldTypes(t, PodStatus_fields, PodStatus_inline)
	Library["PodStatus"] = skylark.NewBuiltin("PodStatus", createPodStatus)
}

func createPodStatus(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := PodStatus{V: &core.PodStatus{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t PodStatus) Underlying() interface{} { return t.V }
func (t PodStatus) DeepCopy() boxed         { return PodStatus{V: t.V.DeepCopy()} }
func (t PodStatus) Package() util.Package   { return util.Core }
func (t PodStatus) Type() string            { return "k8s_core_PodStatus" }
func (t PodStatus) String() string          { return t.V.String() }
func (t PodStatus) Freeze()                 {} // TODO
func (t PodStatus) Truth() skylark.Bool     { return skylark.True }
func (t PodStatus) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t PodStatus) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PodStatus)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PodStatus) AttrNames() []string { return PodStatus_attrs }
func (t PodStatus) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, PodStatus_fields, PodStatus_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t PodStatus) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, PodStatus_fields, PodStatus_inline)
}

type PodStatusResult struct {
	V *core.PodStatusResult
}

var (
	_ boxed = (*PodStatusResult)(nil)

	PodStatusResult_fields = map[string]util.FieldSpec{}
	PodStatusResult_inline = map[string]util.FieldSpec{}
	PodStatusResult_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.PodStatusResult)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.PodStatusResult:
			return PodStatusResult{V: v}
		case core.PodStatusResult:
			return PodStatusResult{V: &v}
		default:
			return skylark.None
		}
	}
	PodStatusResult_attrs = setFieldTypes(t, PodStatusResult_fields, PodStatusResult_inline)
	Library["PodStatusResult"] = skylark.NewBuiltin("PodStatusResult", createPodStatusResult)
}

func createPodStatusResult(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := PodStatusResult{V: &core.PodStatusResult{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t PodStatusResult) Underlying() interface{} { return t.V }
func (t PodStatusResult) DeepCopy() boxed         { return PodStatusResult{V: t.V.DeepCopy()} }
func (t PodStatusResult) Package() util.Package   { return util.Core }
func (t PodStatusResult) Type() string            { return "k8s_core_PodStatusResult" }
func (t PodStatusResult) String() string          { return t.V.String() }
func (t PodStatusResult) Freeze()                 {} // TODO
func (t PodStatusResult) Truth() skylark.Bool     { return skylark.True }
func (t PodStatusResult) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t PodStatusResult) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PodStatusResult)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PodStatusResult) AttrNames() []string { return PodStatusResult_attrs }
func (t PodStatusResult) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, PodStatusResult_fields, PodStatusResult_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t PodStatusResult) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, PodStatusResult_fields, PodStatusResult_inline)
}

type PodTemplate struct {
	V *core.PodTemplate
}

var (
	_ boxed = (*PodTemplate)(nil)

	PodTemplate_fields = map[string]util.FieldSpec{}
	PodTemplate_inline = map[string]util.FieldSpec{}
	PodTemplate_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.PodTemplate)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.PodTemplate:
			return PodTemplate{V: v}
		case core.PodTemplate:
			return PodTemplate{V: &v}
		default:
			return skylark.None
		}
	}
	PodTemplate_attrs = setFieldTypes(t, PodTemplate_fields, PodTemplate_inline)
	Library["PodTemplate"] = skylark.NewBuiltin("PodTemplate", createPodTemplate)
}

func createPodTemplate(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := PodTemplate{V: &core.PodTemplate{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t PodTemplate) Underlying() interface{} { return t.V }
func (t PodTemplate) DeepCopy() boxed         { return PodTemplate{V: t.V.DeepCopy()} }
func (t PodTemplate) Package() util.Package   { return util.Core }
func (t PodTemplate) Type() string            { return "k8s_core_PodTemplate" }
func (t PodTemplate) String() string          { return t.V.String() }
func (t PodTemplate) Freeze()                 {} // TODO
func (t PodTemplate) Truth() skylark.Bool     { return skylark.True }
func (t PodTemplate) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t PodTemplate) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PodTemplate)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PodTemplate) AttrNames() []string { return PodTemplate_attrs }
func (t PodTemplate) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, PodTemplate_fields, PodTemplate_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t PodTemplate) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, PodTemplate_fields, PodTemplate_inline)
}

type PodTemplateList struct {
	V *core.PodTemplateList
}

var (
	_ boxed = (*PodTemplateList)(nil)

	PodTemplateList_fields = map[string]util.FieldSpec{}
	PodTemplateList_inline = map[string]util.FieldSpec{}
	PodTemplateList_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.PodTemplateList)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.PodTemplateList:
			return PodTemplateList{V: v}
		case core.PodTemplateList:
			return PodTemplateList{V: &v}
		default:
			return skylark.None
		}
	}
	PodTemplateList_attrs = setFieldTypes(t, PodTemplateList_fields, PodTemplateList_inline)
	Library["PodTemplateList"] = skylark.NewBuiltin("PodTemplateList", createPodTemplateList)
}

func createPodTemplateList(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := PodTemplateList{V: &core.PodTemplateList{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t PodTemplateList) Underlying() interface{} { return t.V }
func (t PodTemplateList) DeepCopy() boxed         { return PodTemplateList{V: t.V.DeepCopy()} }
func (t PodTemplateList) Package() util.Package   { return util.Core }
func (t PodTemplateList) Type() string            { return "k8s_core_PodTemplateList" }
func (t PodTemplateList) String() string          { return t.V.String() }
func (t PodTemplateList) Freeze()                 {} // TODO
func (t PodTemplateList) Truth() skylark.Bool     { return skylark.True }
func (t PodTemplateList) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t PodTemplateList) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PodTemplateList)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PodTemplateList) AttrNames() []string { return PodTemplateList_attrs }
func (t PodTemplateList) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, PodTemplateList_fields, PodTemplateList_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t PodTemplateList) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, PodTemplateList_fields, PodTemplateList_inline)
}

type PodTemplateSpec struct {
	V *core.PodTemplateSpec
}

var (
	_ boxed = (*PodTemplateSpec)(nil)

	PodTemplateSpec_fields = map[string]util.FieldSpec{}
	PodTemplateSpec_inline = map[string]util.FieldSpec{}
	PodTemplateSpec_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.PodTemplateSpec)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.PodTemplateSpec:
			return PodTemplateSpec{V: v}
		case core.PodTemplateSpec:
			return PodTemplateSpec{V: &v}
		default:
			return skylark.None
		}
	}
	PodTemplateSpec_attrs = setFieldTypes(t, PodTemplateSpec_fields, PodTemplateSpec_inline)
	Library["PodTemplateSpec"] = skylark.NewBuiltin("PodTemplateSpec", createPodTemplateSpec)
}

func createPodTemplateSpec(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := PodTemplateSpec{V: &core.PodTemplateSpec{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t PodTemplateSpec) Underlying() interface{} { return t.V }
func (t PodTemplateSpec) DeepCopy() boxed         { return PodTemplateSpec{V: t.V.DeepCopy()} }
func (t PodTemplateSpec) Package() util.Package   { return util.Core }
func (t PodTemplateSpec) Type() string            { return "k8s_core_PodTemplateSpec" }
func (t PodTemplateSpec) String() string          { return t.V.String() }
func (t PodTemplateSpec) Freeze()                 {} // TODO
func (t PodTemplateSpec) Truth() skylark.Bool     { return skylark.True }
func (t PodTemplateSpec) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t PodTemplateSpec) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PodTemplateSpec)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PodTemplateSpec) AttrNames() []string { return PodTemplateSpec_attrs }
func (t PodTemplateSpec) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, PodTemplateSpec_fields, PodTemplateSpec_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t PodTemplateSpec) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, PodTemplateSpec_fields, PodTemplateSpec_inline)
}

type PortworxVolumeSource struct {
	V *core.PortworxVolumeSource
}

var (
	_ boxed = (*PortworxVolumeSource)(nil)

	PortworxVolumeSource_fields = map[string]util.FieldSpec{}
	PortworxVolumeSource_inline = map[string]util.FieldSpec{}
	PortworxVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.PortworxVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.PortworxVolumeSource:
			return PortworxVolumeSource{V: v}
		case core.PortworxVolumeSource:
			return PortworxVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	PortworxVolumeSource_attrs = setFieldTypes(t, PortworxVolumeSource_fields, PortworxVolumeSource_inline)
	Library["PortworxVolumeSource"] = skylark.NewBuiltin("PortworxVolumeSource", createPortworxVolumeSource)
}

func createPortworxVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := PortworxVolumeSource{V: &core.PortworxVolumeSource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t PortworxVolumeSource) Underlying() interface{} { return t.V }
func (t PortworxVolumeSource) DeepCopy() boxed         { return PortworxVolumeSource{V: t.V.DeepCopy()} }
func (t PortworxVolumeSource) Package() util.Package   { return util.Core }
func (t PortworxVolumeSource) Type() string            { return "k8s_core_PortworxVolumeSource" }
func (t PortworxVolumeSource) String() string          { return t.V.String() }
func (t PortworxVolumeSource) Freeze()                 {} // TODO
func (t PortworxVolumeSource) Truth() skylark.Bool     { return skylark.True }
func (t PortworxVolumeSource) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t PortworxVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PortworxVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PortworxVolumeSource) AttrNames() []string { return PortworxVolumeSource_attrs }
func (t PortworxVolumeSource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, PortworxVolumeSource_fields, PortworxVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t PortworxVolumeSource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, PortworxVolumeSource_fields, PortworxVolumeSource_inline)
}

type Preconditions struct {
	V *core.Preconditions
}

var (
	_ boxed = (*Preconditions)(nil)

	Preconditions_fields = map[string]util.FieldSpec{}
	Preconditions_inline = map[string]util.FieldSpec{}
	Preconditions_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.Preconditions)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.Preconditions:
			return Preconditions{V: v}
		case core.Preconditions:
			return Preconditions{V: &v}
		default:
			return skylark.None
		}
	}
	Preconditions_attrs = setFieldTypes(t, Preconditions_fields, Preconditions_inline)
	Library["Preconditions"] = skylark.NewBuiltin("Preconditions", createPreconditions)
}

func createPreconditions(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := Preconditions{V: &core.Preconditions{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t Preconditions) Underlying() interface{} { return t.V }
func (t Preconditions) DeepCopy() boxed         { return Preconditions{V: t.V.DeepCopy()} }
func (t Preconditions) Package() util.Package   { return util.Core }
func (t Preconditions) Type() string            { return "k8s_core_Preconditions" }
func (t Preconditions) String() string          { return t.V.String() }
func (t Preconditions) Freeze()                 {} // TODO
func (t Preconditions) Truth() skylark.Bool     { return skylark.True }
func (t Preconditions) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t Preconditions) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*Preconditions)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t Preconditions) AttrNames() []string { return Preconditions_attrs }
func (t Preconditions) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, Preconditions_fields, Preconditions_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t Preconditions) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, Preconditions_fields, Preconditions_inline)
}

type PreferAvoidPodsEntry struct {
	V *core.PreferAvoidPodsEntry
}

var (
	_ boxed = (*PreferAvoidPodsEntry)(nil)

	PreferAvoidPodsEntry_fields = map[string]util.FieldSpec{}
	PreferAvoidPodsEntry_inline = map[string]util.FieldSpec{}
	PreferAvoidPodsEntry_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.PreferAvoidPodsEntry)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.PreferAvoidPodsEntry:
			return PreferAvoidPodsEntry{V: v}
		case core.PreferAvoidPodsEntry:
			return PreferAvoidPodsEntry{V: &v}
		default:
			return skylark.None
		}
	}
	PreferAvoidPodsEntry_attrs = setFieldTypes(t, PreferAvoidPodsEntry_fields, PreferAvoidPodsEntry_inline)
	Library["PreferAvoidPodsEntry"] = skylark.NewBuiltin("PreferAvoidPodsEntry", createPreferAvoidPodsEntry)
}

func createPreferAvoidPodsEntry(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := PreferAvoidPodsEntry{V: &core.PreferAvoidPodsEntry{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t PreferAvoidPodsEntry) Underlying() interface{} { return t.V }
func (t PreferAvoidPodsEntry) DeepCopy() boxed         { return PreferAvoidPodsEntry{V: t.V.DeepCopy()} }
func (t PreferAvoidPodsEntry) Package() util.Package   { return util.Core }
func (t PreferAvoidPodsEntry) Type() string            { return "k8s_core_PreferAvoidPodsEntry" }
func (t PreferAvoidPodsEntry) String() string          { return t.V.String() }
func (t PreferAvoidPodsEntry) Freeze()                 {} // TODO
func (t PreferAvoidPodsEntry) Truth() skylark.Bool     { return skylark.True }
func (t PreferAvoidPodsEntry) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t PreferAvoidPodsEntry) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PreferAvoidPodsEntry)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PreferAvoidPodsEntry) AttrNames() []string { return PreferAvoidPodsEntry_attrs }
func (t PreferAvoidPodsEntry) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, PreferAvoidPodsEntry_fields, PreferAvoidPodsEntry_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t PreferAvoidPodsEntry) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, PreferAvoidPodsEntry_fields, PreferAvoidPodsEntry_inline)
}

type PreferredSchedulingTerm struct {
	V *core.PreferredSchedulingTerm
}

var (
	_ boxed = (*PreferredSchedulingTerm)(nil)

	PreferredSchedulingTerm_fields = map[string]util.FieldSpec{}
	PreferredSchedulingTerm_inline = map[string]util.FieldSpec{}
	PreferredSchedulingTerm_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.PreferredSchedulingTerm)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.PreferredSchedulingTerm:
			return PreferredSchedulingTerm{V: v}
		case core.PreferredSchedulingTerm:
			return PreferredSchedulingTerm{V: &v}
		default:
			return skylark.None
		}
	}
	PreferredSchedulingTerm_attrs = setFieldTypes(t, PreferredSchedulingTerm_fields, PreferredSchedulingTerm_inline)
	Library["PreferredSchedulingTerm"] = skylark.NewBuiltin("PreferredSchedulingTerm", createPreferredSchedulingTerm)
}

func createPreferredSchedulingTerm(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := PreferredSchedulingTerm{V: &core.PreferredSchedulingTerm{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t PreferredSchedulingTerm) Underlying() interface{} { return t.V }
func (t PreferredSchedulingTerm) DeepCopy() boxed         { return PreferredSchedulingTerm{V: t.V.DeepCopy()} }
func (t PreferredSchedulingTerm) Package() util.Package   { return util.Core }
func (t PreferredSchedulingTerm) Type() string            { return "k8s_core_PreferredSchedulingTerm" }
func (t PreferredSchedulingTerm) String() string          { return t.V.String() }
func (t PreferredSchedulingTerm) Freeze()                 {} // TODO
func (t PreferredSchedulingTerm) Truth() skylark.Bool     { return skylark.True }
func (t PreferredSchedulingTerm) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t PreferredSchedulingTerm) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PreferredSchedulingTerm)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PreferredSchedulingTerm) AttrNames() []string { return PreferredSchedulingTerm_attrs }
func (t PreferredSchedulingTerm) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, PreferredSchedulingTerm_fields, PreferredSchedulingTerm_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t PreferredSchedulingTerm) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, PreferredSchedulingTerm_fields, PreferredSchedulingTerm_inline)
}

type Probe struct {
	V *core.Probe
}

var (
	_ boxed = (*Probe)(nil)

	Probe_fields = map[string]util.FieldSpec{}
	Probe_inline = map[string]util.FieldSpec{}
	Probe_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.Probe)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.Probe:
			return Probe{V: v}
		case core.Probe:
			return Probe{V: &v}
		default:
			return skylark.None
		}
	}
	Probe_attrs = setFieldTypes(t, Probe_fields, Probe_inline)
	Library["Probe"] = skylark.NewBuiltin("Probe", createProbe)
}

func createProbe(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := Probe{V: &core.Probe{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t Probe) Underlying() interface{} { return t.V }
func (t Probe) DeepCopy() boxed         { return Probe{V: t.V.DeepCopy()} }
func (t Probe) Package() util.Package   { return util.Core }
func (t Probe) Type() string            { return "k8s_core_Probe" }
func (t Probe) String() string          { return t.V.String() }
func (t Probe) Freeze()                 {} // TODO
func (t Probe) Truth() skylark.Bool     { return skylark.True }
func (t Probe) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t Probe) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*Probe)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t Probe) AttrNames() []string { return Probe_attrs }
func (t Probe) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, Probe_fields, Probe_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t Probe) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, Probe_fields, Probe_inline)
}

type ProjectedVolumeSource struct {
	V *core.ProjectedVolumeSource
}

var (
	_ boxed = (*ProjectedVolumeSource)(nil)

	ProjectedVolumeSource_fields = map[string]util.FieldSpec{}
	ProjectedVolumeSource_inline = map[string]util.FieldSpec{}
	ProjectedVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.ProjectedVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.ProjectedVolumeSource:
			return ProjectedVolumeSource{V: v}
		case core.ProjectedVolumeSource:
			return ProjectedVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	ProjectedVolumeSource_attrs = setFieldTypes(t, ProjectedVolumeSource_fields, ProjectedVolumeSource_inline)
	Library["ProjectedVolumeSource"] = skylark.NewBuiltin("ProjectedVolumeSource", createProjectedVolumeSource)
}

func createProjectedVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ProjectedVolumeSource{V: &core.ProjectedVolumeSource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ProjectedVolumeSource) Underlying() interface{} { return t.V }
func (t ProjectedVolumeSource) DeepCopy() boxed         { return ProjectedVolumeSource{V: t.V.DeepCopy()} }
func (t ProjectedVolumeSource) Package() util.Package   { return util.Core }
func (t ProjectedVolumeSource) Type() string            { return "k8s_core_ProjectedVolumeSource" }
func (t ProjectedVolumeSource) String() string          { return t.V.String() }
func (t ProjectedVolumeSource) Freeze()                 {} // TODO
func (t ProjectedVolumeSource) Truth() skylark.Bool     { return skylark.True }
func (t ProjectedVolumeSource) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ProjectedVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ProjectedVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ProjectedVolumeSource) AttrNames() []string { return ProjectedVolumeSource_attrs }
func (t ProjectedVolumeSource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ProjectedVolumeSource_fields, ProjectedVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ProjectedVolumeSource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ProjectedVolumeSource_fields, ProjectedVolumeSource_inline)
}

type QuobyteVolumeSource struct {
	V *core.QuobyteVolumeSource
}

var (
	_ boxed = (*QuobyteVolumeSource)(nil)

	QuobyteVolumeSource_fields = map[string]util.FieldSpec{}
	QuobyteVolumeSource_inline = map[string]util.FieldSpec{}
	QuobyteVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.QuobyteVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.QuobyteVolumeSource:
			return QuobyteVolumeSource{V: v}
		case core.QuobyteVolumeSource:
			return QuobyteVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	QuobyteVolumeSource_attrs = setFieldTypes(t, QuobyteVolumeSource_fields, QuobyteVolumeSource_inline)
	Library["QuobyteVolumeSource"] = skylark.NewBuiltin("QuobyteVolumeSource", createQuobyteVolumeSource)
}

func createQuobyteVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := QuobyteVolumeSource{V: &core.QuobyteVolumeSource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t QuobyteVolumeSource) Underlying() interface{} { return t.V }
func (t QuobyteVolumeSource) DeepCopy() boxed         { return QuobyteVolumeSource{V: t.V.DeepCopy()} }
func (t QuobyteVolumeSource) Package() util.Package   { return util.Core }
func (t QuobyteVolumeSource) Type() string            { return "k8s_core_QuobyteVolumeSource" }
func (t QuobyteVolumeSource) String() string          { return t.V.String() }
func (t QuobyteVolumeSource) Freeze()                 {} // TODO
func (t QuobyteVolumeSource) Truth() skylark.Bool     { return skylark.True }
func (t QuobyteVolumeSource) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t QuobyteVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*QuobyteVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t QuobyteVolumeSource) AttrNames() []string { return QuobyteVolumeSource_attrs }
func (t QuobyteVolumeSource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, QuobyteVolumeSource_fields, QuobyteVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t QuobyteVolumeSource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, QuobyteVolumeSource_fields, QuobyteVolumeSource_inline)
}

type RBDPersistentVolumeSource struct {
	V *core.RBDPersistentVolumeSource
}

var (
	_ boxed = (*RBDPersistentVolumeSource)(nil)

	RBDPersistentVolumeSource_fields = map[string]util.FieldSpec{}
	RBDPersistentVolumeSource_inline = map[string]util.FieldSpec{}
	RBDPersistentVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.RBDPersistentVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.RBDPersistentVolumeSource:
			return RBDPersistentVolumeSource{V: v}
		case core.RBDPersistentVolumeSource:
			return RBDPersistentVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	RBDPersistentVolumeSource_attrs = setFieldTypes(t, RBDPersistentVolumeSource_fields, RBDPersistentVolumeSource_inline)
	Library["RBDPersistentVolumeSource"] = skylark.NewBuiltin("RBDPersistentVolumeSource", createRBDPersistentVolumeSource)
}

func createRBDPersistentVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := RBDPersistentVolumeSource{V: &core.RBDPersistentVolumeSource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t RBDPersistentVolumeSource) Underlying() interface{} { return t.V }
func (t RBDPersistentVolumeSource) DeepCopy() boxed {
	return RBDPersistentVolumeSource{V: t.V.DeepCopy()}
}
func (t RBDPersistentVolumeSource) Package() util.Package { return util.Core }
func (t RBDPersistentVolumeSource) Type() string          { return "k8s_core_RBDPersistentVolumeSource" }
func (t RBDPersistentVolumeSource) String() string        { return t.V.String() }
func (t RBDPersistentVolumeSource) Freeze()               {} // TODO
func (t RBDPersistentVolumeSource) Truth() skylark.Bool   { return skylark.True }
func (t RBDPersistentVolumeSource) Hash() (uint32, error) { return 0, unhashable(t.Type()) }
func (t RBDPersistentVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*RBDPersistentVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t RBDPersistentVolumeSource) AttrNames() []string { return RBDPersistentVolumeSource_attrs }
func (t RBDPersistentVolumeSource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, RBDPersistentVolumeSource_fields, RBDPersistentVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t RBDPersistentVolumeSource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, RBDPersistentVolumeSource_fields, RBDPersistentVolumeSource_inline)
}

type RBDVolumeSource struct {
	V *core.RBDVolumeSource
}

var (
	_ boxed = (*RBDVolumeSource)(nil)

	RBDVolumeSource_fields = map[string]util.FieldSpec{}
	RBDVolumeSource_inline = map[string]util.FieldSpec{}
	RBDVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.RBDVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.RBDVolumeSource:
			return RBDVolumeSource{V: v}
		case core.RBDVolumeSource:
			return RBDVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	RBDVolumeSource_attrs = setFieldTypes(t, RBDVolumeSource_fields, RBDVolumeSource_inline)
	Library["RBDVolumeSource"] = skylark.NewBuiltin("RBDVolumeSource", createRBDVolumeSource)
}

func createRBDVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := RBDVolumeSource{V: &core.RBDVolumeSource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t RBDVolumeSource) Underlying() interface{} { return t.V }
func (t RBDVolumeSource) DeepCopy() boxed         { return RBDVolumeSource{V: t.V.DeepCopy()} }
func (t RBDVolumeSource) Package() util.Package   { return util.Core }
func (t RBDVolumeSource) Type() string            { return "k8s_core_RBDVolumeSource" }
func (t RBDVolumeSource) String() string          { return t.V.String() }
func (t RBDVolumeSource) Freeze()                 {} // TODO
func (t RBDVolumeSource) Truth() skylark.Bool     { return skylark.True }
func (t RBDVolumeSource) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t RBDVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*RBDVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t RBDVolumeSource) AttrNames() []string { return RBDVolumeSource_attrs }
func (t RBDVolumeSource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, RBDVolumeSource_fields, RBDVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t RBDVolumeSource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, RBDVolumeSource_fields, RBDVolumeSource_inline)
}

type RangeAllocation struct {
	V *core.RangeAllocation
}

var (
	_ boxed = (*RangeAllocation)(nil)

	RangeAllocation_fields = map[string]util.FieldSpec{}
	RangeAllocation_inline = map[string]util.FieldSpec{}
	RangeAllocation_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.RangeAllocation)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.RangeAllocation:
			return RangeAllocation{V: v}
		case core.RangeAllocation:
			return RangeAllocation{V: &v}
		default:
			return skylark.None
		}
	}
	RangeAllocation_attrs = setFieldTypes(t, RangeAllocation_fields, RangeAllocation_inline)
	Library["RangeAllocation"] = skylark.NewBuiltin("RangeAllocation", createRangeAllocation)
}

func createRangeAllocation(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := RangeAllocation{V: &core.RangeAllocation{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t RangeAllocation) Underlying() interface{} { return t.V }
func (t RangeAllocation) DeepCopy() boxed         { return RangeAllocation{V: t.V.DeepCopy()} }
func (t RangeAllocation) Package() util.Package   { return util.Core }
func (t RangeAllocation) Type() string            { return "k8s_core_RangeAllocation" }
func (t RangeAllocation) String() string          { return t.V.String() }
func (t RangeAllocation) Freeze()                 {} // TODO
func (t RangeAllocation) Truth() skylark.Bool     { return skylark.True }
func (t RangeAllocation) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t RangeAllocation) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*RangeAllocation)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t RangeAllocation) AttrNames() []string { return RangeAllocation_attrs }
func (t RangeAllocation) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, RangeAllocation_fields, RangeAllocation_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t RangeAllocation) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, RangeAllocation_fields, RangeAllocation_inline)
}

type ReplicationController struct {
	V *core.ReplicationController
}

var (
	_ boxed = (*ReplicationController)(nil)

	ReplicationController_fields = map[string]util.FieldSpec{}
	ReplicationController_inline = map[string]util.FieldSpec{}
	ReplicationController_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.ReplicationController)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.ReplicationController:
			return ReplicationController{V: v}
		case core.ReplicationController:
			return ReplicationController{V: &v}
		default:
			return skylark.None
		}
	}
	ReplicationController_attrs = setFieldTypes(t, ReplicationController_fields, ReplicationController_inline)
	Library["ReplicationController"] = skylark.NewBuiltin("ReplicationController", createReplicationController)
}

func createReplicationController(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ReplicationController{V: &core.ReplicationController{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ReplicationController) Underlying() interface{} { return t.V }
func (t ReplicationController) DeepCopy() boxed         { return ReplicationController{V: t.V.DeepCopy()} }
func (t ReplicationController) Package() util.Package   { return util.Core }
func (t ReplicationController) Type() string            { return "k8s_core_ReplicationController" }
func (t ReplicationController) String() string          { return t.V.String() }
func (t ReplicationController) Freeze()                 {} // TODO
func (t ReplicationController) Truth() skylark.Bool     { return skylark.True }
func (t ReplicationController) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ReplicationController) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ReplicationController)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ReplicationController) AttrNames() []string { return ReplicationController_attrs }
func (t ReplicationController) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ReplicationController_fields, ReplicationController_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ReplicationController) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ReplicationController_fields, ReplicationController_inline)
}

type ReplicationControllerCondition struct {
	V *core.ReplicationControllerCondition
}

var (
	_ boxed = (*ReplicationControllerCondition)(nil)

	ReplicationControllerCondition_fields = map[string]util.FieldSpec{}
	ReplicationControllerCondition_inline = map[string]util.FieldSpec{}
	ReplicationControllerCondition_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.ReplicationControllerCondition)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.ReplicationControllerCondition:
			return ReplicationControllerCondition{V: v}
		case core.ReplicationControllerCondition:
			return ReplicationControllerCondition{V: &v}
		default:
			return skylark.None
		}
	}
	ReplicationControllerCondition_attrs = setFieldTypes(t, ReplicationControllerCondition_fields, ReplicationControllerCondition_inline)
	Library["ReplicationControllerCondition"] = skylark.NewBuiltin("ReplicationControllerCondition", createReplicationControllerCondition)
}

func createReplicationControllerCondition(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ReplicationControllerCondition{V: &core.ReplicationControllerCondition{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ReplicationControllerCondition) Underlying() interface{} { return t.V }
func (t ReplicationControllerCondition) DeepCopy() boxed {
	return ReplicationControllerCondition{V: t.V.DeepCopy()}
}
func (t ReplicationControllerCondition) Package() util.Package { return util.Core }
func (t ReplicationControllerCondition) Type() string {
	return "k8s_core_ReplicationControllerCondition"
}
func (t ReplicationControllerCondition) String() string        { return t.V.String() }
func (t ReplicationControllerCondition) Freeze()               {} // TODO
func (t ReplicationControllerCondition) Truth() skylark.Bool   { return skylark.True }
func (t ReplicationControllerCondition) Hash() (uint32, error) { return 0, unhashable(t.Type()) }
func (t ReplicationControllerCondition) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ReplicationControllerCondition)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ReplicationControllerCondition) AttrNames() []string {
	return ReplicationControllerCondition_attrs
}
func (t ReplicationControllerCondition) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ReplicationControllerCondition_fields, ReplicationControllerCondition_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ReplicationControllerCondition) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ReplicationControllerCondition_fields, ReplicationControllerCondition_inline)
}

type ReplicationControllerList struct {
	V *core.ReplicationControllerList
}

var (
	_ boxed = (*ReplicationControllerList)(nil)

	ReplicationControllerList_fields = map[string]util.FieldSpec{}
	ReplicationControllerList_inline = map[string]util.FieldSpec{}
	ReplicationControllerList_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.ReplicationControllerList)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.ReplicationControllerList:
			return ReplicationControllerList{V: v}
		case core.ReplicationControllerList:
			return ReplicationControllerList{V: &v}
		default:
			return skylark.None
		}
	}
	ReplicationControllerList_attrs = setFieldTypes(t, ReplicationControllerList_fields, ReplicationControllerList_inline)
	Library["ReplicationControllerList"] = skylark.NewBuiltin("ReplicationControllerList", createReplicationControllerList)
}

func createReplicationControllerList(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ReplicationControllerList{V: &core.ReplicationControllerList{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ReplicationControllerList) Underlying() interface{} { return t.V }
func (t ReplicationControllerList) DeepCopy() boxed {
	return ReplicationControllerList{V: t.V.DeepCopy()}
}
func (t ReplicationControllerList) Package() util.Package { return util.Core }
func (t ReplicationControllerList) Type() string          { return "k8s_core_ReplicationControllerList" }
func (t ReplicationControllerList) String() string        { return t.V.String() }
func (t ReplicationControllerList) Freeze()               {} // TODO
func (t ReplicationControllerList) Truth() skylark.Bool   { return skylark.True }
func (t ReplicationControllerList) Hash() (uint32, error) { return 0, unhashable(t.Type()) }
func (t ReplicationControllerList) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ReplicationControllerList)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ReplicationControllerList) AttrNames() []string { return ReplicationControllerList_attrs }
func (t ReplicationControllerList) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ReplicationControllerList_fields, ReplicationControllerList_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ReplicationControllerList) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ReplicationControllerList_fields, ReplicationControllerList_inline)
}

type ReplicationControllerSpec struct {
	V *core.ReplicationControllerSpec
}

var (
	_ boxed = (*ReplicationControllerSpec)(nil)

	ReplicationControllerSpec_fields = map[string]util.FieldSpec{}
	ReplicationControllerSpec_inline = map[string]util.FieldSpec{}
	ReplicationControllerSpec_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.ReplicationControllerSpec)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.ReplicationControllerSpec:
			return ReplicationControllerSpec{V: v}
		case core.ReplicationControllerSpec:
			return ReplicationControllerSpec{V: &v}
		default:
			return skylark.None
		}
	}
	ReplicationControllerSpec_attrs = setFieldTypes(t, ReplicationControllerSpec_fields, ReplicationControllerSpec_inline)
	Library["ReplicationControllerSpec"] = skylark.NewBuiltin("ReplicationControllerSpec", createReplicationControllerSpec)
}

func createReplicationControllerSpec(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ReplicationControllerSpec{V: &core.ReplicationControllerSpec{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ReplicationControllerSpec) Underlying() interface{} { return t.V }
func (t ReplicationControllerSpec) DeepCopy() boxed {
	return ReplicationControllerSpec{V: t.V.DeepCopy()}
}
func (t ReplicationControllerSpec) Package() util.Package { return util.Core }
func (t ReplicationControllerSpec) Type() string          { return "k8s_core_ReplicationControllerSpec" }
func (t ReplicationControllerSpec) String() string        { return t.V.String() }
func (t ReplicationControllerSpec) Freeze()               {} // TODO
func (t ReplicationControllerSpec) Truth() skylark.Bool   { return skylark.True }
func (t ReplicationControllerSpec) Hash() (uint32, error) { return 0, unhashable(t.Type()) }
func (t ReplicationControllerSpec) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ReplicationControllerSpec)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ReplicationControllerSpec) AttrNames() []string { return ReplicationControllerSpec_attrs }
func (t ReplicationControllerSpec) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ReplicationControllerSpec_fields, ReplicationControllerSpec_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ReplicationControllerSpec) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ReplicationControllerSpec_fields, ReplicationControllerSpec_inline)
}

type ReplicationControllerStatus struct {
	V *core.ReplicationControllerStatus
}

var (
	_ boxed = (*ReplicationControllerStatus)(nil)

	ReplicationControllerStatus_fields = map[string]util.FieldSpec{}
	ReplicationControllerStatus_inline = map[string]util.FieldSpec{}
	ReplicationControllerStatus_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.ReplicationControllerStatus)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.ReplicationControllerStatus:
			return ReplicationControllerStatus{V: v}
		case core.ReplicationControllerStatus:
			return ReplicationControllerStatus{V: &v}
		default:
			return skylark.None
		}
	}
	ReplicationControllerStatus_attrs = setFieldTypes(t, ReplicationControllerStatus_fields, ReplicationControllerStatus_inline)
	Library["ReplicationControllerStatus"] = skylark.NewBuiltin("ReplicationControllerStatus", createReplicationControllerStatus)
}

func createReplicationControllerStatus(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ReplicationControllerStatus{V: &core.ReplicationControllerStatus{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ReplicationControllerStatus) Underlying() interface{} { return t.V }
func (t ReplicationControllerStatus) DeepCopy() boxed {
	return ReplicationControllerStatus{V: t.V.DeepCopy()}
}
func (t ReplicationControllerStatus) Package() util.Package { return util.Core }
func (t ReplicationControllerStatus) Type() string          { return "k8s_core_ReplicationControllerStatus" }
func (t ReplicationControllerStatus) String() string        { return t.V.String() }
func (t ReplicationControllerStatus) Freeze()               {} // TODO
func (t ReplicationControllerStatus) Truth() skylark.Bool   { return skylark.True }
func (t ReplicationControllerStatus) Hash() (uint32, error) { return 0, unhashable(t.Type()) }
func (t ReplicationControllerStatus) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ReplicationControllerStatus)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ReplicationControllerStatus) AttrNames() []string { return ReplicationControllerStatus_attrs }
func (t ReplicationControllerStatus) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ReplicationControllerStatus_fields, ReplicationControllerStatus_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ReplicationControllerStatus) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ReplicationControllerStatus_fields, ReplicationControllerStatus_inline)
}

type ResourceFieldSelector struct {
	V *core.ResourceFieldSelector
}

var (
	_ boxed = (*ResourceFieldSelector)(nil)

	ResourceFieldSelector_fields = map[string]util.FieldSpec{}
	ResourceFieldSelector_inline = map[string]util.FieldSpec{}
	ResourceFieldSelector_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.ResourceFieldSelector)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.ResourceFieldSelector:
			return ResourceFieldSelector{V: v}
		case core.ResourceFieldSelector:
			return ResourceFieldSelector{V: &v}
		default:
			return skylark.None
		}
	}
	ResourceFieldSelector_attrs = setFieldTypes(t, ResourceFieldSelector_fields, ResourceFieldSelector_inline)
	Library["ResourceFieldSelector"] = skylark.NewBuiltin("ResourceFieldSelector", createResourceFieldSelector)
}

func createResourceFieldSelector(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ResourceFieldSelector{V: &core.ResourceFieldSelector{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ResourceFieldSelector) Underlying() interface{} { return t.V }
func (t ResourceFieldSelector) DeepCopy() boxed         { return ResourceFieldSelector{V: t.V.DeepCopy()} }
func (t ResourceFieldSelector) Package() util.Package   { return util.Core }
func (t ResourceFieldSelector) Type() string            { return "k8s_core_ResourceFieldSelector" }
func (t ResourceFieldSelector) String() string          { return t.V.String() }
func (t ResourceFieldSelector) Freeze()                 {} // TODO
func (t ResourceFieldSelector) Truth() skylark.Bool     { return skylark.True }
func (t ResourceFieldSelector) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ResourceFieldSelector) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ResourceFieldSelector)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ResourceFieldSelector) AttrNames() []string { return ResourceFieldSelector_attrs }
func (t ResourceFieldSelector) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ResourceFieldSelector_fields, ResourceFieldSelector_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ResourceFieldSelector) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ResourceFieldSelector_fields, ResourceFieldSelector_inline)
}

type ResourceQuota struct {
	V *core.ResourceQuota
}

var (
	_ boxed = (*ResourceQuota)(nil)

	ResourceQuota_fields = map[string]util.FieldSpec{}
	ResourceQuota_inline = map[string]util.FieldSpec{}
	ResourceQuota_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.ResourceQuota)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.ResourceQuota:
			return ResourceQuota{V: v}
		case core.ResourceQuota:
			return ResourceQuota{V: &v}
		default:
			return skylark.None
		}
	}
	ResourceQuota_attrs = setFieldTypes(t, ResourceQuota_fields, ResourceQuota_inline)
	Library["ResourceQuota"] = skylark.NewBuiltin("ResourceQuota", createResourceQuota)
}

func createResourceQuota(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ResourceQuota{V: &core.ResourceQuota{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ResourceQuota) Underlying() interface{} { return t.V }
func (t ResourceQuota) DeepCopy() boxed         { return ResourceQuota{V: t.V.DeepCopy()} }
func (t ResourceQuota) Package() util.Package   { return util.Core }
func (t ResourceQuota) Type() string            { return "k8s_core_ResourceQuota" }
func (t ResourceQuota) String() string          { return t.V.String() }
func (t ResourceQuota) Freeze()                 {} // TODO
func (t ResourceQuota) Truth() skylark.Bool     { return skylark.True }
func (t ResourceQuota) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ResourceQuota) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ResourceQuota)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ResourceQuota) AttrNames() []string { return ResourceQuota_attrs }
func (t ResourceQuota) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ResourceQuota_fields, ResourceQuota_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ResourceQuota) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ResourceQuota_fields, ResourceQuota_inline)
}

type ResourceQuotaList struct {
	V *core.ResourceQuotaList
}

var (
	_ boxed = (*ResourceQuotaList)(nil)

	ResourceQuotaList_fields = map[string]util.FieldSpec{}
	ResourceQuotaList_inline = map[string]util.FieldSpec{}
	ResourceQuotaList_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.ResourceQuotaList)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.ResourceQuotaList:
			return ResourceQuotaList{V: v}
		case core.ResourceQuotaList:
			return ResourceQuotaList{V: &v}
		default:
			return skylark.None
		}
	}
	ResourceQuotaList_attrs = setFieldTypes(t, ResourceQuotaList_fields, ResourceQuotaList_inline)
	Library["ResourceQuotaList"] = skylark.NewBuiltin("ResourceQuotaList", createResourceQuotaList)
}

func createResourceQuotaList(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ResourceQuotaList{V: &core.ResourceQuotaList{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ResourceQuotaList) Underlying() interface{} { return t.V }
func (t ResourceQuotaList) DeepCopy() boxed         { return ResourceQuotaList{V: t.V.DeepCopy()} }
func (t ResourceQuotaList) Package() util.Package   { return util.Core }
func (t ResourceQuotaList) Type() string            { return "k8s_core_ResourceQuotaList" }
func (t ResourceQuotaList) String() string          { return t.V.String() }
func (t ResourceQuotaList) Freeze()                 {} // TODO
func (t ResourceQuotaList) Truth() skylark.Bool     { return skylark.True }
func (t ResourceQuotaList) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ResourceQuotaList) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ResourceQuotaList)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ResourceQuotaList) AttrNames() []string { return ResourceQuotaList_attrs }
func (t ResourceQuotaList) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ResourceQuotaList_fields, ResourceQuotaList_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ResourceQuotaList) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ResourceQuotaList_fields, ResourceQuotaList_inline)
}

type ResourceQuotaSpec struct {
	V *core.ResourceQuotaSpec
}

var (
	_ boxed = (*ResourceQuotaSpec)(nil)

	ResourceQuotaSpec_fields = map[string]util.FieldSpec{}
	ResourceQuotaSpec_inline = map[string]util.FieldSpec{}
	ResourceQuotaSpec_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.ResourceQuotaSpec)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.ResourceQuotaSpec:
			return ResourceQuotaSpec{V: v}
		case core.ResourceQuotaSpec:
			return ResourceQuotaSpec{V: &v}
		default:
			return skylark.None
		}
	}
	ResourceQuotaSpec_attrs = setFieldTypes(t, ResourceQuotaSpec_fields, ResourceQuotaSpec_inline)
	Library["ResourceQuotaSpec"] = skylark.NewBuiltin("ResourceQuotaSpec", createResourceQuotaSpec)
}

func createResourceQuotaSpec(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ResourceQuotaSpec{V: &core.ResourceQuotaSpec{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ResourceQuotaSpec) Underlying() interface{} { return t.V }
func (t ResourceQuotaSpec) DeepCopy() boxed         { return ResourceQuotaSpec{V: t.V.DeepCopy()} }
func (t ResourceQuotaSpec) Package() util.Package   { return util.Core }
func (t ResourceQuotaSpec) Type() string            { return "k8s_core_ResourceQuotaSpec" }
func (t ResourceQuotaSpec) String() string          { return t.V.String() }
func (t ResourceQuotaSpec) Freeze()                 {} // TODO
func (t ResourceQuotaSpec) Truth() skylark.Bool     { return skylark.True }
func (t ResourceQuotaSpec) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ResourceQuotaSpec) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ResourceQuotaSpec)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ResourceQuotaSpec) AttrNames() []string { return ResourceQuotaSpec_attrs }
func (t ResourceQuotaSpec) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ResourceQuotaSpec_fields, ResourceQuotaSpec_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ResourceQuotaSpec) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ResourceQuotaSpec_fields, ResourceQuotaSpec_inline)
}

type ResourceQuotaStatus struct {
	V *core.ResourceQuotaStatus
}

var (
	_ boxed = (*ResourceQuotaStatus)(nil)

	ResourceQuotaStatus_fields = map[string]util.FieldSpec{}
	ResourceQuotaStatus_inline = map[string]util.FieldSpec{}
	ResourceQuotaStatus_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.ResourceQuotaStatus)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.ResourceQuotaStatus:
			return ResourceQuotaStatus{V: v}
		case core.ResourceQuotaStatus:
			return ResourceQuotaStatus{V: &v}
		default:
			return skylark.None
		}
	}
	ResourceQuotaStatus_attrs = setFieldTypes(t, ResourceQuotaStatus_fields, ResourceQuotaStatus_inline)
	Library["ResourceQuotaStatus"] = skylark.NewBuiltin("ResourceQuotaStatus", createResourceQuotaStatus)
}

func createResourceQuotaStatus(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ResourceQuotaStatus{V: &core.ResourceQuotaStatus{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ResourceQuotaStatus) Underlying() interface{} { return t.V }
func (t ResourceQuotaStatus) DeepCopy() boxed         { return ResourceQuotaStatus{V: t.V.DeepCopy()} }
func (t ResourceQuotaStatus) Package() util.Package   { return util.Core }
func (t ResourceQuotaStatus) Type() string            { return "k8s_core_ResourceQuotaStatus" }
func (t ResourceQuotaStatus) String() string          { return t.V.String() }
func (t ResourceQuotaStatus) Freeze()                 {} // TODO
func (t ResourceQuotaStatus) Truth() skylark.Bool     { return skylark.True }
func (t ResourceQuotaStatus) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ResourceQuotaStatus) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ResourceQuotaStatus)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ResourceQuotaStatus) AttrNames() []string { return ResourceQuotaStatus_attrs }
func (t ResourceQuotaStatus) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ResourceQuotaStatus_fields, ResourceQuotaStatus_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ResourceQuotaStatus) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ResourceQuotaStatus_fields, ResourceQuotaStatus_inline)
}

type ResourceRequirements struct {
	V *core.ResourceRequirements
}

var (
	_ boxed = (*ResourceRequirements)(nil)

	ResourceRequirements_fields = map[string]util.FieldSpec{}
	ResourceRequirements_inline = map[string]util.FieldSpec{}
	ResourceRequirements_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.ResourceRequirements)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.ResourceRequirements:
			return ResourceRequirements{V: v}
		case core.ResourceRequirements:
			return ResourceRequirements{V: &v}
		default:
			return skylark.None
		}
	}
	ResourceRequirements_attrs = setFieldTypes(t, ResourceRequirements_fields, ResourceRequirements_inline)
	Library["ResourceRequirements"] = skylark.NewBuiltin("ResourceRequirements", createResourceRequirements)
}

func createResourceRequirements(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ResourceRequirements{V: &core.ResourceRequirements{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ResourceRequirements) Underlying() interface{} { return t.V }
func (t ResourceRequirements) DeepCopy() boxed         { return ResourceRequirements{V: t.V.DeepCopy()} }
func (t ResourceRequirements) Package() util.Package   { return util.Core }
func (t ResourceRequirements) Type() string            { return "k8s_core_ResourceRequirements" }
func (t ResourceRequirements) String() string          { return t.V.String() }
func (t ResourceRequirements) Freeze()                 {} // TODO
func (t ResourceRequirements) Truth() skylark.Bool     { return skylark.True }
func (t ResourceRequirements) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ResourceRequirements) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ResourceRequirements)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ResourceRequirements) AttrNames() []string { return ResourceRequirements_attrs }
func (t ResourceRequirements) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ResourceRequirements_fields, ResourceRequirements_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ResourceRequirements) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ResourceRequirements_fields, ResourceRequirements_inline)
}

type SELinuxOptions struct {
	V *core.SELinuxOptions
}

var (
	_ boxed = (*SELinuxOptions)(nil)

	SELinuxOptions_fields = map[string]util.FieldSpec{}
	SELinuxOptions_inline = map[string]util.FieldSpec{}
	SELinuxOptions_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.SELinuxOptions)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.SELinuxOptions:
			return SELinuxOptions{V: v}
		case core.SELinuxOptions:
			return SELinuxOptions{V: &v}
		default:
			return skylark.None
		}
	}
	SELinuxOptions_attrs = setFieldTypes(t, SELinuxOptions_fields, SELinuxOptions_inline)
	Library["SELinuxOptions"] = skylark.NewBuiltin("SELinuxOptions", createSELinuxOptions)
}

func createSELinuxOptions(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := SELinuxOptions{V: &core.SELinuxOptions{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t SELinuxOptions) Underlying() interface{} { return t.V }
func (t SELinuxOptions) DeepCopy() boxed         { return SELinuxOptions{V: t.V.DeepCopy()} }
func (t SELinuxOptions) Package() util.Package   { return util.Core }
func (t SELinuxOptions) Type() string            { return "k8s_core_SELinuxOptions" }
func (t SELinuxOptions) String() string          { return t.V.String() }
func (t SELinuxOptions) Freeze()                 {} // TODO
func (t SELinuxOptions) Truth() skylark.Bool     { return skylark.True }
func (t SELinuxOptions) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t SELinuxOptions) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*SELinuxOptions)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t SELinuxOptions) AttrNames() []string { return SELinuxOptions_attrs }
func (t SELinuxOptions) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, SELinuxOptions_fields, SELinuxOptions_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t SELinuxOptions) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, SELinuxOptions_fields, SELinuxOptions_inline)
}

type ScaleIOPersistentVolumeSource struct {
	V *core.ScaleIOPersistentVolumeSource
}

var (
	_ boxed = (*ScaleIOPersistentVolumeSource)(nil)

	ScaleIOPersistentVolumeSource_fields = map[string]util.FieldSpec{}
	ScaleIOPersistentVolumeSource_inline = map[string]util.FieldSpec{}
	ScaleIOPersistentVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.ScaleIOPersistentVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.ScaleIOPersistentVolumeSource:
			return ScaleIOPersistentVolumeSource{V: v}
		case core.ScaleIOPersistentVolumeSource:
			return ScaleIOPersistentVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	ScaleIOPersistentVolumeSource_attrs = setFieldTypes(t, ScaleIOPersistentVolumeSource_fields, ScaleIOPersistentVolumeSource_inline)
	Library["ScaleIOPersistentVolumeSource"] = skylark.NewBuiltin("ScaleIOPersistentVolumeSource", createScaleIOPersistentVolumeSource)
}

func createScaleIOPersistentVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ScaleIOPersistentVolumeSource{V: &core.ScaleIOPersistentVolumeSource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ScaleIOPersistentVolumeSource) Underlying() interface{} { return t.V }
func (t ScaleIOPersistentVolumeSource) DeepCopy() boxed {
	return ScaleIOPersistentVolumeSource{V: t.V.DeepCopy()}
}
func (t ScaleIOPersistentVolumeSource) Package() util.Package { return util.Core }
func (t ScaleIOPersistentVolumeSource) Type() string          { return "k8s_core_ScaleIOPersistentVolumeSource" }
func (t ScaleIOPersistentVolumeSource) String() string        { return t.V.String() }
func (t ScaleIOPersistentVolumeSource) Freeze()               {} // TODO
func (t ScaleIOPersistentVolumeSource) Truth() skylark.Bool   { return skylark.True }
func (t ScaleIOPersistentVolumeSource) Hash() (uint32, error) { return 0, unhashable(t.Type()) }
func (t ScaleIOPersistentVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ScaleIOPersistentVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ScaleIOPersistentVolumeSource) AttrNames() []string {
	return ScaleIOPersistentVolumeSource_attrs
}
func (t ScaleIOPersistentVolumeSource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ScaleIOPersistentVolumeSource_fields, ScaleIOPersistentVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ScaleIOPersistentVolumeSource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ScaleIOPersistentVolumeSource_fields, ScaleIOPersistentVolumeSource_inline)
}

type ScaleIOVolumeSource struct {
	V *core.ScaleIOVolumeSource
}

var (
	_ boxed = (*ScaleIOVolumeSource)(nil)

	ScaleIOVolumeSource_fields = map[string]util.FieldSpec{}
	ScaleIOVolumeSource_inline = map[string]util.FieldSpec{}
	ScaleIOVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.ScaleIOVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.ScaleIOVolumeSource:
			return ScaleIOVolumeSource{V: v}
		case core.ScaleIOVolumeSource:
			return ScaleIOVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	ScaleIOVolumeSource_attrs = setFieldTypes(t, ScaleIOVolumeSource_fields, ScaleIOVolumeSource_inline)
	Library["ScaleIOVolumeSource"] = skylark.NewBuiltin("ScaleIOVolumeSource", createScaleIOVolumeSource)
}

func createScaleIOVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ScaleIOVolumeSource{V: &core.ScaleIOVolumeSource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ScaleIOVolumeSource) Underlying() interface{} { return t.V }
func (t ScaleIOVolumeSource) DeepCopy() boxed         { return ScaleIOVolumeSource{V: t.V.DeepCopy()} }
func (t ScaleIOVolumeSource) Package() util.Package   { return util.Core }
func (t ScaleIOVolumeSource) Type() string            { return "k8s_core_ScaleIOVolumeSource" }
func (t ScaleIOVolumeSource) String() string          { return t.V.String() }
func (t ScaleIOVolumeSource) Freeze()                 {} // TODO
func (t ScaleIOVolumeSource) Truth() skylark.Bool     { return skylark.True }
func (t ScaleIOVolumeSource) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ScaleIOVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ScaleIOVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ScaleIOVolumeSource) AttrNames() []string { return ScaleIOVolumeSource_attrs }
func (t ScaleIOVolumeSource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ScaleIOVolumeSource_fields, ScaleIOVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ScaleIOVolumeSource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ScaleIOVolumeSource_fields, ScaleIOVolumeSource_inline)
}

type ScopeSelector struct {
	V *core.ScopeSelector
}

var (
	_ boxed = (*ScopeSelector)(nil)

	ScopeSelector_fields = map[string]util.FieldSpec{}
	ScopeSelector_inline = map[string]util.FieldSpec{}
	ScopeSelector_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.ScopeSelector)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.ScopeSelector:
			return ScopeSelector{V: v}
		case core.ScopeSelector:
			return ScopeSelector{V: &v}
		default:
			return skylark.None
		}
	}
	ScopeSelector_attrs = setFieldTypes(t, ScopeSelector_fields, ScopeSelector_inline)
	Library["ScopeSelector"] = skylark.NewBuiltin("ScopeSelector", createScopeSelector)
}

func createScopeSelector(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ScopeSelector{V: &core.ScopeSelector{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ScopeSelector) Underlying() interface{} { return t.V }
func (t ScopeSelector) DeepCopy() boxed         { return ScopeSelector{V: t.V.DeepCopy()} }
func (t ScopeSelector) Package() util.Package   { return util.Core }
func (t ScopeSelector) Type() string            { return "k8s_core_ScopeSelector" }
func (t ScopeSelector) String() string          { return t.V.String() }
func (t ScopeSelector) Freeze()                 {} // TODO
func (t ScopeSelector) Truth() skylark.Bool     { return skylark.True }
func (t ScopeSelector) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ScopeSelector) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ScopeSelector)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ScopeSelector) AttrNames() []string { return ScopeSelector_attrs }
func (t ScopeSelector) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ScopeSelector_fields, ScopeSelector_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ScopeSelector) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ScopeSelector_fields, ScopeSelector_inline)
}

type ScopedResourceSelectorRequirement struct {
	V *core.ScopedResourceSelectorRequirement
}

var (
	_ boxed = (*ScopedResourceSelectorRequirement)(nil)

	ScopedResourceSelectorRequirement_fields = map[string]util.FieldSpec{}
	ScopedResourceSelectorRequirement_inline = map[string]util.FieldSpec{}
	ScopedResourceSelectorRequirement_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.ScopedResourceSelectorRequirement)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.ScopedResourceSelectorRequirement:
			return ScopedResourceSelectorRequirement{V: v}
		case core.ScopedResourceSelectorRequirement:
			return ScopedResourceSelectorRequirement{V: &v}
		default:
			return skylark.None
		}
	}
	ScopedResourceSelectorRequirement_attrs = setFieldTypes(t, ScopedResourceSelectorRequirement_fields, ScopedResourceSelectorRequirement_inline)
	Library["ScopedResourceSelectorRequirement"] = skylark.NewBuiltin("ScopedResourceSelectorRequirement", createScopedResourceSelectorRequirement)
}

func createScopedResourceSelectorRequirement(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ScopedResourceSelectorRequirement{V: &core.ScopedResourceSelectorRequirement{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ScopedResourceSelectorRequirement) Underlying() interface{} { return t.V }
func (t ScopedResourceSelectorRequirement) DeepCopy() boxed {
	return ScopedResourceSelectorRequirement{V: t.V.DeepCopy()}
}
func (t ScopedResourceSelectorRequirement) Package() util.Package { return util.Core }
func (t ScopedResourceSelectorRequirement) Type() string {
	return "k8s_core_ScopedResourceSelectorRequirement"
}
func (t ScopedResourceSelectorRequirement) String() string        { return t.V.String() }
func (t ScopedResourceSelectorRequirement) Freeze()               {} // TODO
func (t ScopedResourceSelectorRequirement) Truth() skylark.Bool   { return skylark.True }
func (t ScopedResourceSelectorRequirement) Hash() (uint32, error) { return 0, unhashable(t.Type()) }
func (t ScopedResourceSelectorRequirement) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ScopedResourceSelectorRequirement)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ScopedResourceSelectorRequirement) AttrNames() []string {
	return ScopedResourceSelectorRequirement_attrs
}
func (t ScopedResourceSelectorRequirement) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ScopedResourceSelectorRequirement_fields, ScopedResourceSelectorRequirement_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ScopedResourceSelectorRequirement) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ScopedResourceSelectorRequirement_fields, ScopedResourceSelectorRequirement_inline)
}

type Secret struct {
	V *core.Secret
}

var (
	_ boxed = (*Secret)(nil)

	Secret_fields = map[string]util.FieldSpec{}
	Secret_inline = map[string]util.FieldSpec{}
	Secret_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.Secret)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.Secret:
			return Secret{V: v}
		case core.Secret:
			return Secret{V: &v}
		default:
			return skylark.None
		}
	}
	Secret_attrs = setFieldTypes(t, Secret_fields, Secret_inline)
	Library["Secret"] = skylark.NewBuiltin("Secret", createSecret)
}

func createSecret(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := Secret{V: &core.Secret{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t Secret) Underlying() interface{} { return t.V }
func (t Secret) DeepCopy() boxed         { return Secret{V: t.V.DeepCopy()} }
func (t Secret) Package() util.Package   { return util.Core }
func (t Secret) Type() string            { return "k8s_core_Secret" }
func (t Secret) String() string          { return t.V.String() }
func (t Secret) Freeze()                 {} // TODO
func (t Secret) Truth() skylark.Bool     { return skylark.True }
func (t Secret) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t Secret) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*Secret)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t Secret) AttrNames() []string { return Secret_attrs }
func (t Secret) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, Secret_fields, Secret_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t Secret) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, Secret_fields, Secret_inline)
}

type SecretEnvSource struct {
	V *core.SecretEnvSource
}

var (
	_ boxed = (*SecretEnvSource)(nil)

	SecretEnvSource_fields = map[string]util.FieldSpec{}
	SecretEnvSource_inline = map[string]util.FieldSpec{}
	SecretEnvSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.SecretEnvSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.SecretEnvSource:
			return SecretEnvSource{V: v}
		case core.SecretEnvSource:
			return SecretEnvSource{V: &v}
		default:
			return skylark.None
		}
	}
	SecretEnvSource_attrs = setFieldTypes(t, SecretEnvSource_fields, SecretEnvSource_inline)
	Library["SecretEnvSource"] = skylark.NewBuiltin("SecretEnvSource", createSecretEnvSource)
}

func createSecretEnvSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := SecretEnvSource{V: &core.SecretEnvSource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t SecretEnvSource) Underlying() interface{} { return t.V }
func (t SecretEnvSource) DeepCopy() boxed         { return SecretEnvSource{V: t.V.DeepCopy()} }
func (t SecretEnvSource) Package() util.Package   { return util.Core }
func (t SecretEnvSource) Type() string            { return "k8s_core_SecretEnvSource" }
func (t SecretEnvSource) String() string          { return t.V.String() }
func (t SecretEnvSource) Freeze()                 {} // TODO
func (t SecretEnvSource) Truth() skylark.Bool     { return skylark.True }
func (t SecretEnvSource) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t SecretEnvSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*SecretEnvSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t SecretEnvSource) AttrNames() []string { return SecretEnvSource_attrs }
func (t SecretEnvSource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, SecretEnvSource_fields, SecretEnvSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t SecretEnvSource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, SecretEnvSource_fields, SecretEnvSource_inline)
}

type SecretKeySelector struct {
	V *core.SecretKeySelector
}

var (
	_ boxed = (*SecretKeySelector)(nil)

	SecretKeySelector_fields = map[string]util.FieldSpec{}
	SecretKeySelector_inline = map[string]util.FieldSpec{}
	SecretKeySelector_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.SecretKeySelector)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.SecretKeySelector:
			return SecretKeySelector{V: v}
		case core.SecretKeySelector:
			return SecretKeySelector{V: &v}
		default:
			return skylark.None
		}
	}
	SecretKeySelector_attrs = setFieldTypes(t, SecretKeySelector_fields, SecretKeySelector_inline)
	Library["SecretKeySelector"] = skylark.NewBuiltin("SecretKeySelector", createSecretKeySelector)
}

func createSecretKeySelector(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := SecretKeySelector{V: &core.SecretKeySelector{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t SecretKeySelector) Underlying() interface{} { return t.V }
func (t SecretKeySelector) DeepCopy() boxed         { return SecretKeySelector{V: t.V.DeepCopy()} }
func (t SecretKeySelector) Package() util.Package   { return util.Core }
func (t SecretKeySelector) Type() string            { return "k8s_core_SecretKeySelector" }
func (t SecretKeySelector) String() string          { return t.V.String() }
func (t SecretKeySelector) Freeze()                 {} // TODO
func (t SecretKeySelector) Truth() skylark.Bool     { return skylark.True }
func (t SecretKeySelector) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t SecretKeySelector) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*SecretKeySelector)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t SecretKeySelector) AttrNames() []string { return SecretKeySelector_attrs }
func (t SecretKeySelector) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, SecretKeySelector_fields, SecretKeySelector_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t SecretKeySelector) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, SecretKeySelector_fields, SecretKeySelector_inline)
}

type SecretList struct {
	V *core.SecretList
}

var (
	_ boxed = (*SecretList)(nil)

	SecretList_fields = map[string]util.FieldSpec{}
	SecretList_inline = map[string]util.FieldSpec{}
	SecretList_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.SecretList)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.SecretList:
			return SecretList{V: v}
		case core.SecretList:
			return SecretList{V: &v}
		default:
			return skylark.None
		}
	}
	SecretList_attrs = setFieldTypes(t, SecretList_fields, SecretList_inline)
	Library["SecretList"] = skylark.NewBuiltin("SecretList", createSecretList)
}

func createSecretList(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := SecretList{V: &core.SecretList{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t SecretList) Underlying() interface{} { return t.V }
func (t SecretList) DeepCopy() boxed         { return SecretList{V: t.V.DeepCopy()} }
func (t SecretList) Package() util.Package   { return util.Core }
func (t SecretList) Type() string            { return "k8s_core_SecretList" }
func (t SecretList) String() string          { return t.V.String() }
func (t SecretList) Freeze()                 {} // TODO
func (t SecretList) Truth() skylark.Bool     { return skylark.True }
func (t SecretList) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t SecretList) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*SecretList)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t SecretList) AttrNames() []string { return SecretList_attrs }
func (t SecretList) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, SecretList_fields, SecretList_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t SecretList) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, SecretList_fields, SecretList_inline)
}

type SecretProjection struct {
	V *core.SecretProjection
}

var (
	_ boxed = (*SecretProjection)(nil)

	SecretProjection_fields = map[string]util.FieldSpec{}
	SecretProjection_inline = map[string]util.FieldSpec{}
	SecretProjection_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.SecretProjection)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.SecretProjection:
			return SecretProjection{V: v}
		case core.SecretProjection:
			return SecretProjection{V: &v}
		default:
			return skylark.None
		}
	}
	SecretProjection_attrs = setFieldTypes(t, SecretProjection_fields, SecretProjection_inline)
	Library["SecretProjection"] = skylark.NewBuiltin("SecretProjection", createSecretProjection)
}

func createSecretProjection(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := SecretProjection{V: &core.SecretProjection{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t SecretProjection) Underlying() interface{} { return t.V }
func (t SecretProjection) DeepCopy() boxed         { return SecretProjection{V: t.V.DeepCopy()} }
func (t SecretProjection) Package() util.Package   { return util.Core }
func (t SecretProjection) Type() string            { return "k8s_core_SecretProjection" }
func (t SecretProjection) String() string          { return t.V.String() }
func (t SecretProjection) Freeze()                 {} // TODO
func (t SecretProjection) Truth() skylark.Bool     { return skylark.True }
func (t SecretProjection) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t SecretProjection) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*SecretProjection)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t SecretProjection) AttrNames() []string { return SecretProjection_attrs }
func (t SecretProjection) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, SecretProjection_fields, SecretProjection_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t SecretProjection) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, SecretProjection_fields, SecretProjection_inline)
}

type SecretReference struct {
	V *core.SecretReference
}

var (
	_ boxed = (*SecretReference)(nil)

	SecretReference_fields = map[string]util.FieldSpec{}
	SecretReference_inline = map[string]util.FieldSpec{}
	SecretReference_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.SecretReference)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.SecretReference:
			return SecretReference{V: v}
		case core.SecretReference:
			return SecretReference{V: &v}
		default:
			return skylark.None
		}
	}
	SecretReference_attrs = setFieldTypes(t, SecretReference_fields, SecretReference_inline)
	Library["SecretReference"] = skylark.NewBuiltin("SecretReference", createSecretReference)
}

func createSecretReference(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := SecretReference{V: &core.SecretReference{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t SecretReference) Underlying() interface{} { return t.V }
func (t SecretReference) DeepCopy() boxed         { return SecretReference{V: t.V.DeepCopy()} }
func (t SecretReference) Package() util.Package   { return util.Core }
func (t SecretReference) Type() string            { return "k8s_core_SecretReference" }
func (t SecretReference) String() string          { return t.V.String() }
func (t SecretReference) Freeze()                 {} // TODO
func (t SecretReference) Truth() skylark.Bool     { return skylark.True }
func (t SecretReference) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t SecretReference) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*SecretReference)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t SecretReference) AttrNames() []string { return SecretReference_attrs }
func (t SecretReference) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, SecretReference_fields, SecretReference_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t SecretReference) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, SecretReference_fields, SecretReference_inline)
}

type SecretVolumeSource struct {
	V *core.SecretVolumeSource
}

var (
	_ boxed = (*SecretVolumeSource)(nil)

	SecretVolumeSource_fields = map[string]util.FieldSpec{}
	SecretVolumeSource_inline = map[string]util.FieldSpec{}
	SecretVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.SecretVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.SecretVolumeSource:
			return SecretVolumeSource{V: v}
		case core.SecretVolumeSource:
			return SecretVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	SecretVolumeSource_attrs = setFieldTypes(t, SecretVolumeSource_fields, SecretVolumeSource_inline)
	Library["SecretVolumeSource"] = skylark.NewBuiltin("SecretVolumeSource", createSecretVolumeSource)
}

func createSecretVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := SecretVolumeSource{V: &core.SecretVolumeSource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t SecretVolumeSource) Underlying() interface{} { return t.V }
func (t SecretVolumeSource) DeepCopy() boxed         { return SecretVolumeSource{V: t.V.DeepCopy()} }
func (t SecretVolumeSource) Package() util.Package   { return util.Core }
func (t SecretVolumeSource) Type() string            { return "k8s_core_SecretVolumeSource" }
func (t SecretVolumeSource) String() string          { return t.V.String() }
func (t SecretVolumeSource) Freeze()                 {} // TODO
func (t SecretVolumeSource) Truth() skylark.Bool     { return skylark.True }
func (t SecretVolumeSource) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t SecretVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*SecretVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t SecretVolumeSource) AttrNames() []string { return SecretVolumeSource_attrs }
func (t SecretVolumeSource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, SecretVolumeSource_fields, SecretVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t SecretVolumeSource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, SecretVolumeSource_fields, SecretVolumeSource_inline)
}

type SecurityContext struct {
	V *core.SecurityContext
}

var (
	_ boxed = (*SecurityContext)(nil)

	SecurityContext_fields = map[string]util.FieldSpec{}
	SecurityContext_inline = map[string]util.FieldSpec{}
	SecurityContext_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.SecurityContext)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.SecurityContext:
			return SecurityContext{V: v}
		case core.SecurityContext:
			return SecurityContext{V: &v}
		default:
			return skylark.None
		}
	}
	SecurityContext_attrs = setFieldTypes(t, SecurityContext_fields, SecurityContext_inline)
	Library["SecurityContext"] = skylark.NewBuiltin("SecurityContext", createSecurityContext)
}

func createSecurityContext(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := SecurityContext{V: &core.SecurityContext{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t SecurityContext) Underlying() interface{} { return t.V }
func (t SecurityContext) DeepCopy() boxed         { return SecurityContext{V: t.V.DeepCopy()} }
func (t SecurityContext) Package() util.Package   { return util.Core }
func (t SecurityContext) Type() string            { return "k8s_core_SecurityContext" }
func (t SecurityContext) String() string          { return t.V.String() }
func (t SecurityContext) Freeze()                 {} // TODO
func (t SecurityContext) Truth() skylark.Bool     { return skylark.True }
func (t SecurityContext) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t SecurityContext) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*SecurityContext)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t SecurityContext) AttrNames() []string { return SecurityContext_attrs }
func (t SecurityContext) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, SecurityContext_fields, SecurityContext_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t SecurityContext) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, SecurityContext_fields, SecurityContext_inline)
}

type SerializedReference struct {
	V *core.SerializedReference
}

var (
	_ boxed = (*SerializedReference)(nil)

	SerializedReference_fields = map[string]util.FieldSpec{}
	SerializedReference_inline = map[string]util.FieldSpec{}
	SerializedReference_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.SerializedReference)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.SerializedReference:
			return SerializedReference{V: v}
		case core.SerializedReference:
			return SerializedReference{V: &v}
		default:
			return skylark.None
		}
	}
	SerializedReference_attrs = setFieldTypes(t, SerializedReference_fields, SerializedReference_inline)
	Library["SerializedReference"] = skylark.NewBuiltin("SerializedReference", createSerializedReference)
}

func createSerializedReference(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := SerializedReference{V: &core.SerializedReference{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t SerializedReference) Underlying() interface{} { return t.V }
func (t SerializedReference) DeepCopy() boxed         { return SerializedReference{V: t.V.DeepCopy()} }
func (t SerializedReference) Package() util.Package   { return util.Core }
func (t SerializedReference) Type() string            { return "k8s_core_SerializedReference" }
func (t SerializedReference) String() string          { return t.V.String() }
func (t SerializedReference) Freeze()                 {} // TODO
func (t SerializedReference) Truth() skylark.Bool     { return skylark.True }
func (t SerializedReference) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t SerializedReference) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*SerializedReference)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t SerializedReference) AttrNames() []string { return SerializedReference_attrs }
func (t SerializedReference) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, SerializedReference_fields, SerializedReference_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t SerializedReference) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, SerializedReference_fields, SerializedReference_inline)
}

type Service struct {
	V *core.Service
}

var (
	_ boxed = (*Service)(nil)

	Service_fields = map[string]util.FieldSpec{}
	Service_inline = map[string]util.FieldSpec{}
	Service_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.Service)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.Service:
			return Service{V: v}
		case core.Service:
			return Service{V: &v}
		default:
			return skylark.None
		}
	}
	Service_attrs = setFieldTypes(t, Service_fields, Service_inline)
	Library["Service"] = skylark.NewBuiltin("Service", createService)
}

func createService(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := Service{V: &core.Service{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t Service) Underlying() interface{} { return t.V }
func (t Service) DeepCopy() boxed         { return Service{V: t.V.DeepCopy()} }
func (t Service) Package() util.Package   { return util.Core }
func (t Service) Type() string            { return "k8s_core_Service" }
func (t Service) String() string          { return t.V.String() }
func (t Service) Freeze()                 {} // TODO
func (t Service) Truth() skylark.Bool     { return skylark.True }
func (t Service) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t Service) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*Service)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t Service) AttrNames() []string { return Service_attrs }
func (t Service) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, Service_fields, Service_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t Service) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, Service_fields, Service_inline)
}

type ServiceAccount struct {
	V *core.ServiceAccount
}

var (
	_ boxed = (*ServiceAccount)(nil)

	ServiceAccount_fields = map[string]util.FieldSpec{}
	ServiceAccount_inline = map[string]util.FieldSpec{}
	ServiceAccount_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.ServiceAccount)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.ServiceAccount:
			return ServiceAccount{V: v}
		case core.ServiceAccount:
			return ServiceAccount{V: &v}
		default:
			return skylark.None
		}
	}
	ServiceAccount_attrs = setFieldTypes(t, ServiceAccount_fields, ServiceAccount_inline)
	Library["ServiceAccount"] = skylark.NewBuiltin("ServiceAccount", createServiceAccount)
}

func createServiceAccount(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ServiceAccount{V: &core.ServiceAccount{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ServiceAccount) Underlying() interface{} { return t.V }
func (t ServiceAccount) DeepCopy() boxed         { return ServiceAccount{V: t.V.DeepCopy()} }
func (t ServiceAccount) Package() util.Package   { return util.Core }
func (t ServiceAccount) Type() string            { return "k8s_core_ServiceAccount" }
func (t ServiceAccount) String() string          { return t.V.String() }
func (t ServiceAccount) Freeze()                 {} // TODO
func (t ServiceAccount) Truth() skylark.Bool     { return skylark.True }
func (t ServiceAccount) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ServiceAccount) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ServiceAccount)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ServiceAccount) AttrNames() []string { return ServiceAccount_attrs }
func (t ServiceAccount) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ServiceAccount_fields, ServiceAccount_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ServiceAccount) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ServiceAccount_fields, ServiceAccount_inline)
}

type ServiceAccountList struct {
	V *core.ServiceAccountList
}

var (
	_ boxed = (*ServiceAccountList)(nil)

	ServiceAccountList_fields = map[string]util.FieldSpec{}
	ServiceAccountList_inline = map[string]util.FieldSpec{}
	ServiceAccountList_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.ServiceAccountList)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.ServiceAccountList:
			return ServiceAccountList{V: v}
		case core.ServiceAccountList:
			return ServiceAccountList{V: &v}
		default:
			return skylark.None
		}
	}
	ServiceAccountList_attrs = setFieldTypes(t, ServiceAccountList_fields, ServiceAccountList_inline)
	Library["ServiceAccountList"] = skylark.NewBuiltin("ServiceAccountList", createServiceAccountList)
}

func createServiceAccountList(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ServiceAccountList{V: &core.ServiceAccountList{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ServiceAccountList) Underlying() interface{} { return t.V }
func (t ServiceAccountList) DeepCopy() boxed         { return ServiceAccountList{V: t.V.DeepCopy()} }
func (t ServiceAccountList) Package() util.Package   { return util.Core }
func (t ServiceAccountList) Type() string            { return "k8s_core_ServiceAccountList" }
func (t ServiceAccountList) String() string          { return t.V.String() }
func (t ServiceAccountList) Freeze()                 {} // TODO
func (t ServiceAccountList) Truth() skylark.Bool     { return skylark.True }
func (t ServiceAccountList) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ServiceAccountList) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ServiceAccountList)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ServiceAccountList) AttrNames() []string { return ServiceAccountList_attrs }
func (t ServiceAccountList) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ServiceAccountList_fields, ServiceAccountList_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ServiceAccountList) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ServiceAccountList_fields, ServiceAccountList_inline)
}

type ServiceAccountTokenProjection struct {
	V *core.ServiceAccountTokenProjection
}

var (
	_ boxed = (*ServiceAccountTokenProjection)(nil)

	ServiceAccountTokenProjection_fields = map[string]util.FieldSpec{}
	ServiceAccountTokenProjection_inline = map[string]util.FieldSpec{}
	ServiceAccountTokenProjection_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.ServiceAccountTokenProjection)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.ServiceAccountTokenProjection:
			return ServiceAccountTokenProjection{V: v}
		case core.ServiceAccountTokenProjection:
			return ServiceAccountTokenProjection{V: &v}
		default:
			return skylark.None
		}
	}
	ServiceAccountTokenProjection_attrs = setFieldTypes(t, ServiceAccountTokenProjection_fields, ServiceAccountTokenProjection_inline)
	Library["ServiceAccountTokenProjection"] = skylark.NewBuiltin("ServiceAccountTokenProjection", createServiceAccountTokenProjection)
}

func createServiceAccountTokenProjection(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ServiceAccountTokenProjection{V: &core.ServiceAccountTokenProjection{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ServiceAccountTokenProjection) Underlying() interface{} { return t.V }
func (t ServiceAccountTokenProjection) DeepCopy() boxed {
	return ServiceAccountTokenProjection{V: t.V.DeepCopy()}
}
func (t ServiceAccountTokenProjection) Package() util.Package { return util.Core }
func (t ServiceAccountTokenProjection) Type() string          { return "k8s_core_ServiceAccountTokenProjection" }
func (t ServiceAccountTokenProjection) String() string        { return t.V.String() }
func (t ServiceAccountTokenProjection) Freeze()               {} // TODO
func (t ServiceAccountTokenProjection) Truth() skylark.Bool   { return skylark.True }
func (t ServiceAccountTokenProjection) Hash() (uint32, error) { return 0, unhashable(t.Type()) }
func (t ServiceAccountTokenProjection) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ServiceAccountTokenProjection)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ServiceAccountTokenProjection) AttrNames() []string {
	return ServiceAccountTokenProjection_attrs
}
func (t ServiceAccountTokenProjection) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ServiceAccountTokenProjection_fields, ServiceAccountTokenProjection_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ServiceAccountTokenProjection) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ServiceAccountTokenProjection_fields, ServiceAccountTokenProjection_inline)
}

type ServiceList struct {
	V *core.ServiceList
}

var (
	_ boxed = (*ServiceList)(nil)

	ServiceList_fields = map[string]util.FieldSpec{}
	ServiceList_inline = map[string]util.FieldSpec{}
	ServiceList_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.ServiceList)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.ServiceList:
			return ServiceList{V: v}
		case core.ServiceList:
			return ServiceList{V: &v}
		default:
			return skylark.None
		}
	}
	ServiceList_attrs = setFieldTypes(t, ServiceList_fields, ServiceList_inline)
	Library["ServiceList"] = skylark.NewBuiltin("ServiceList", createServiceList)
}

func createServiceList(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ServiceList{V: &core.ServiceList{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ServiceList) Underlying() interface{} { return t.V }
func (t ServiceList) DeepCopy() boxed         { return ServiceList{V: t.V.DeepCopy()} }
func (t ServiceList) Package() util.Package   { return util.Core }
func (t ServiceList) Type() string            { return "k8s_core_ServiceList" }
func (t ServiceList) String() string          { return t.V.String() }
func (t ServiceList) Freeze()                 {} // TODO
func (t ServiceList) Truth() skylark.Bool     { return skylark.True }
func (t ServiceList) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ServiceList) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ServiceList)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ServiceList) AttrNames() []string { return ServiceList_attrs }
func (t ServiceList) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ServiceList_fields, ServiceList_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ServiceList) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ServiceList_fields, ServiceList_inline)
}

type ServicePort struct {
	V *core.ServicePort
}

var (
	_ boxed = (*ServicePort)(nil)

	ServicePort_fields = map[string]util.FieldSpec{}
	ServicePort_inline = map[string]util.FieldSpec{}
	ServicePort_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.ServicePort)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.ServicePort:
			return ServicePort{V: v}
		case core.ServicePort:
			return ServicePort{V: &v}
		default:
			return skylark.None
		}
	}
	ServicePort_attrs = setFieldTypes(t, ServicePort_fields, ServicePort_inline)
	Library["ServicePort"] = skylark.NewBuiltin("ServicePort", createServicePort)
}

func createServicePort(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ServicePort{V: &core.ServicePort{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ServicePort) Underlying() interface{} { return t.V }
func (t ServicePort) DeepCopy() boxed         { return ServicePort{V: t.V.DeepCopy()} }
func (t ServicePort) Package() util.Package   { return util.Core }
func (t ServicePort) Type() string            { return "k8s_core_ServicePort" }
func (t ServicePort) String() string          { return t.V.String() }
func (t ServicePort) Freeze()                 {} // TODO
func (t ServicePort) Truth() skylark.Bool     { return skylark.True }
func (t ServicePort) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ServicePort) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ServicePort)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ServicePort) AttrNames() []string { return ServicePort_attrs }
func (t ServicePort) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ServicePort_fields, ServicePort_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ServicePort) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ServicePort_fields, ServicePort_inline)
}

type ServiceProxyOptions struct {
	V *core.ServiceProxyOptions
}

var (
	_ boxed = (*ServiceProxyOptions)(nil)

	ServiceProxyOptions_fields = map[string]util.FieldSpec{}
	ServiceProxyOptions_inline = map[string]util.FieldSpec{}
	ServiceProxyOptions_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.ServiceProxyOptions)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.ServiceProxyOptions:
			return ServiceProxyOptions{V: v}
		case core.ServiceProxyOptions:
			return ServiceProxyOptions{V: &v}
		default:
			return skylark.None
		}
	}
	ServiceProxyOptions_attrs = setFieldTypes(t, ServiceProxyOptions_fields, ServiceProxyOptions_inline)
	Library["ServiceProxyOptions"] = skylark.NewBuiltin("ServiceProxyOptions", createServiceProxyOptions)
}

func createServiceProxyOptions(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ServiceProxyOptions{V: &core.ServiceProxyOptions{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ServiceProxyOptions) Underlying() interface{} { return t.V }
func (t ServiceProxyOptions) DeepCopy() boxed         { return ServiceProxyOptions{V: t.V.DeepCopy()} }
func (t ServiceProxyOptions) Package() util.Package   { return util.Core }
func (t ServiceProxyOptions) Type() string            { return "k8s_core_ServiceProxyOptions" }
func (t ServiceProxyOptions) String() string          { return t.V.String() }
func (t ServiceProxyOptions) Freeze()                 {} // TODO
func (t ServiceProxyOptions) Truth() skylark.Bool     { return skylark.True }
func (t ServiceProxyOptions) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ServiceProxyOptions) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ServiceProxyOptions)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ServiceProxyOptions) AttrNames() []string { return ServiceProxyOptions_attrs }
func (t ServiceProxyOptions) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ServiceProxyOptions_fields, ServiceProxyOptions_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ServiceProxyOptions) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ServiceProxyOptions_fields, ServiceProxyOptions_inline)
}

type ServiceSpec struct {
	V *core.ServiceSpec
}

var (
	_ boxed = (*ServiceSpec)(nil)

	ServiceSpec_fields = map[string]util.FieldSpec{}
	ServiceSpec_inline = map[string]util.FieldSpec{}
	ServiceSpec_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.ServiceSpec)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.ServiceSpec:
			return ServiceSpec{V: v}
		case core.ServiceSpec:
			return ServiceSpec{V: &v}
		default:
			return skylark.None
		}
	}
	ServiceSpec_attrs = setFieldTypes(t, ServiceSpec_fields, ServiceSpec_inline)
	Library["ServiceSpec"] = skylark.NewBuiltin("ServiceSpec", createServiceSpec)
}

func createServiceSpec(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ServiceSpec{V: &core.ServiceSpec{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ServiceSpec) Underlying() interface{} { return t.V }
func (t ServiceSpec) DeepCopy() boxed         { return ServiceSpec{V: t.V.DeepCopy()} }
func (t ServiceSpec) Package() util.Package   { return util.Core }
func (t ServiceSpec) Type() string            { return "k8s_core_ServiceSpec" }
func (t ServiceSpec) String() string          { return t.V.String() }
func (t ServiceSpec) Freeze()                 {} // TODO
func (t ServiceSpec) Truth() skylark.Bool     { return skylark.True }
func (t ServiceSpec) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ServiceSpec) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ServiceSpec)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ServiceSpec) AttrNames() []string { return ServiceSpec_attrs }
func (t ServiceSpec) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ServiceSpec_fields, ServiceSpec_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ServiceSpec) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ServiceSpec_fields, ServiceSpec_inline)
}

type ServiceStatus struct {
	V *core.ServiceStatus
}

var (
	_ boxed = (*ServiceStatus)(nil)

	ServiceStatus_fields = map[string]util.FieldSpec{}
	ServiceStatus_inline = map[string]util.FieldSpec{}
	ServiceStatus_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.ServiceStatus)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.ServiceStatus:
			return ServiceStatus{V: v}
		case core.ServiceStatus:
			return ServiceStatus{V: &v}
		default:
			return skylark.None
		}
	}
	ServiceStatus_attrs = setFieldTypes(t, ServiceStatus_fields, ServiceStatus_inline)
	Library["ServiceStatus"] = skylark.NewBuiltin("ServiceStatus", createServiceStatus)
}

func createServiceStatus(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ServiceStatus{V: &core.ServiceStatus{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ServiceStatus) Underlying() interface{} { return t.V }
func (t ServiceStatus) DeepCopy() boxed         { return ServiceStatus{V: t.V.DeepCopy()} }
func (t ServiceStatus) Package() util.Package   { return util.Core }
func (t ServiceStatus) Type() string            { return "k8s_core_ServiceStatus" }
func (t ServiceStatus) String() string          { return t.V.String() }
func (t ServiceStatus) Freeze()                 {} // TODO
func (t ServiceStatus) Truth() skylark.Bool     { return skylark.True }
func (t ServiceStatus) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ServiceStatus) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ServiceStatus)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ServiceStatus) AttrNames() []string { return ServiceStatus_attrs }
func (t ServiceStatus) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ServiceStatus_fields, ServiceStatus_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ServiceStatus) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ServiceStatus_fields, ServiceStatus_inline)
}

type SessionAffinityConfig struct {
	V *core.SessionAffinityConfig
}

var (
	_ boxed = (*SessionAffinityConfig)(nil)

	SessionAffinityConfig_fields = map[string]util.FieldSpec{}
	SessionAffinityConfig_inline = map[string]util.FieldSpec{}
	SessionAffinityConfig_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.SessionAffinityConfig)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.SessionAffinityConfig:
			return SessionAffinityConfig{V: v}
		case core.SessionAffinityConfig:
			return SessionAffinityConfig{V: &v}
		default:
			return skylark.None
		}
	}
	SessionAffinityConfig_attrs = setFieldTypes(t, SessionAffinityConfig_fields, SessionAffinityConfig_inline)
	Library["SessionAffinityConfig"] = skylark.NewBuiltin("SessionAffinityConfig", createSessionAffinityConfig)
}

func createSessionAffinityConfig(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := SessionAffinityConfig{V: &core.SessionAffinityConfig{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t SessionAffinityConfig) Underlying() interface{} { return t.V }
func (t SessionAffinityConfig) DeepCopy() boxed         { return SessionAffinityConfig{V: t.V.DeepCopy()} }
func (t SessionAffinityConfig) Package() util.Package   { return util.Core }
func (t SessionAffinityConfig) Type() string            { return "k8s_core_SessionAffinityConfig" }
func (t SessionAffinityConfig) String() string          { return t.V.String() }
func (t SessionAffinityConfig) Freeze()                 {} // TODO
func (t SessionAffinityConfig) Truth() skylark.Bool     { return skylark.True }
func (t SessionAffinityConfig) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t SessionAffinityConfig) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*SessionAffinityConfig)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t SessionAffinityConfig) AttrNames() []string { return SessionAffinityConfig_attrs }
func (t SessionAffinityConfig) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, SessionAffinityConfig_fields, SessionAffinityConfig_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t SessionAffinityConfig) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, SessionAffinityConfig_fields, SessionAffinityConfig_inline)
}

type StorageOSPersistentVolumeSource struct {
	V *core.StorageOSPersistentVolumeSource
}

var (
	_ boxed = (*StorageOSPersistentVolumeSource)(nil)

	StorageOSPersistentVolumeSource_fields = map[string]util.FieldSpec{}
	StorageOSPersistentVolumeSource_inline = map[string]util.FieldSpec{}
	StorageOSPersistentVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.StorageOSPersistentVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.StorageOSPersistentVolumeSource:
			return StorageOSPersistentVolumeSource{V: v}
		case core.StorageOSPersistentVolumeSource:
			return StorageOSPersistentVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	StorageOSPersistentVolumeSource_attrs = setFieldTypes(t, StorageOSPersistentVolumeSource_fields, StorageOSPersistentVolumeSource_inline)
	Library["StorageOSPersistentVolumeSource"] = skylark.NewBuiltin("StorageOSPersistentVolumeSource", createStorageOSPersistentVolumeSource)
}

func createStorageOSPersistentVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := StorageOSPersistentVolumeSource{V: &core.StorageOSPersistentVolumeSource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t StorageOSPersistentVolumeSource) Underlying() interface{} { return t.V }
func (t StorageOSPersistentVolumeSource) DeepCopy() boxed {
	return StorageOSPersistentVolumeSource{V: t.V.DeepCopy()}
}
func (t StorageOSPersistentVolumeSource) Package() util.Package { return util.Core }
func (t StorageOSPersistentVolumeSource) Type() string {
	return "k8s_core_StorageOSPersistentVolumeSource"
}
func (t StorageOSPersistentVolumeSource) String() string        { return t.V.String() }
func (t StorageOSPersistentVolumeSource) Freeze()               {} // TODO
func (t StorageOSPersistentVolumeSource) Truth() skylark.Bool   { return skylark.True }
func (t StorageOSPersistentVolumeSource) Hash() (uint32, error) { return 0, unhashable(t.Type()) }
func (t StorageOSPersistentVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*StorageOSPersistentVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t StorageOSPersistentVolumeSource) AttrNames() []string {
	return StorageOSPersistentVolumeSource_attrs
}
func (t StorageOSPersistentVolumeSource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, StorageOSPersistentVolumeSource_fields, StorageOSPersistentVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t StorageOSPersistentVolumeSource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, StorageOSPersistentVolumeSource_fields, StorageOSPersistentVolumeSource_inline)
}

type StorageOSVolumeSource struct {
	V *core.StorageOSVolumeSource
}

var (
	_ boxed = (*StorageOSVolumeSource)(nil)

	StorageOSVolumeSource_fields = map[string]util.FieldSpec{}
	StorageOSVolumeSource_inline = map[string]util.FieldSpec{}
	StorageOSVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.StorageOSVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.StorageOSVolumeSource:
			return StorageOSVolumeSource{V: v}
		case core.StorageOSVolumeSource:
			return StorageOSVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	StorageOSVolumeSource_attrs = setFieldTypes(t, StorageOSVolumeSource_fields, StorageOSVolumeSource_inline)
	Library["StorageOSVolumeSource"] = skylark.NewBuiltin("StorageOSVolumeSource", createStorageOSVolumeSource)
}

func createStorageOSVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := StorageOSVolumeSource{V: &core.StorageOSVolumeSource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t StorageOSVolumeSource) Underlying() interface{} { return t.V }
func (t StorageOSVolumeSource) DeepCopy() boxed         { return StorageOSVolumeSource{V: t.V.DeepCopy()} }
func (t StorageOSVolumeSource) Package() util.Package   { return util.Core }
func (t StorageOSVolumeSource) Type() string            { return "k8s_core_StorageOSVolumeSource" }
func (t StorageOSVolumeSource) String() string          { return t.V.String() }
func (t StorageOSVolumeSource) Freeze()                 {} // TODO
func (t StorageOSVolumeSource) Truth() skylark.Bool     { return skylark.True }
func (t StorageOSVolumeSource) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t StorageOSVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*StorageOSVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t StorageOSVolumeSource) AttrNames() []string { return StorageOSVolumeSource_attrs }
func (t StorageOSVolumeSource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, StorageOSVolumeSource_fields, StorageOSVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t StorageOSVolumeSource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, StorageOSVolumeSource_fields, StorageOSVolumeSource_inline)
}

type Sysctl struct {
	V *core.Sysctl
}

var (
	_ boxed = (*Sysctl)(nil)

	Sysctl_fields = map[string]util.FieldSpec{}
	Sysctl_inline = map[string]util.FieldSpec{}
	Sysctl_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.Sysctl)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.Sysctl:
			return Sysctl{V: v}
		case core.Sysctl:
			return Sysctl{V: &v}
		default:
			return skylark.None
		}
	}
	Sysctl_attrs = setFieldTypes(t, Sysctl_fields, Sysctl_inline)
	Library["Sysctl"] = skylark.NewBuiltin("Sysctl", createSysctl)
}

func createSysctl(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := Sysctl{V: &core.Sysctl{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t Sysctl) Underlying() interface{} { return t.V }
func (t Sysctl) DeepCopy() boxed         { return Sysctl{V: t.V.DeepCopy()} }
func (t Sysctl) Package() util.Package   { return util.Core }
func (t Sysctl) Type() string            { return "k8s_core_Sysctl" }
func (t Sysctl) String() string          { return t.V.String() }
func (t Sysctl) Freeze()                 {} // TODO
func (t Sysctl) Truth() skylark.Bool     { return skylark.True }
func (t Sysctl) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t Sysctl) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*Sysctl)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t Sysctl) AttrNames() []string { return Sysctl_attrs }
func (t Sysctl) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, Sysctl_fields, Sysctl_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t Sysctl) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, Sysctl_fields, Sysctl_inline)
}

type TCPSocketAction struct {
	V *core.TCPSocketAction
}

var (
	_ boxed = (*TCPSocketAction)(nil)

	TCPSocketAction_fields = map[string]util.FieldSpec{}
	TCPSocketAction_inline = map[string]util.FieldSpec{}
	TCPSocketAction_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.TCPSocketAction)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.TCPSocketAction:
			return TCPSocketAction{V: v}
		case core.TCPSocketAction:
			return TCPSocketAction{V: &v}
		default:
			return skylark.None
		}
	}
	TCPSocketAction_attrs = setFieldTypes(t, TCPSocketAction_fields, TCPSocketAction_inline)
	Library["TCPSocketAction"] = skylark.NewBuiltin("TCPSocketAction", createTCPSocketAction)
}

func createTCPSocketAction(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := TCPSocketAction{V: &core.TCPSocketAction{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t TCPSocketAction) Underlying() interface{} { return t.V }
func (t TCPSocketAction) DeepCopy() boxed         { return TCPSocketAction{V: t.V.DeepCopy()} }
func (t TCPSocketAction) Package() util.Package   { return util.Core }
func (t TCPSocketAction) Type() string            { return "k8s_core_TCPSocketAction" }
func (t TCPSocketAction) String() string          { return t.V.String() }
func (t TCPSocketAction) Freeze()                 {} // TODO
func (t TCPSocketAction) Truth() skylark.Bool     { return skylark.True }
func (t TCPSocketAction) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t TCPSocketAction) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*TCPSocketAction)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t TCPSocketAction) AttrNames() []string { return TCPSocketAction_attrs }
func (t TCPSocketAction) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, TCPSocketAction_fields, TCPSocketAction_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t TCPSocketAction) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, TCPSocketAction_fields, TCPSocketAction_inline)
}

type Taint struct {
	V *core.Taint
}

var (
	_ boxed = (*Taint)(nil)

	Taint_fields = map[string]util.FieldSpec{}
	Taint_inline = map[string]util.FieldSpec{}
	Taint_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.Taint)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.Taint:
			return Taint{V: v}
		case core.Taint:
			return Taint{V: &v}
		default:
			return skylark.None
		}
	}
	Taint_attrs = setFieldTypes(t, Taint_fields, Taint_inline)
	Library["Taint"] = skylark.NewBuiltin("Taint", createTaint)
}

func createTaint(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := Taint{V: &core.Taint{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t Taint) Underlying() interface{} { return t.V }
func (t Taint) DeepCopy() boxed         { return Taint{V: t.V.DeepCopy()} }
func (t Taint) Package() util.Package   { return util.Core }
func (t Taint) Type() string            { return "k8s_core_Taint" }
func (t Taint) String() string          { return t.V.String() }
func (t Taint) Freeze()                 {} // TODO
func (t Taint) Truth() skylark.Bool     { return skylark.True }
func (t Taint) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t Taint) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*Taint)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t Taint) AttrNames() []string { return Taint_attrs }
func (t Taint) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, Taint_fields, Taint_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t Taint) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, Taint_fields, Taint_inline)
}

type Toleration struct {
	V *core.Toleration
}

var (
	_ boxed = (*Toleration)(nil)

	Toleration_fields = map[string]util.FieldSpec{}
	Toleration_inline = map[string]util.FieldSpec{}
	Toleration_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.Toleration)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.Toleration:
			return Toleration{V: v}
		case core.Toleration:
			return Toleration{V: &v}
		default:
			return skylark.None
		}
	}
	Toleration_attrs = setFieldTypes(t, Toleration_fields, Toleration_inline)
	Library["Toleration"] = skylark.NewBuiltin("Toleration", createToleration)
}

func createToleration(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := Toleration{V: &core.Toleration{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t Toleration) Underlying() interface{} { return t.V }
func (t Toleration) DeepCopy() boxed         { return Toleration{V: t.V.DeepCopy()} }
func (t Toleration) Package() util.Package   { return util.Core }
func (t Toleration) Type() string            { return "k8s_core_Toleration" }
func (t Toleration) String() string          { return t.V.String() }
func (t Toleration) Freeze()                 {} // TODO
func (t Toleration) Truth() skylark.Bool     { return skylark.True }
func (t Toleration) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t Toleration) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*Toleration)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t Toleration) AttrNames() []string { return Toleration_attrs }
func (t Toleration) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, Toleration_fields, Toleration_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t Toleration) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, Toleration_fields, Toleration_inline)
}

type TopologySelectorLabelRequirement struct {
	V *core.TopologySelectorLabelRequirement
}

var (
	_ boxed = (*TopologySelectorLabelRequirement)(nil)

	TopologySelectorLabelRequirement_fields = map[string]util.FieldSpec{}
	TopologySelectorLabelRequirement_inline = map[string]util.FieldSpec{}
	TopologySelectorLabelRequirement_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.TopologySelectorLabelRequirement)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.TopologySelectorLabelRequirement:
			return TopologySelectorLabelRequirement{V: v}
		case core.TopologySelectorLabelRequirement:
			return TopologySelectorLabelRequirement{V: &v}
		default:
			return skylark.None
		}
	}
	TopologySelectorLabelRequirement_attrs = setFieldTypes(t, TopologySelectorLabelRequirement_fields, TopologySelectorLabelRequirement_inline)
	Library["TopologySelectorLabelRequirement"] = skylark.NewBuiltin("TopologySelectorLabelRequirement", createTopologySelectorLabelRequirement)
}

func createTopologySelectorLabelRequirement(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := TopologySelectorLabelRequirement{V: &core.TopologySelectorLabelRequirement{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t TopologySelectorLabelRequirement) Underlying() interface{} { return t.V }
func (t TopologySelectorLabelRequirement) DeepCopy() boxed {
	return TopologySelectorLabelRequirement{V: t.V.DeepCopy()}
}
func (t TopologySelectorLabelRequirement) Package() util.Package { return util.Core }
func (t TopologySelectorLabelRequirement) Type() string {
	return "k8s_core_TopologySelectorLabelRequirement"
}
func (t TopologySelectorLabelRequirement) String() string        { return t.V.String() }
func (t TopologySelectorLabelRequirement) Freeze()               {} // TODO
func (t TopologySelectorLabelRequirement) Truth() skylark.Bool   { return skylark.True }
func (t TopologySelectorLabelRequirement) Hash() (uint32, error) { return 0, unhashable(t.Type()) }
func (t TopologySelectorLabelRequirement) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*TopologySelectorLabelRequirement)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t TopologySelectorLabelRequirement) AttrNames() []string {
	return TopologySelectorLabelRequirement_attrs
}
func (t TopologySelectorLabelRequirement) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, TopologySelectorLabelRequirement_fields, TopologySelectorLabelRequirement_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t TopologySelectorLabelRequirement) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, TopologySelectorLabelRequirement_fields, TopologySelectorLabelRequirement_inline)
}

type TopologySelectorTerm struct {
	V *core.TopologySelectorTerm
}

var (
	_ boxed = (*TopologySelectorTerm)(nil)

	TopologySelectorTerm_fields = map[string]util.FieldSpec{}
	TopologySelectorTerm_inline = map[string]util.FieldSpec{}
	TopologySelectorTerm_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.TopologySelectorTerm)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.TopologySelectorTerm:
			return TopologySelectorTerm{V: v}
		case core.TopologySelectorTerm:
			return TopologySelectorTerm{V: &v}
		default:
			return skylark.None
		}
	}
	TopologySelectorTerm_attrs = setFieldTypes(t, TopologySelectorTerm_fields, TopologySelectorTerm_inline)
	Library["TopologySelectorTerm"] = skylark.NewBuiltin("TopologySelectorTerm", createTopologySelectorTerm)
}

func createTopologySelectorTerm(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := TopologySelectorTerm{V: &core.TopologySelectorTerm{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t TopologySelectorTerm) Underlying() interface{} { return t.V }
func (t TopologySelectorTerm) DeepCopy() boxed         { return TopologySelectorTerm{V: t.V.DeepCopy()} }
func (t TopologySelectorTerm) Package() util.Package   { return util.Core }
func (t TopologySelectorTerm) Type() string            { return "k8s_core_TopologySelectorTerm" }
func (t TopologySelectorTerm) String() string          { return t.V.String() }
func (t TopologySelectorTerm) Freeze()                 {} // TODO
func (t TopologySelectorTerm) Truth() skylark.Bool     { return skylark.True }
func (t TopologySelectorTerm) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t TopologySelectorTerm) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*TopologySelectorTerm)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t TopologySelectorTerm) AttrNames() []string { return TopologySelectorTerm_attrs }
func (t TopologySelectorTerm) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, TopologySelectorTerm_fields, TopologySelectorTerm_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t TopologySelectorTerm) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, TopologySelectorTerm_fields, TopologySelectorTerm_inline)
}

type Volume struct {
	V *core.Volume
}

var (
	_ boxed = (*Volume)(nil)

	Volume_fields = map[string]util.FieldSpec{}
	Volume_inline = map[string]util.FieldSpec{}
	Volume_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.Volume)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.Volume:
			return Volume{V: v}
		case core.Volume:
			return Volume{V: &v}
		default:
			return skylark.None
		}
	}
	Volume_attrs = setFieldTypes(t, Volume_fields, Volume_inline)
	Library["Volume"] = skylark.NewBuiltin("Volume", createVolume)
}

func createVolume(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := Volume{V: &core.Volume{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t Volume) Underlying() interface{} { return t.V }
func (t Volume) DeepCopy() boxed         { return Volume{V: t.V.DeepCopy()} }
func (t Volume) Package() util.Package   { return util.Core }
func (t Volume) Type() string            { return "k8s_core_Volume" }
func (t Volume) String() string          { return t.V.String() }
func (t Volume) Freeze()                 {} // TODO
func (t Volume) Truth() skylark.Bool     { return skylark.True }
func (t Volume) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t Volume) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*Volume)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t Volume) AttrNames() []string { return Volume_attrs }
func (t Volume) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, Volume_fields, Volume_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t Volume) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, Volume_fields, Volume_inline)
}

type VolumeDevice struct {
	V *core.VolumeDevice
}

var (
	_ boxed = (*VolumeDevice)(nil)

	VolumeDevice_fields = map[string]util.FieldSpec{}
	VolumeDevice_inline = map[string]util.FieldSpec{}
	VolumeDevice_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.VolumeDevice)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.VolumeDevice:
			return VolumeDevice{V: v}
		case core.VolumeDevice:
			return VolumeDevice{V: &v}
		default:
			return skylark.None
		}
	}
	VolumeDevice_attrs = setFieldTypes(t, VolumeDevice_fields, VolumeDevice_inline)
	Library["VolumeDevice"] = skylark.NewBuiltin("VolumeDevice", createVolumeDevice)
}

func createVolumeDevice(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := VolumeDevice{V: &core.VolumeDevice{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t VolumeDevice) Underlying() interface{} { return t.V }
func (t VolumeDevice) DeepCopy() boxed         { return VolumeDevice{V: t.V.DeepCopy()} }
func (t VolumeDevice) Package() util.Package   { return util.Core }
func (t VolumeDevice) Type() string            { return "k8s_core_VolumeDevice" }
func (t VolumeDevice) String() string          { return t.V.String() }
func (t VolumeDevice) Freeze()                 {} // TODO
func (t VolumeDevice) Truth() skylark.Bool     { return skylark.True }
func (t VolumeDevice) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t VolumeDevice) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*VolumeDevice)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t VolumeDevice) AttrNames() []string { return VolumeDevice_attrs }
func (t VolumeDevice) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, VolumeDevice_fields, VolumeDevice_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t VolumeDevice) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, VolumeDevice_fields, VolumeDevice_inline)
}

type VolumeMount struct {
	V *core.VolumeMount
}

var (
	_ boxed = (*VolumeMount)(nil)

	VolumeMount_fields = map[string]util.FieldSpec{}
	VolumeMount_inline = map[string]util.FieldSpec{}
	VolumeMount_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.VolumeMount)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.VolumeMount:
			return VolumeMount{V: v}
		case core.VolumeMount:
			return VolumeMount{V: &v}
		default:
			return skylark.None
		}
	}
	VolumeMount_attrs = setFieldTypes(t, VolumeMount_fields, VolumeMount_inline)
	Library["VolumeMount"] = skylark.NewBuiltin("VolumeMount", createVolumeMount)
}

func createVolumeMount(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := VolumeMount{V: &core.VolumeMount{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t VolumeMount) Underlying() interface{} { return t.V }
func (t VolumeMount) DeepCopy() boxed         { return VolumeMount{V: t.V.DeepCopy()} }
func (t VolumeMount) Package() util.Package   { return util.Core }
func (t VolumeMount) Type() string            { return "k8s_core_VolumeMount" }
func (t VolumeMount) String() string          { return t.V.String() }
func (t VolumeMount) Freeze()                 {} // TODO
func (t VolumeMount) Truth() skylark.Bool     { return skylark.True }
func (t VolumeMount) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t VolumeMount) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*VolumeMount)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t VolumeMount) AttrNames() []string { return VolumeMount_attrs }
func (t VolumeMount) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, VolumeMount_fields, VolumeMount_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t VolumeMount) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, VolumeMount_fields, VolumeMount_inline)
}

type VolumeNodeAffinity struct {
	V *core.VolumeNodeAffinity
}

var (
	_ boxed = (*VolumeNodeAffinity)(nil)

	VolumeNodeAffinity_fields = map[string]util.FieldSpec{}
	VolumeNodeAffinity_inline = map[string]util.FieldSpec{}
	VolumeNodeAffinity_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.VolumeNodeAffinity)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.VolumeNodeAffinity:
			return VolumeNodeAffinity{V: v}
		case core.VolumeNodeAffinity:
			return VolumeNodeAffinity{V: &v}
		default:
			return skylark.None
		}
	}
	VolumeNodeAffinity_attrs = setFieldTypes(t, VolumeNodeAffinity_fields, VolumeNodeAffinity_inline)
	Library["VolumeNodeAffinity"] = skylark.NewBuiltin("VolumeNodeAffinity", createVolumeNodeAffinity)
}

func createVolumeNodeAffinity(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := VolumeNodeAffinity{V: &core.VolumeNodeAffinity{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t VolumeNodeAffinity) Underlying() interface{} { return t.V }
func (t VolumeNodeAffinity) DeepCopy() boxed         { return VolumeNodeAffinity{V: t.V.DeepCopy()} }
func (t VolumeNodeAffinity) Package() util.Package   { return util.Core }
func (t VolumeNodeAffinity) Type() string            { return "k8s_core_VolumeNodeAffinity" }
func (t VolumeNodeAffinity) String() string          { return t.V.String() }
func (t VolumeNodeAffinity) Freeze()                 {} // TODO
func (t VolumeNodeAffinity) Truth() skylark.Bool     { return skylark.True }
func (t VolumeNodeAffinity) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t VolumeNodeAffinity) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*VolumeNodeAffinity)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t VolumeNodeAffinity) AttrNames() []string { return VolumeNodeAffinity_attrs }
func (t VolumeNodeAffinity) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, VolumeNodeAffinity_fields, VolumeNodeAffinity_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t VolumeNodeAffinity) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, VolumeNodeAffinity_fields, VolumeNodeAffinity_inline)
}

type VolumeProjection struct {
	V *core.VolumeProjection
}

var (
	_ boxed = (*VolumeProjection)(nil)

	VolumeProjection_fields = map[string]util.FieldSpec{}
	VolumeProjection_inline = map[string]util.FieldSpec{}
	VolumeProjection_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.VolumeProjection)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.VolumeProjection:
			return VolumeProjection{V: v}
		case core.VolumeProjection:
			return VolumeProjection{V: &v}
		default:
			return skylark.None
		}
	}
	VolumeProjection_attrs = setFieldTypes(t, VolumeProjection_fields, VolumeProjection_inline)
	Library["VolumeProjection"] = skylark.NewBuiltin("VolumeProjection", createVolumeProjection)
}

func createVolumeProjection(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := VolumeProjection{V: &core.VolumeProjection{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t VolumeProjection) Underlying() interface{} { return t.V }
func (t VolumeProjection) DeepCopy() boxed         { return VolumeProjection{V: t.V.DeepCopy()} }
func (t VolumeProjection) Package() util.Package   { return util.Core }
func (t VolumeProjection) Type() string            { return "k8s_core_VolumeProjection" }
func (t VolumeProjection) String() string          { return t.V.String() }
func (t VolumeProjection) Freeze()                 {} // TODO
func (t VolumeProjection) Truth() skylark.Bool     { return skylark.True }
func (t VolumeProjection) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t VolumeProjection) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*VolumeProjection)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t VolumeProjection) AttrNames() []string { return VolumeProjection_attrs }
func (t VolumeProjection) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, VolumeProjection_fields, VolumeProjection_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t VolumeProjection) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, VolumeProjection_fields, VolumeProjection_inline)
}

type VolumeSource struct {
	V *core.VolumeSource
}

var (
	_ boxed = (*VolumeSource)(nil)

	VolumeSource_fields = map[string]util.FieldSpec{}
	VolumeSource_inline = map[string]util.FieldSpec{}
	VolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.VolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.VolumeSource:
			return VolumeSource{V: v}
		case core.VolumeSource:
			return VolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	VolumeSource_attrs = setFieldTypes(t, VolumeSource_fields, VolumeSource_inline)
	Library["VolumeSource"] = skylark.NewBuiltin("VolumeSource", createVolumeSource)
}

func createVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := VolumeSource{V: &core.VolumeSource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t VolumeSource) Underlying() interface{} { return t.V }
func (t VolumeSource) DeepCopy() boxed         { return VolumeSource{V: t.V.DeepCopy()} }
func (t VolumeSource) Package() util.Package   { return util.Core }
func (t VolumeSource) Type() string            { return "k8s_core_VolumeSource" }
func (t VolumeSource) String() string          { return t.V.String() }
func (t VolumeSource) Freeze()                 {} // TODO
func (t VolumeSource) Truth() skylark.Bool     { return skylark.True }
func (t VolumeSource) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t VolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*VolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t VolumeSource) AttrNames() []string { return VolumeSource_attrs }
func (t VolumeSource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, VolumeSource_fields, VolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t VolumeSource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, VolumeSource_fields, VolumeSource_inline)
}

type VsphereVirtualDiskVolumeSource struct {
	V *core.VsphereVirtualDiskVolumeSource
}

var (
	_ boxed = (*VsphereVirtualDiskVolumeSource)(nil)

	VsphereVirtualDiskVolumeSource_fields = map[string]util.FieldSpec{}
	VsphereVirtualDiskVolumeSource_inline = map[string]util.FieldSpec{}
	VsphereVirtualDiskVolumeSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.VsphereVirtualDiskVolumeSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.VsphereVirtualDiskVolumeSource:
			return VsphereVirtualDiskVolumeSource{V: v}
		case core.VsphereVirtualDiskVolumeSource:
			return VsphereVirtualDiskVolumeSource{V: &v}
		default:
			return skylark.None
		}
	}
	VsphereVirtualDiskVolumeSource_attrs = setFieldTypes(t, VsphereVirtualDiskVolumeSource_fields, VsphereVirtualDiskVolumeSource_inline)
	Library["VsphereVirtualDiskVolumeSource"] = skylark.NewBuiltin("VsphereVirtualDiskVolumeSource", createVsphereVirtualDiskVolumeSource)
}

func createVsphereVirtualDiskVolumeSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := VsphereVirtualDiskVolumeSource{V: &core.VsphereVirtualDiskVolumeSource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t VsphereVirtualDiskVolumeSource) Underlying() interface{} { return t.V }
func (t VsphereVirtualDiskVolumeSource) DeepCopy() boxed {
	return VsphereVirtualDiskVolumeSource{V: t.V.DeepCopy()}
}
func (t VsphereVirtualDiskVolumeSource) Package() util.Package { return util.Core }
func (t VsphereVirtualDiskVolumeSource) Type() string {
	return "k8s_core_VsphereVirtualDiskVolumeSource"
}
func (t VsphereVirtualDiskVolumeSource) String() string        { return t.V.String() }
func (t VsphereVirtualDiskVolumeSource) Freeze()               {} // TODO
func (t VsphereVirtualDiskVolumeSource) Truth() skylark.Bool   { return skylark.True }
func (t VsphereVirtualDiskVolumeSource) Hash() (uint32, error) { return 0, unhashable(t.Type()) }
func (t VsphereVirtualDiskVolumeSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*VsphereVirtualDiskVolumeSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t VsphereVirtualDiskVolumeSource) AttrNames() []string {
	return VsphereVirtualDiskVolumeSource_attrs
}
func (t VsphereVirtualDiskVolumeSource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, VsphereVirtualDiskVolumeSource_fields, VsphereVirtualDiskVolumeSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t VsphereVirtualDiskVolumeSource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, VsphereVirtualDiskVolumeSource_fields, VsphereVirtualDiskVolumeSource_inline)
}

type WeightedPodAffinityTerm struct {
	V *core.WeightedPodAffinityTerm
}

var (
	_ boxed = (*WeightedPodAffinityTerm)(nil)

	WeightedPodAffinityTerm_fields = map[string]util.FieldSpec{}
	WeightedPodAffinityTerm_inline = map[string]util.FieldSpec{}
	WeightedPodAffinityTerm_attrs  []string
)

func init() {
	t := reflect.TypeOf((*core.WeightedPodAffinityTerm)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *core.WeightedPodAffinityTerm:
			return WeightedPodAffinityTerm{V: v}
		case core.WeightedPodAffinityTerm:
			return WeightedPodAffinityTerm{V: &v}
		default:
			return skylark.None
		}
	}
	WeightedPodAffinityTerm_attrs = setFieldTypes(t, WeightedPodAffinityTerm_fields, WeightedPodAffinityTerm_inline)
	Library["WeightedPodAffinityTerm"] = skylark.NewBuiltin("WeightedPodAffinityTerm", createWeightedPodAffinityTerm)
}

func createWeightedPodAffinityTerm(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := WeightedPodAffinityTerm{V: &core.WeightedPodAffinityTerm{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t WeightedPodAffinityTerm) Underlying() interface{} { return t.V }
func (t WeightedPodAffinityTerm) DeepCopy() boxed         { return WeightedPodAffinityTerm{V: t.V.DeepCopy()} }
func (t WeightedPodAffinityTerm) Package() util.Package   { return util.Core }
func (t WeightedPodAffinityTerm) Type() string            { return "k8s_core_WeightedPodAffinityTerm" }
func (t WeightedPodAffinityTerm) String() string          { return t.V.String() }
func (t WeightedPodAffinityTerm) Freeze()                 {} // TODO
func (t WeightedPodAffinityTerm) Truth() skylark.Bool     { return skylark.True }
func (t WeightedPodAffinityTerm) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t WeightedPodAffinityTerm) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*WeightedPodAffinityTerm)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t WeightedPodAffinityTerm) AttrNames() []string { return WeightedPodAffinityTerm_attrs }
func (t WeightedPodAffinityTerm) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, WeightedPodAffinityTerm_fields, WeightedPodAffinityTerm_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t WeightedPodAffinityTerm) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, WeightedPodAffinityTerm_fields, WeightedPodAffinityTerm_inline)
}

type ControllerRevision struct {
	V *apps.ControllerRevision
}

var (
	_ boxed = (*ControllerRevision)(nil)

	ControllerRevision_fields = map[string]util.FieldSpec{}
	ControllerRevision_inline = map[string]util.FieldSpec{}
	ControllerRevision_attrs  []string
)

func init() {
	t := reflect.TypeOf((*apps.ControllerRevision)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *apps.ControllerRevision:
			return ControllerRevision{V: v}
		case apps.ControllerRevision:
			return ControllerRevision{V: &v}
		default:
			return skylark.None
		}
	}
	ControllerRevision_attrs = setFieldTypes(t, ControllerRevision_fields, ControllerRevision_inline)
	Library["ControllerRevision"] = skylark.NewBuiltin("ControllerRevision", createControllerRevision)
}

func createControllerRevision(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ControllerRevision{V: &apps.ControllerRevision{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ControllerRevision) Underlying() interface{} { return t.V }
func (t ControllerRevision) DeepCopy() boxed         { return ControllerRevision{V: t.V.DeepCopy()} }
func (t ControllerRevision) Package() util.Package   { return util.Apps }
func (t ControllerRevision) Type() string            { return "k8s_apps_ControllerRevision" }
func (t ControllerRevision) String() string          { return t.V.String() }
func (t ControllerRevision) Freeze()                 {} // TODO
func (t ControllerRevision) Truth() skylark.Bool     { return skylark.True }
func (t ControllerRevision) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ControllerRevision) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ControllerRevision)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ControllerRevision) AttrNames() []string { return ControllerRevision_attrs }
func (t ControllerRevision) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ControllerRevision_fields, ControllerRevision_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ControllerRevision) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ControllerRevision_fields, ControllerRevision_inline)
}

type ControllerRevisionList struct {
	V *apps.ControllerRevisionList
}

var (
	_ boxed = (*ControllerRevisionList)(nil)

	ControllerRevisionList_fields = map[string]util.FieldSpec{}
	ControllerRevisionList_inline = map[string]util.FieldSpec{}
	ControllerRevisionList_attrs  []string
)

func init() {
	t := reflect.TypeOf((*apps.ControllerRevisionList)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *apps.ControllerRevisionList:
			return ControllerRevisionList{V: v}
		case apps.ControllerRevisionList:
			return ControllerRevisionList{V: &v}
		default:
			return skylark.None
		}
	}
	ControllerRevisionList_attrs = setFieldTypes(t, ControllerRevisionList_fields, ControllerRevisionList_inline)
	Library["ControllerRevisionList"] = skylark.NewBuiltin("ControllerRevisionList", createControllerRevisionList)
}

func createControllerRevisionList(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ControllerRevisionList{V: &apps.ControllerRevisionList{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ControllerRevisionList) Underlying() interface{} { return t.V }
func (t ControllerRevisionList) DeepCopy() boxed         { return ControllerRevisionList{V: t.V.DeepCopy()} }
func (t ControllerRevisionList) Package() util.Package   { return util.Apps }
func (t ControllerRevisionList) Type() string            { return "k8s_apps_ControllerRevisionList" }
func (t ControllerRevisionList) String() string          { return t.V.String() }
func (t ControllerRevisionList) Freeze()                 {} // TODO
func (t ControllerRevisionList) Truth() skylark.Bool     { return skylark.True }
func (t ControllerRevisionList) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ControllerRevisionList) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ControllerRevisionList)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ControllerRevisionList) AttrNames() []string { return ControllerRevisionList_attrs }
func (t ControllerRevisionList) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ControllerRevisionList_fields, ControllerRevisionList_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ControllerRevisionList) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ControllerRevisionList_fields, ControllerRevisionList_inline)
}

type DaemonSet struct {
	V *apps.DaemonSet
}

var (
	_ boxed = (*DaemonSet)(nil)

	DaemonSet_fields = map[string]util.FieldSpec{}
	DaemonSet_inline = map[string]util.FieldSpec{}
	DaemonSet_attrs  []string
)

func init() {
	t := reflect.TypeOf((*apps.DaemonSet)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *apps.DaemonSet:
			return DaemonSet{V: v}
		case apps.DaemonSet:
			return DaemonSet{V: &v}
		default:
			return skylark.None
		}
	}
	DaemonSet_attrs = setFieldTypes(t, DaemonSet_fields, DaemonSet_inline)
	Library["DaemonSet"] = skylark.NewBuiltin("DaemonSet", createDaemonSet)
}

func createDaemonSet(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := DaemonSet{V: &apps.DaemonSet{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t DaemonSet) Underlying() interface{} { return t.V }
func (t DaemonSet) DeepCopy() boxed         { return DaemonSet{V: t.V.DeepCopy()} }
func (t DaemonSet) Package() util.Package   { return util.Apps }
func (t DaemonSet) Type() string            { return "k8s_apps_DaemonSet" }
func (t DaemonSet) String() string          { return t.V.String() }
func (t DaemonSet) Freeze()                 {} // TODO
func (t DaemonSet) Truth() skylark.Bool     { return skylark.True }
func (t DaemonSet) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t DaemonSet) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*DaemonSet)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t DaemonSet) AttrNames() []string { return DaemonSet_attrs }
func (t DaemonSet) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, DaemonSet_fields, DaemonSet_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t DaemonSet) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, DaemonSet_fields, DaemonSet_inline)
}

type DaemonSetCondition struct {
	V *apps.DaemonSetCondition
}

var (
	_ boxed = (*DaemonSetCondition)(nil)

	DaemonSetCondition_fields = map[string]util.FieldSpec{}
	DaemonSetCondition_inline = map[string]util.FieldSpec{}
	DaemonSetCondition_attrs  []string
)

func init() {
	t := reflect.TypeOf((*apps.DaemonSetCondition)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *apps.DaemonSetCondition:
			return DaemonSetCondition{V: v}
		case apps.DaemonSetCondition:
			return DaemonSetCondition{V: &v}
		default:
			return skylark.None
		}
	}
	DaemonSetCondition_attrs = setFieldTypes(t, DaemonSetCondition_fields, DaemonSetCondition_inline)
	Library["DaemonSetCondition"] = skylark.NewBuiltin("DaemonSetCondition", createDaemonSetCondition)
}

func createDaemonSetCondition(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := DaemonSetCondition{V: &apps.DaemonSetCondition{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t DaemonSetCondition) Underlying() interface{} { return t.V }
func (t DaemonSetCondition) DeepCopy() boxed         { return DaemonSetCondition{V: t.V.DeepCopy()} }
func (t DaemonSetCondition) Package() util.Package   { return util.Apps }
func (t DaemonSetCondition) Type() string            { return "k8s_apps_DaemonSetCondition" }
func (t DaemonSetCondition) String() string          { return t.V.String() }
func (t DaemonSetCondition) Freeze()                 {} // TODO
func (t DaemonSetCondition) Truth() skylark.Bool     { return skylark.True }
func (t DaemonSetCondition) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t DaemonSetCondition) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*DaemonSetCondition)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t DaemonSetCondition) AttrNames() []string { return DaemonSetCondition_attrs }
func (t DaemonSetCondition) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, DaemonSetCondition_fields, DaemonSetCondition_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t DaemonSetCondition) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, DaemonSetCondition_fields, DaemonSetCondition_inline)
}

type DaemonSetList struct {
	V *apps.DaemonSetList
}

var (
	_ boxed = (*DaemonSetList)(nil)

	DaemonSetList_fields = map[string]util.FieldSpec{}
	DaemonSetList_inline = map[string]util.FieldSpec{}
	DaemonSetList_attrs  []string
)

func init() {
	t := reflect.TypeOf((*apps.DaemonSetList)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *apps.DaemonSetList:
			return DaemonSetList{V: v}
		case apps.DaemonSetList:
			return DaemonSetList{V: &v}
		default:
			return skylark.None
		}
	}
	DaemonSetList_attrs = setFieldTypes(t, DaemonSetList_fields, DaemonSetList_inline)
	Library["DaemonSetList"] = skylark.NewBuiltin("DaemonSetList", createDaemonSetList)
}

func createDaemonSetList(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := DaemonSetList{V: &apps.DaemonSetList{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t DaemonSetList) Underlying() interface{} { return t.V }
func (t DaemonSetList) DeepCopy() boxed         { return DaemonSetList{V: t.V.DeepCopy()} }
func (t DaemonSetList) Package() util.Package   { return util.Apps }
func (t DaemonSetList) Type() string            { return "k8s_apps_DaemonSetList" }
func (t DaemonSetList) String() string          { return t.V.String() }
func (t DaemonSetList) Freeze()                 {} // TODO
func (t DaemonSetList) Truth() skylark.Bool     { return skylark.True }
func (t DaemonSetList) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t DaemonSetList) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*DaemonSetList)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t DaemonSetList) AttrNames() []string { return DaemonSetList_attrs }
func (t DaemonSetList) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, DaemonSetList_fields, DaemonSetList_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t DaemonSetList) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, DaemonSetList_fields, DaemonSetList_inline)
}

type DaemonSetSpec struct {
	V *apps.DaemonSetSpec
}

var (
	_ boxed = (*DaemonSetSpec)(nil)

	DaemonSetSpec_fields = map[string]util.FieldSpec{}
	DaemonSetSpec_inline = map[string]util.FieldSpec{}
	DaemonSetSpec_attrs  []string
)

func init() {
	t := reflect.TypeOf((*apps.DaemonSetSpec)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *apps.DaemonSetSpec:
			return DaemonSetSpec{V: v}
		case apps.DaemonSetSpec:
			return DaemonSetSpec{V: &v}
		default:
			return skylark.None
		}
	}
	DaemonSetSpec_attrs = setFieldTypes(t, DaemonSetSpec_fields, DaemonSetSpec_inline)
	Library["DaemonSetSpec"] = skylark.NewBuiltin("DaemonSetSpec", createDaemonSetSpec)
}

func createDaemonSetSpec(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := DaemonSetSpec{V: &apps.DaemonSetSpec{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t DaemonSetSpec) Underlying() interface{} { return t.V }
func (t DaemonSetSpec) DeepCopy() boxed         { return DaemonSetSpec{V: t.V.DeepCopy()} }
func (t DaemonSetSpec) Package() util.Package   { return util.Apps }
func (t DaemonSetSpec) Type() string            { return "k8s_apps_DaemonSetSpec" }
func (t DaemonSetSpec) String() string          { return t.V.String() }
func (t DaemonSetSpec) Freeze()                 {} // TODO
func (t DaemonSetSpec) Truth() skylark.Bool     { return skylark.True }
func (t DaemonSetSpec) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t DaemonSetSpec) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*DaemonSetSpec)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t DaemonSetSpec) AttrNames() []string { return DaemonSetSpec_attrs }
func (t DaemonSetSpec) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, DaemonSetSpec_fields, DaemonSetSpec_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t DaemonSetSpec) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, DaemonSetSpec_fields, DaemonSetSpec_inline)
}

type DaemonSetStatus struct {
	V *apps.DaemonSetStatus
}

var (
	_ boxed = (*DaemonSetStatus)(nil)

	DaemonSetStatus_fields = map[string]util.FieldSpec{}
	DaemonSetStatus_inline = map[string]util.FieldSpec{}
	DaemonSetStatus_attrs  []string
)

func init() {
	t := reflect.TypeOf((*apps.DaemonSetStatus)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *apps.DaemonSetStatus:
			return DaemonSetStatus{V: v}
		case apps.DaemonSetStatus:
			return DaemonSetStatus{V: &v}
		default:
			return skylark.None
		}
	}
	DaemonSetStatus_attrs = setFieldTypes(t, DaemonSetStatus_fields, DaemonSetStatus_inline)
	Library["DaemonSetStatus"] = skylark.NewBuiltin("DaemonSetStatus", createDaemonSetStatus)
}

func createDaemonSetStatus(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := DaemonSetStatus{V: &apps.DaemonSetStatus{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t DaemonSetStatus) Underlying() interface{} { return t.V }
func (t DaemonSetStatus) DeepCopy() boxed         { return DaemonSetStatus{V: t.V.DeepCopy()} }
func (t DaemonSetStatus) Package() util.Package   { return util.Apps }
func (t DaemonSetStatus) Type() string            { return "k8s_apps_DaemonSetStatus" }
func (t DaemonSetStatus) String() string          { return t.V.String() }
func (t DaemonSetStatus) Freeze()                 {} // TODO
func (t DaemonSetStatus) Truth() skylark.Bool     { return skylark.True }
func (t DaemonSetStatus) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t DaemonSetStatus) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*DaemonSetStatus)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t DaemonSetStatus) AttrNames() []string { return DaemonSetStatus_attrs }
func (t DaemonSetStatus) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, DaemonSetStatus_fields, DaemonSetStatus_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t DaemonSetStatus) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, DaemonSetStatus_fields, DaemonSetStatus_inline)
}

type DaemonSetUpdateStrategy struct {
	V *apps.DaemonSetUpdateStrategy
}

var (
	_ boxed = (*DaemonSetUpdateStrategy)(nil)

	DaemonSetUpdateStrategy_fields = map[string]util.FieldSpec{}
	DaemonSetUpdateStrategy_inline = map[string]util.FieldSpec{}
	DaemonSetUpdateStrategy_attrs  []string
)

func init() {
	t := reflect.TypeOf((*apps.DaemonSetUpdateStrategy)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *apps.DaemonSetUpdateStrategy:
			return DaemonSetUpdateStrategy{V: v}
		case apps.DaemonSetUpdateStrategy:
			return DaemonSetUpdateStrategy{V: &v}
		default:
			return skylark.None
		}
	}
	DaemonSetUpdateStrategy_attrs = setFieldTypes(t, DaemonSetUpdateStrategy_fields, DaemonSetUpdateStrategy_inline)
	Library["DaemonSetUpdateStrategy"] = skylark.NewBuiltin("DaemonSetUpdateStrategy", createDaemonSetUpdateStrategy)
}

func createDaemonSetUpdateStrategy(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := DaemonSetUpdateStrategy{V: &apps.DaemonSetUpdateStrategy{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t DaemonSetUpdateStrategy) Underlying() interface{} { return t.V }
func (t DaemonSetUpdateStrategy) DeepCopy() boxed         { return DaemonSetUpdateStrategy{V: t.V.DeepCopy()} }
func (t DaemonSetUpdateStrategy) Package() util.Package   { return util.Apps }
func (t DaemonSetUpdateStrategy) Type() string            { return "k8s_apps_DaemonSetUpdateStrategy" }
func (t DaemonSetUpdateStrategy) String() string          { return t.V.String() }
func (t DaemonSetUpdateStrategy) Freeze()                 {} // TODO
func (t DaemonSetUpdateStrategy) Truth() skylark.Bool     { return skylark.True }
func (t DaemonSetUpdateStrategy) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t DaemonSetUpdateStrategy) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*DaemonSetUpdateStrategy)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t DaemonSetUpdateStrategy) AttrNames() []string { return DaemonSetUpdateStrategy_attrs }
func (t DaemonSetUpdateStrategy) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, DaemonSetUpdateStrategy_fields, DaemonSetUpdateStrategy_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t DaemonSetUpdateStrategy) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, DaemonSetUpdateStrategy_fields, DaemonSetUpdateStrategy_inline)
}

type Deployment struct {
	V *apps.Deployment
}

var (
	_ boxed = (*Deployment)(nil)

	Deployment_fields = map[string]util.FieldSpec{}
	Deployment_inline = map[string]util.FieldSpec{}
	Deployment_attrs  []string
)

func init() {
	t := reflect.TypeOf((*apps.Deployment)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *apps.Deployment:
			return Deployment{V: v}
		case apps.Deployment:
			return Deployment{V: &v}
		default:
			return skylark.None
		}
	}
	Deployment_attrs = setFieldTypes(t, Deployment_fields, Deployment_inline)
	Library["Deployment"] = skylark.NewBuiltin("Deployment", createDeployment)
}

func createDeployment(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := Deployment{V: &apps.Deployment{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t Deployment) Underlying() interface{} { return t.V }
func (t Deployment) DeepCopy() boxed         { return Deployment{V: t.V.DeepCopy()} }
func (t Deployment) Package() util.Package   { return util.Apps }
func (t Deployment) Type() string            { return "k8s_apps_Deployment" }
func (t Deployment) String() string          { return t.V.String() }
func (t Deployment) Freeze()                 {} // TODO
func (t Deployment) Truth() skylark.Bool     { return skylark.True }
func (t Deployment) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t Deployment) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*Deployment)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t Deployment) AttrNames() []string { return Deployment_attrs }
func (t Deployment) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, Deployment_fields, Deployment_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t Deployment) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, Deployment_fields, Deployment_inline)
}

type DeploymentCondition struct {
	V *apps.DeploymentCondition
}

var (
	_ boxed = (*DeploymentCondition)(nil)

	DeploymentCondition_fields = map[string]util.FieldSpec{}
	DeploymentCondition_inline = map[string]util.FieldSpec{}
	DeploymentCondition_attrs  []string
)

func init() {
	t := reflect.TypeOf((*apps.DeploymentCondition)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *apps.DeploymentCondition:
			return DeploymentCondition{V: v}
		case apps.DeploymentCondition:
			return DeploymentCondition{V: &v}
		default:
			return skylark.None
		}
	}
	DeploymentCondition_attrs = setFieldTypes(t, DeploymentCondition_fields, DeploymentCondition_inline)
	Library["DeploymentCondition"] = skylark.NewBuiltin("DeploymentCondition", createDeploymentCondition)
}

func createDeploymentCondition(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := DeploymentCondition{V: &apps.DeploymentCondition{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t DeploymentCondition) Underlying() interface{} { return t.V }
func (t DeploymentCondition) DeepCopy() boxed         { return DeploymentCondition{V: t.V.DeepCopy()} }
func (t DeploymentCondition) Package() util.Package   { return util.Apps }
func (t DeploymentCondition) Type() string            { return "k8s_apps_DeploymentCondition" }
func (t DeploymentCondition) String() string          { return t.V.String() }
func (t DeploymentCondition) Freeze()                 {} // TODO
func (t DeploymentCondition) Truth() skylark.Bool     { return skylark.True }
func (t DeploymentCondition) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t DeploymentCondition) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*DeploymentCondition)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t DeploymentCondition) AttrNames() []string { return DeploymentCondition_attrs }
func (t DeploymentCondition) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, DeploymentCondition_fields, DeploymentCondition_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t DeploymentCondition) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, DeploymentCondition_fields, DeploymentCondition_inline)
}

type DeploymentList struct {
	V *apps.DeploymentList
}

var (
	_ boxed = (*DeploymentList)(nil)

	DeploymentList_fields = map[string]util.FieldSpec{}
	DeploymentList_inline = map[string]util.FieldSpec{}
	DeploymentList_attrs  []string
)

func init() {
	t := reflect.TypeOf((*apps.DeploymentList)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *apps.DeploymentList:
			return DeploymentList{V: v}
		case apps.DeploymentList:
			return DeploymentList{V: &v}
		default:
			return skylark.None
		}
	}
	DeploymentList_attrs = setFieldTypes(t, DeploymentList_fields, DeploymentList_inline)
	Library["DeploymentList"] = skylark.NewBuiltin("DeploymentList", createDeploymentList)
}

func createDeploymentList(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := DeploymentList{V: &apps.DeploymentList{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t DeploymentList) Underlying() interface{} { return t.V }
func (t DeploymentList) DeepCopy() boxed         { return DeploymentList{V: t.V.DeepCopy()} }
func (t DeploymentList) Package() util.Package   { return util.Apps }
func (t DeploymentList) Type() string            { return "k8s_apps_DeploymentList" }
func (t DeploymentList) String() string          { return t.V.String() }
func (t DeploymentList) Freeze()                 {} // TODO
func (t DeploymentList) Truth() skylark.Bool     { return skylark.True }
func (t DeploymentList) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t DeploymentList) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*DeploymentList)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t DeploymentList) AttrNames() []string { return DeploymentList_attrs }
func (t DeploymentList) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, DeploymentList_fields, DeploymentList_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t DeploymentList) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, DeploymentList_fields, DeploymentList_inline)
}

type DeploymentSpec struct {
	V *apps.DeploymentSpec
}

var (
	_ boxed = (*DeploymentSpec)(nil)

	DeploymentSpec_fields = map[string]util.FieldSpec{}
	DeploymentSpec_inline = map[string]util.FieldSpec{}
	DeploymentSpec_attrs  []string
)

func init() {
	t := reflect.TypeOf((*apps.DeploymentSpec)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *apps.DeploymentSpec:
			return DeploymentSpec{V: v}
		case apps.DeploymentSpec:
			return DeploymentSpec{V: &v}
		default:
			return skylark.None
		}
	}
	DeploymentSpec_attrs = setFieldTypes(t, DeploymentSpec_fields, DeploymentSpec_inline)
	Library["DeploymentSpec"] = skylark.NewBuiltin("DeploymentSpec", createDeploymentSpec)
}

func createDeploymentSpec(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := DeploymentSpec{V: &apps.DeploymentSpec{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t DeploymentSpec) Underlying() interface{} { return t.V }
func (t DeploymentSpec) DeepCopy() boxed         { return DeploymentSpec{V: t.V.DeepCopy()} }
func (t DeploymentSpec) Package() util.Package   { return util.Apps }
func (t DeploymentSpec) Type() string            { return "k8s_apps_DeploymentSpec" }
func (t DeploymentSpec) String() string          { return t.V.String() }
func (t DeploymentSpec) Freeze()                 {} // TODO
func (t DeploymentSpec) Truth() skylark.Bool     { return skylark.True }
func (t DeploymentSpec) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t DeploymentSpec) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*DeploymentSpec)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t DeploymentSpec) AttrNames() []string { return DeploymentSpec_attrs }
func (t DeploymentSpec) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, DeploymentSpec_fields, DeploymentSpec_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t DeploymentSpec) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, DeploymentSpec_fields, DeploymentSpec_inline)
}

type DeploymentStatus struct {
	V *apps.DeploymentStatus
}

var (
	_ boxed = (*DeploymentStatus)(nil)

	DeploymentStatus_fields = map[string]util.FieldSpec{}
	DeploymentStatus_inline = map[string]util.FieldSpec{}
	DeploymentStatus_attrs  []string
)

func init() {
	t := reflect.TypeOf((*apps.DeploymentStatus)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *apps.DeploymentStatus:
			return DeploymentStatus{V: v}
		case apps.DeploymentStatus:
			return DeploymentStatus{V: &v}
		default:
			return skylark.None
		}
	}
	DeploymentStatus_attrs = setFieldTypes(t, DeploymentStatus_fields, DeploymentStatus_inline)
	Library["DeploymentStatus"] = skylark.NewBuiltin("DeploymentStatus", createDeploymentStatus)
}

func createDeploymentStatus(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := DeploymentStatus{V: &apps.DeploymentStatus{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t DeploymentStatus) Underlying() interface{} { return t.V }
func (t DeploymentStatus) DeepCopy() boxed         { return DeploymentStatus{V: t.V.DeepCopy()} }
func (t DeploymentStatus) Package() util.Package   { return util.Apps }
func (t DeploymentStatus) Type() string            { return "k8s_apps_DeploymentStatus" }
func (t DeploymentStatus) String() string          { return t.V.String() }
func (t DeploymentStatus) Freeze()                 {} // TODO
func (t DeploymentStatus) Truth() skylark.Bool     { return skylark.True }
func (t DeploymentStatus) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t DeploymentStatus) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*DeploymentStatus)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t DeploymentStatus) AttrNames() []string { return DeploymentStatus_attrs }
func (t DeploymentStatus) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, DeploymentStatus_fields, DeploymentStatus_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t DeploymentStatus) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, DeploymentStatus_fields, DeploymentStatus_inline)
}

type DeploymentStrategy struct {
	V *apps.DeploymentStrategy
}

var (
	_ boxed = (*DeploymentStrategy)(nil)

	DeploymentStrategy_fields = map[string]util.FieldSpec{}
	DeploymentStrategy_inline = map[string]util.FieldSpec{}
	DeploymentStrategy_attrs  []string
)

func init() {
	t := reflect.TypeOf((*apps.DeploymentStrategy)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *apps.DeploymentStrategy:
			return DeploymentStrategy{V: v}
		case apps.DeploymentStrategy:
			return DeploymentStrategy{V: &v}
		default:
			return skylark.None
		}
	}
	DeploymentStrategy_attrs = setFieldTypes(t, DeploymentStrategy_fields, DeploymentStrategy_inline)
	Library["DeploymentStrategy"] = skylark.NewBuiltin("DeploymentStrategy", createDeploymentStrategy)
}

func createDeploymentStrategy(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := DeploymentStrategy{V: &apps.DeploymentStrategy{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t DeploymentStrategy) Underlying() interface{} { return t.V }
func (t DeploymentStrategy) DeepCopy() boxed         { return DeploymentStrategy{V: t.V.DeepCopy()} }
func (t DeploymentStrategy) Package() util.Package   { return util.Apps }
func (t DeploymentStrategy) Type() string            { return "k8s_apps_DeploymentStrategy" }
func (t DeploymentStrategy) String() string          { return t.V.String() }
func (t DeploymentStrategy) Freeze()                 {} // TODO
func (t DeploymentStrategy) Truth() skylark.Bool     { return skylark.True }
func (t DeploymentStrategy) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t DeploymentStrategy) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*DeploymentStrategy)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t DeploymentStrategy) AttrNames() []string { return DeploymentStrategy_attrs }
func (t DeploymentStrategy) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, DeploymentStrategy_fields, DeploymentStrategy_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t DeploymentStrategy) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, DeploymentStrategy_fields, DeploymentStrategy_inline)
}

type ReplicaSet struct {
	V *apps.ReplicaSet
}

var (
	_ boxed = (*ReplicaSet)(nil)

	ReplicaSet_fields = map[string]util.FieldSpec{}
	ReplicaSet_inline = map[string]util.FieldSpec{}
	ReplicaSet_attrs  []string
)

func init() {
	t := reflect.TypeOf((*apps.ReplicaSet)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *apps.ReplicaSet:
			return ReplicaSet{V: v}
		case apps.ReplicaSet:
			return ReplicaSet{V: &v}
		default:
			return skylark.None
		}
	}
	ReplicaSet_attrs = setFieldTypes(t, ReplicaSet_fields, ReplicaSet_inline)
	Library["ReplicaSet"] = skylark.NewBuiltin("ReplicaSet", createReplicaSet)
}

func createReplicaSet(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ReplicaSet{V: &apps.ReplicaSet{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ReplicaSet) Underlying() interface{} { return t.V }
func (t ReplicaSet) DeepCopy() boxed         { return ReplicaSet{V: t.V.DeepCopy()} }
func (t ReplicaSet) Package() util.Package   { return util.Apps }
func (t ReplicaSet) Type() string            { return "k8s_apps_ReplicaSet" }
func (t ReplicaSet) String() string          { return t.V.String() }
func (t ReplicaSet) Freeze()                 {} // TODO
func (t ReplicaSet) Truth() skylark.Bool     { return skylark.True }
func (t ReplicaSet) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ReplicaSet) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ReplicaSet)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ReplicaSet) AttrNames() []string { return ReplicaSet_attrs }
func (t ReplicaSet) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ReplicaSet_fields, ReplicaSet_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ReplicaSet) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ReplicaSet_fields, ReplicaSet_inline)
}

type ReplicaSetCondition struct {
	V *apps.ReplicaSetCondition
}

var (
	_ boxed = (*ReplicaSetCondition)(nil)

	ReplicaSetCondition_fields = map[string]util.FieldSpec{}
	ReplicaSetCondition_inline = map[string]util.FieldSpec{}
	ReplicaSetCondition_attrs  []string
)

func init() {
	t := reflect.TypeOf((*apps.ReplicaSetCondition)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *apps.ReplicaSetCondition:
			return ReplicaSetCondition{V: v}
		case apps.ReplicaSetCondition:
			return ReplicaSetCondition{V: &v}
		default:
			return skylark.None
		}
	}
	ReplicaSetCondition_attrs = setFieldTypes(t, ReplicaSetCondition_fields, ReplicaSetCondition_inline)
	Library["ReplicaSetCondition"] = skylark.NewBuiltin("ReplicaSetCondition", createReplicaSetCondition)
}

func createReplicaSetCondition(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ReplicaSetCondition{V: &apps.ReplicaSetCondition{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ReplicaSetCondition) Underlying() interface{} { return t.V }
func (t ReplicaSetCondition) DeepCopy() boxed         { return ReplicaSetCondition{V: t.V.DeepCopy()} }
func (t ReplicaSetCondition) Package() util.Package   { return util.Apps }
func (t ReplicaSetCondition) Type() string            { return "k8s_apps_ReplicaSetCondition" }
func (t ReplicaSetCondition) String() string          { return t.V.String() }
func (t ReplicaSetCondition) Freeze()                 {} // TODO
func (t ReplicaSetCondition) Truth() skylark.Bool     { return skylark.True }
func (t ReplicaSetCondition) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ReplicaSetCondition) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ReplicaSetCondition)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ReplicaSetCondition) AttrNames() []string { return ReplicaSetCondition_attrs }
func (t ReplicaSetCondition) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ReplicaSetCondition_fields, ReplicaSetCondition_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ReplicaSetCondition) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ReplicaSetCondition_fields, ReplicaSetCondition_inline)
}

type ReplicaSetList struct {
	V *apps.ReplicaSetList
}

var (
	_ boxed = (*ReplicaSetList)(nil)

	ReplicaSetList_fields = map[string]util.FieldSpec{}
	ReplicaSetList_inline = map[string]util.FieldSpec{}
	ReplicaSetList_attrs  []string
)

func init() {
	t := reflect.TypeOf((*apps.ReplicaSetList)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *apps.ReplicaSetList:
			return ReplicaSetList{V: v}
		case apps.ReplicaSetList:
			return ReplicaSetList{V: &v}
		default:
			return skylark.None
		}
	}
	ReplicaSetList_attrs = setFieldTypes(t, ReplicaSetList_fields, ReplicaSetList_inline)
	Library["ReplicaSetList"] = skylark.NewBuiltin("ReplicaSetList", createReplicaSetList)
}

func createReplicaSetList(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ReplicaSetList{V: &apps.ReplicaSetList{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ReplicaSetList) Underlying() interface{} { return t.V }
func (t ReplicaSetList) DeepCopy() boxed         { return ReplicaSetList{V: t.V.DeepCopy()} }
func (t ReplicaSetList) Package() util.Package   { return util.Apps }
func (t ReplicaSetList) Type() string            { return "k8s_apps_ReplicaSetList" }
func (t ReplicaSetList) String() string          { return t.V.String() }
func (t ReplicaSetList) Freeze()                 {} // TODO
func (t ReplicaSetList) Truth() skylark.Bool     { return skylark.True }
func (t ReplicaSetList) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ReplicaSetList) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ReplicaSetList)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ReplicaSetList) AttrNames() []string { return ReplicaSetList_attrs }
func (t ReplicaSetList) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ReplicaSetList_fields, ReplicaSetList_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ReplicaSetList) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ReplicaSetList_fields, ReplicaSetList_inline)
}

type ReplicaSetSpec struct {
	V *apps.ReplicaSetSpec
}

var (
	_ boxed = (*ReplicaSetSpec)(nil)

	ReplicaSetSpec_fields = map[string]util.FieldSpec{}
	ReplicaSetSpec_inline = map[string]util.FieldSpec{}
	ReplicaSetSpec_attrs  []string
)

func init() {
	t := reflect.TypeOf((*apps.ReplicaSetSpec)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *apps.ReplicaSetSpec:
			return ReplicaSetSpec{V: v}
		case apps.ReplicaSetSpec:
			return ReplicaSetSpec{V: &v}
		default:
			return skylark.None
		}
	}
	ReplicaSetSpec_attrs = setFieldTypes(t, ReplicaSetSpec_fields, ReplicaSetSpec_inline)
	Library["ReplicaSetSpec"] = skylark.NewBuiltin("ReplicaSetSpec", createReplicaSetSpec)
}

func createReplicaSetSpec(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ReplicaSetSpec{V: &apps.ReplicaSetSpec{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ReplicaSetSpec) Underlying() interface{} { return t.V }
func (t ReplicaSetSpec) DeepCopy() boxed         { return ReplicaSetSpec{V: t.V.DeepCopy()} }
func (t ReplicaSetSpec) Package() util.Package   { return util.Apps }
func (t ReplicaSetSpec) Type() string            { return "k8s_apps_ReplicaSetSpec" }
func (t ReplicaSetSpec) String() string          { return t.V.String() }
func (t ReplicaSetSpec) Freeze()                 {} // TODO
func (t ReplicaSetSpec) Truth() skylark.Bool     { return skylark.True }
func (t ReplicaSetSpec) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ReplicaSetSpec) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ReplicaSetSpec)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ReplicaSetSpec) AttrNames() []string { return ReplicaSetSpec_attrs }
func (t ReplicaSetSpec) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ReplicaSetSpec_fields, ReplicaSetSpec_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ReplicaSetSpec) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ReplicaSetSpec_fields, ReplicaSetSpec_inline)
}

type ReplicaSetStatus struct {
	V *apps.ReplicaSetStatus
}

var (
	_ boxed = (*ReplicaSetStatus)(nil)

	ReplicaSetStatus_fields = map[string]util.FieldSpec{}
	ReplicaSetStatus_inline = map[string]util.FieldSpec{}
	ReplicaSetStatus_attrs  []string
)

func init() {
	t := reflect.TypeOf((*apps.ReplicaSetStatus)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *apps.ReplicaSetStatus:
			return ReplicaSetStatus{V: v}
		case apps.ReplicaSetStatus:
			return ReplicaSetStatus{V: &v}
		default:
			return skylark.None
		}
	}
	ReplicaSetStatus_attrs = setFieldTypes(t, ReplicaSetStatus_fields, ReplicaSetStatus_inline)
	Library["ReplicaSetStatus"] = skylark.NewBuiltin("ReplicaSetStatus", createReplicaSetStatus)
}

func createReplicaSetStatus(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ReplicaSetStatus{V: &apps.ReplicaSetStatus{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ReplicaSetStatus) Underlying() interface{} { return t.V }
func (t ReplicaSetStatus) DeepCopy() boxed         { return ReplicaSetStatus{V: t.V.DeepCopy()} }
func (t ReplicaSetStatus) Package() util.Package   { return util.Apps }
func (t ReplicaSetStatus) Type() string            { return "k8s_apps_ReplicaSetStatus" }
func (t ReplicaSetStatus) String() string          { return t.V.String() }
func (t ReplicaSetStatus) Freeze()                 {} // TODO
func (t ReplicaSetStatus) Truth() skylark.Bool     { return skylark.True }
func (t ReplicaSetStatus) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ReplicaSetStatus) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ReplicaSetStatus)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ReplicaSetStatus) AttrNames() []string { return ReplicaSetStatus_attrs }
func (t ReplicaSetStatus) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ReplicaSetStatus_fields, ReplicaSetStatus_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ReplicaSetStatus) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ReplicaSetStatus_fields, ReplicaSetStatus_inline)
}

type RollingUpdateDaemonSet struct {
	V *apps.RollingUpdateDaemonSet
}

var (
	_ boxed = (*RollingUpdateDaemonSet)(nil)

	RollingUpdateDaemonSet_fields = map[string]util.FieldSpec{}
	RollingUpdateDaemonSet_inline = map[string]util.FieldSpec{}
	RollingUpdateDaemonSet_attrs  []string
)

func init() {
	t := reflect.TypeOf((*apps.RollingUpdateDaemonSet)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *apps.RollingUpdateDaemonSet:
			return RollingUpdateDaemonSet{V: v}
		case apps.RollingUpdateDaemonSet:
			return RollingUpdateDaemonSet{V: &v}
		default:
			return skylark.None
		}
	}
	RollingUpdateDaemonSet_attrs = setFieldTypes(t, RollingUpdateDaemonSet_fields, RollingUpdateDaemonSet_inline)
	Library["RollingUpdateDaemonSet"] = skylark.NewBuiltin("RollingUpdateDaemonSet", createRollingUpdateDaemonSet)
}

func createRollingUpdateDaemonSet(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := RollingUpdateDaemonSet{V: &apps.RollingUpdateDaemonSet{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t RollingUpdateDaemonSet) Underlying() interface{} { return t.V }
func (t RollingUpdateDaemonSet) DeepCopy() boxed         { return RollingUpdateDaemonSet{V: t.V.DeepCopy()} }
func (t RollingUpdateDaemonSet) Package() util.Package   { return util.Apps }
func (t RollingUpdateDaemonSet) Type() string            { return "k8s_apps_RollingUpdateDaemonSet" }
func (t RollingUpdateDaemonSet) String() string          { return t.V.String() }
func (t RollingUpdateDaemonSet) Freeze()                 {} // TODO
func (t RollingUpdateDaemonSet) Truth() skylark.Bool     { return skylark.True }
func (t RollingUpdateDaemonSet) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t RollingUpdateDaemonSet) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*RollingUpdateDaemonSet)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t RollingUpdateDaemonSet) AttrNames() []string { return RollingUpdateDaemonSet_attrs }
func (t RollingUpdateDaemonSet) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, RollingUpdateDaemonSet_fields, RollingUpdateDaemonSet_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t RollingUpdateDaemonSet) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, RollingUpdateDaemonSet_fields, RollingUpdateDaemonSet_inline)
}

type RollingUpdateDeployment struct {
	V *apps.RollingUpdateDeployment
}

var (
	_ boxed = (*RollingUpdateDeployment)(nil)

	RollingUpdateDeployment_fields = map[string]util.FieldSpec{}
	RollingUpdateDeployment_inline = map[string]util.FieldSpec{}
	RollingUpdateDeployment_attrs  []string
)

func init() {
	t := reflect.TypeOf((*apps.RollingUpdateDeployment)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *apps.RollingUpdateDeployment:
			return RollingUpdateDeployment{V: v}
		case apps.RollingUpdateDeployment:
			return RollingUpdateDeployment{V: &v}
		default:
			return skylark.None
		}
	}
	RollingUpdateDeployment_attrs = setFieldTypes(t, RollingUpdateDeployment_fields, RollingUpdateDeployment_inline)
	Library["RollingUpdateDeployment"] = skylark.NewBuiltin("RollingUpdateDeployment", createRollingUpdateDeployment)
}

func createRollingUpdateDeployment(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := RollingUpdateDeployment{V: &apps.RollingUpdateDeployment{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t RollingUpdateDeployment) Underlying() interface{} { return t.V }
func (t RollingUpdateDeployment) DeepCopy() boxed         { return RollingUpdateDeployment{V: t.V.DeepCopy()} }
func (t RollingUpdateDeployment) Package() util.Package   { return util.Apps }
func (t RollingUpdateDeployment) Type() string            { return "k8s_apps_RollingUpdateDeployment" }
func (t RollingUpdateDeployment) String() string          { return t.V.String() }
func (t RollingUpdateDeployment) Freeze()                 {} // TODO
func (t RollingUpdateDeployment) Truth() skylark.Bool     { return skylark.True }
func (t RollingUpdateDeployment) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t RollingUpdateDeployment) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*RollingUpdateDeployment)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t RollingUpdateDeployment) AttrNames() []string { return RollingUpdateDeployment_attrs }
func (t RollingUpdateDeployment) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, RollingUpdateDeployment_fields, RollingUpdateDeployment_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t RollingUpdateDeployment) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, RollingUpdateDeployment_fields, RollingUpdateDeployment_inline)
}

type RollingUpdateStatefulSetStrategy struct {
	V *apps.RollingUpdateStatefulSetStrategy
}

var (
	_ boxed = (*RollingUpdateStatefulSetStrategy)(nil)

	RollingUpdateStatefulSetStrategy_fields = map[string]util.FieldSpec{}
	RollingUpdateStatefulSetStrategy_inline = map[string]util.FieldSpec{}
	RollingUpdateStatefulSetStrategy_attrs  []string
)

func init() {
	t := reflect.TypeOf((*apps.RollingUpdateStatefulSetStrategy)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *apps.RollingUpdateStatefulSetStrategy:
			return RollingUpdateStatefulSetStrategy{V: v}
		case apps.RollingUpdateStatefulSetStrategy:
			return RollingUpdateStatefulSetStrategy{V: &v}
		default:
			return skylark.None
		}
	}
	RollingUpdateStatefulSetStrategy_attrs = setFieldTypes(t, RollingUpdateStatefulSetStrategy_fields, RollingUpdateStatefulSetStrategy_inline)
	Library["RollingUpdateStatefulSetStrategy"] = skylark.NewBuiltin("RollingUpdateStatefulSetStrategy", createRollingUpdateStatefulSetStrategy)
}

func createRollingUpdateStatefulSetStrategy(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := RollingUpdateStatefulSetStrategy{V: &apps.RollingUpdateStatefulSetStrategy{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t RollingUpdateStatefulSetStrategy) Underlying() interface{} { return t.V }
func (t RollingUpdateStatefulSetStrategy) DeepCopy() boxed {
	return RollingUpdateStatefulSetStrategy{V: t.V.DeepCopy()}
}
func (t RollingUpdateStatefulSetStrategy) Package() util.Package { return util.Apps }
func (t RollingUpdateStatefulSetStrategy) Type() string {
	return "k8s_apps_RollingUpdateStatefulSetStrategy"
}
func (t RollingUpdateStatefulSetStrategy) String() string        { return t.V.String() }
func (t RollingUpdateStatefulSetStrategy) Freeze()               {} // TODO
func (t RollingUpdateStatefulSetStrategy) Truth() skylark.Bool   { return skylark.True }
func (t RollingUpdateStatefulSetStrategy) Hash() (uint32, error) { return 0, unhashable(t.Type()) }
func (t RollingUpdateStatefulSetStrategy) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*RollingUpdateStatefulSetStrategy)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t RollingUpdateStatefulSetStrategy) AttrNames() []string {
	return RollingUpdateStatefulSetStrategy_attrs
}
func (t RollingUpdateStatefulSetStrategy) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, RollingUpdateStatefulSetStrategy_fields, RollingUpdateStatefulSetStrategy_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t RollingUpdateStatefulSetStrategy) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, RollingUpdateStatefulSetStrategy_fields, RollingUpdateStatefulSetStrategy_inline)
}

type StatefulSet struct {
	V *apps.StatefulSet
}

var (
	_ boxed = (*StatefulSet)(nil)

	StatefulSet_fields = map[string]util.FieldSpec{}
	StatefulSet_inline = map[string]util.FieldSpec{}
	StatefulSet_attrs  []string
)

func init() {
	t := reflect.TypeOf((*apps.StatefulSet)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *apps.StatefulSet:
			return StatefulSet{V: v}
		case apps.StatefulSet:
			return StatefulSet{V: &v}
		default:
			return skylark.None
		}
	}
	StatefulSet_attrs = setFieldTypes(t, StatefulSet_fields, StatefulSet_inline)
	Library["StatefulSet"] = skylark.NewBuiltin("StatefulSet", createStatefulSet)
}

func createStatefulSet(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := StatefulSet{V: &apps.StatefulSet{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t StatefulSet) Underlying() interface{} { return t.V }
func (t StatefulSet) DeepCopy() boxed         { return StatefulSet{V: t.V.DeepCopy()} }
func (t StatefulSet) Package() util.Package   { return util.Apps }
func (t StatefulSet) Type() string            { return "k8s_apps_StatefulSet" }
func (t StatefulSet) String() string          { return t.V.String() }
func (t StatefulSet) Freeze()                 {} // TODO
func (t StatefulSet) Truth() skylark.Bool     { return skylark.True }
func (t StatefulSet) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t StatefulSet) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*StatefulSet)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t StatefulSet) AttrNames() []string { return StatefulSet_attrs }
func (t StatefulSet) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, StatefulSet_fields, StatefulSet_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t StatefulSet) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, StatefulSet_fields, StatefulSet_inline)
}

type StatefulSetCondition struct {
	V *apps.StatefulSetCondition
}

var (
	_ boxed = (*StatefulSetCondition)(nil)

	StatefulSetCondition_fields = map[string]util.FieldSpec{}
	StatefulSetCondition_inline = map[string]util.FieldSpec{}
	StatefulSetCondition_attrs  []string
)

func init() {
	t := reflect.TypeOf((*apps.StatefulSetCondition)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *apps.StatefulSetCondition:
			return StatefulSetCondition{V: v}
		case apps.StatefulSetCondition:
			return StatefulSetCondition{V: &v}
		default:
			return skylark.None
		}
	}
	StatefulSetCondition_attrs = setFieldTypes(t, StatefulSetCondition_fields, StatefulSetCondition_inline)
	Library["StatefulSetCondition"] = skylark.NewBuiltin("StatefulSetCondition", createStatefulSetCondition)
}

func createStatefulSetCondition(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := StatefulSetCondition{V: &apps.StatefulSetCondition{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t StatefulSetCondition) Underlying() interface{} { return t.V }
func (t StatefulSetCondition) DeepCopy() boxed         { return StatefulSetCondition{V: t.V.DeepCopy()} }
func (t StatefulSetCondition) Package() util.Package   { return util.Apps }
func (t StatefulSetCondition) Type() string            { return "k8s_apps_StatefulSetCondition" }
func (t StatefulSetCondition) String() string          { return t.V.String() }
func (t StatefulSetCondition) Freeze()                 {} // TODO
func (t StatefulSetCondition) Truth() skylark.Bool     { return skylark.True }
func (t StatefulSetCondition) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t StatefulSetCondition) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*StatefulSetCondition)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t StatefulSetCondition) AttrNames() []string { return StatefulSetCondition_attrs }
func (t StatefulSetCondition) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, StatefulSetCondition_fields, StatefulSetCondition_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t StatefulSetCondition) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, StatefulSetCondition_fields, StatefulSetCondition_inline)
}

type StatefulSetList struct {
	V *apps.StatefulSetList
}

var (
	_ boxed = (*StatefulSetList)(nil)

	StatefulSetList_fields = map[string]util.FieldSpec{}
	StatefulSetList_inline = map[string]util.FieldSpec{}
	StatefulSetList_attrs  []string
)

func init() {
	t := reflect.TypeOf((*apps.StatefulSetList)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *apps.StatefulSetList:
			return StatefulSetList{V: v}
		case apps.StatefulSetList:
			return StatefulSetList{V: &v}
		default:
			return skylark.None
		}
	}
	StatefulSetList_attrs = setFieldTypes(t, StatefulSetList_fields, StatefulSetList_inline)
	Library["StatefulSetList"] = skylark.NewBuiltin("StatefulSetList", createStatefulSetList)
}

func createStatefulSetList(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := StatefulSetList{V: &apps.StatefulSetList{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t StatefulSetList) Underlying() interface{} { return t.V }
func (t StatefulSetList) DeepCopy() boxed         { return StatefulSetList{V: t.V.DeepCopy()} }
func (t StatefulSetList) Package() util.Package   { return util.Apps }
func (t StatefulSetList) Type() string            { return "k8s_apps_StatefulSetList" }
func (t StatefulSetList) String() string          { return t.V.String() }
func (t StatefulSetList) Freeze()                 {} // TODO
func (t StatefulSetList) Truth() skylark.Bool     { return skylark.True }
func (t StatefulSetList) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t StatefulSetList) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*StatefulSetList)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t StatefulSetList) AttrNames() []string { return StatefulSetList_attrs }
func (t StatefulSetList) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, StatefulSetList_fields, StatefulSetList_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t StatefulSetList) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, StatefulSetList_fields, StatefulSetList_inline)
}

type StatefulSetSpec struct {
	V *apps.StatefulSetSpec
}

var (
	_ boxed = (*StatefulSetSpec)(nil)

	StatefulSetSpec_fields = map[string]util.FieldSpec{}
	StatefulSetSpec_inline = map[string]util.FieldSpec{}
	StatefulSetSpec_attrs  []string
)

func init() {
	t := reflect.TypeOf((*apps.StatefulSetSpec)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *apps.StatefulSetSpec:
			return StatefulSetSpec{V: v}
		case apps.StatefulSetSpec:
			return StatefulSetSpec{V: &v}
		default:
			return skylark.None
		}
	}
	StatefulSetSpec_attrs = setFieldTypes(t, StatefulSetSpec_fields, StatefulSetSpec_inline)
	Library["StatefulSetSpec"] = skylark.NewBuiltin("StatefulSetSpec", createStatefulSetSpec)
}

func createStatefulSetSpec(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := StatefulSetSpec{V: &apps.StatefulSetSpec{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t StatefulSetSpec) Underlying() interface{} { return t.V }
func (t StatefulSetSpec) DeepCopy() boxed         { return StatefulSetSpec{V: t.V.DeepCopy()} }
func (t StatefulSetSpec) Package() util.Package   { return util.Apps }
func (t StatefulSetSpec) Type() string            { return "k8s_apps_StatefulSetSpec" }
func (t StatefulSetSpec) String() string          { return t.V.String() }
func (t StatefulSetSpec) Freeze()                 {} // TODO
func (t StatefulSetSpec) Truth() skylark.Bool     { return skylark.True }
func (t StatefulSetSpec) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t StatefulSetSpec) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*StatefulSetSpec)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t StatefulSetSpec) AttrNames() []string { return StatefulSetSpec_attrs }
func (t StatefulSetSpec) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, StatefulSetSpec_fields, StatefulSetSpec_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t StatefulSetSpec) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, StatefulSetSpec_fields, StatefulSetSpec_inline)
}

type StatefulSetStatus struct {
	V *apps.StatefulSetStatus
}

var (
	_ boxed = (*StatefulSetStatus)(nil)

	StatefulSetStatus_fields = map[string]util.FieldSpec{}
	StatefulSetStatus_inline = map[string]util.FieldSpec{}
	StatefulSetStatus_attrs  []string
)

func init() {
	t := reflect.TypeOf((*apps.StatefulSetStatus)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *apps.StatefulSetStatus:
			return StatefulSetStatus{V: v}
		case apps.StatefulSetStatus:
			return StatefulSetStatus{V: &v}
		default:
			return skylark.None
		}
	}
	StatefulSetStatus_attrs = setFieldTypes(t, StatefulSetStatus_fields, StatefulSetStatus_inline)
	Library["StatefulSetStatus"] = skylark.NewBuiltin("StatefulSetStatus", createStatefulSetStatus)
}

func createStatefulSetStatus(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := StatefulSetStatus{V: &apps.StatefulSetStatus{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t StatefulSetStatus) Underlying() interface{} { return t.V }
func (t StatefulSetStatus) DeepCopy() boxed         { return StatefulSetStatus{V: t.V.DeepCopy()} }
func (t StatefulSetStatus) Package() util.Package   { return util.Apps }
func (t StatefulSetStatus) Type() string            { return "k8s_apps_StatefulSetStatus" }
func (t StatefulSetStatus) String() string          { return t.V.String() }
func (t StatefulSetStatus) Freeze()                 {} // TODO
func (t StatefulSetStatus) Truth() skylark.Bool     { return skylark.True }
func (t StatefulSetStatus) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t StatefulSetStatus) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*StatefulSetStatus)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t StatefulSetStatus) AttrNames() []string { return StatefulSetStatus_attrs }
func (t StatefulSetStatus) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, StatefulSetStatus_fields, StatefulSetStatus_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t StatefulSetStatus) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, StatefulSetStatus_fields, StatefulSetStatus_inline)
}

type StatefulSetUpdateStrategy struct {
	V *apps.StatefulSetUpdateStrategy
}

var (
	_ boxed = (*StatefulSetUpdateStrategy)(nil)

	StatefulSetUpdateStrategy_fields = map[string]util.FieldSpec{}
	StatefulSetUpdateStrategy_inline = map[string]util.FieldSpec{}
	StatefulSetUpdateStrategy_attrs  []string
)

func init() {
	t := reflect.TypeOf((*apps.StatefulSetUpdateStrategy)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *apps.StatefulSetUpdateStrategy:
			return StatefulSetUpdateStrategy{V: v}
		case apps.StatefulSetUpdateStrategy:
			return StatefulSetUpdateStrategy{V: &v}
		default:
			return skylark.None
		}
	}
	StatefulSetUpdateStrategy_attrs = setFieldTypes(t, StatefulSetUpdateStrategy_fields, StatefulSetUpdateStrategy_inline)
	Library["StatefulSetUpdateStrategy"] = skylark.NewBuiltin("StatefulSetUpdateStrategy", createStatefulSetUpdateStrategy)
}

func createStatefulSetUpdateStrategy(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := StatefulSetUpdateStrategy{V: &apps.StatefulSetUpdateStrategy{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t StatefulSetUpdateStrategy) Underlying() interface{} { return t.V }
func (t StatefulSetUpdateStrategy) DeepCopy() boxed {
	return StatefulSetUpdateStrategy{V: t.V.DeepCopy()}
}
func (t StatefulSetUpdateStrategy) Package() util.Package { return util.Apps }
func (t StatefulSetUpdateStrategy) Type() string          { return "k8s_apps_StatefulSetUpdateStrategy" }
func (t StatefulSetUpdateStrategy) String() string        { return t.V.String() }
func (t StatefulSetUpdateStrategy) Freeze()               {} // TODO
func (t StatefulSetUpdateStrategy) Truth() skylark.Bool   { return skylark.True }
func (t StatefulSetUpdateStrategy) Hash() (uint32, error) { return 0, unhashable(t.Type()) }
func (t StatefulSetUpdateStrategy) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*StatefulSetUpdateStrategy)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t StatefulSetUpdateStrategy) AttrNames() []string { return StatefulSetUpdateStrategy_attrs }
func (t StatefulSetUpdateStrategy) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, StatefulSetUpdateStrategy_fields, StatefulSetUpdateStrategy_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t StatefulSetUpdateStrategy) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, StatefulSetUpdateStrategy_fields, StatefulSetUpdateStrategy_inline)
}

type CrossVersionObjectReference struct {
	V *autoscaling.CrossVersionObjectReference
}

var (
	_ boxed = (*CrossVersionObjectReference)(nil)

	CrossVersionObjectReference_fields = map[string]util.FieldSpec{}
	CrossVersionObjectReference_inline = map[string]util.FieldSpec{}
	CrossVersionObjectReference_attrs  []string
)

func init() {
	t := reflect.TypeOf((*autoscaling.CrossVersionObjectReference)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *autoscaling.CrossVersionObjectReference:
			return CrossVersionObjectReference{V: v}
		case autoscaling.CrossVersionObjectReference:
			return CrossVersionObjectReference{V: &v}
		default:
			return skylark.None
		}
	}
	CrossVersionObjectReference_attrs = setFieldTypes(t, CrossVersionObjectReference_fields, CrossVersionObjectReference_inline)
	Library["CrossVersionObjectReference"] = skylark.NewBuiltin("CrossVersionObjectReference", createCrossVersionObjectReference)
}

func createCrossVersionObjectReference(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := CrossVersionObjectReference{V: &autoscaling.CrossVersionObjectReference{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t CrossVersionObjectReference) Underlying() interface{} { return t.V }
func (t CrossVersionObjectReference) DeepCopy() boxed {
	return CrossVersionObjectReference{V: t.V.DeepCopy()}
}
func (t CrossVersionObjectReference) Package() util.Package { return util.Autoscaling }
func (t CrossVersionObjectReference) Type() string {
	return "k8s_autoscaling_CrossVersionObjectReference"
}
func (t CrossVersionObjectReference) String() string        { return t.V.String() }
func (t CrossVersionObjectReference) Freeze()               {} // TODO
func (t CrossVersionObjectReference) Truth() skylark.Bool   { return skylark.True }
func (t CrossVersionObjectReference) Hash() (uint32, error) { return 0, unhashable(t.Type()) }
func (t CrossVersionObjectReference) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*CrossVersionObjectReference)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t CrossVersionObjectReference) AttrNames() []string { return CrossVersionObjectReference_attrs }
func (t CrossVersionObjectReference) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, CrossVersionObjectReference_fields, CrossVersionObjectReference_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t CrossVersionObjectReference) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, CrossVersionObjectReference_fields, CrossVersionObjectReference_inline)
}

type ExternalMetricSource struct {
	V *autoscaling.ExternalMetricSource
}

var (
	_ boxed = (*ExternalMetricSource)(nil)

	ExternalMetricSource_fields = map[string]util.FieldSpec{}
	ExternalMetricSource_inline = map[string]util.FieldSpec{}
	ExternalMetricSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*autoscaling.ExternalMetricSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *autoscaling.ExternalMetricSource:
			return ExternalMetricSource{V: v}
		case autoscaling.ExternalMetricSource:
			return ExternalMetricSource{V: &v}
		default:
			return skylark.None
		}
	}
	ExternalMetricSource_attrs = setFieldTypes(t, ExternalMetricSource_fields, ExternalMetricSource_inline)
	Library["ExternalMetricSource"] = skylark.NewBuiltin("ExternalMetricSource", createExternalMetricSource)
}

func createExternalMetricSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ExternalMetricSource{V: &autoscaling.ExternalMetricSource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ExternalMetricSource) Underlying() interface{} { return t.V }
func (t ExternalMetricSource) DeepCopy() boxed         { return ExternalMetricSource{V: t.V.DeepCopy()} }
func (t ExternalMetricSource) Package() util.Package   { return util.Autoscaling }
func (t ExternalMetricSource) Type() string            { return "k8s_autoscaling_ExternalMetricSource" }
func (t ExternalMetricSource) String() string          { return t.V.String() }
func (t ExternalMetricSource) Freeze()                 {} // TODO
func (t ExternalMetricSource) Truth() skylark.Bool     { return skylark.True }
func (t ExternalMetricSource) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ExternalMetricSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ExternalMetricSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ExternalMetricSource) AttrNames() []string { return ExternalMetricSource_attrs }
func (t ExternalMetricSource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ExternalMetricSource_fields, ExternalMetricSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ExternalMetricSource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ExternalMetricSource_fields, ExternalMetricSource_inline)
}

type ExternalMetricStatus struct {
	V *autoscaling.ExternalMetricStatus
}

var (
	_ boxed = (*ExternalMetricStatus)(nil)

	ExternalMetricStatus_fields = map[string]util.FieldSpec{}
	ExternalMetricStatus_inline = map[string]util.FieldSpec{}
	ExternalMetricStatus_attrs  []string
)

func init() {
	t := reflect.TypeOf((*autoscaling.ExternalMetricStatus)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *autoscaling.ExternalMetricStatus:
			return ExternalMetricStatus{V: v}
		case autoscaling.ExternalMetricStatus:
			return ExternalMetricStatus{V: &v}
		default:
			return skylark.None
		}
	}
	ExternalMetricStatus_attrs = setFieldTypes(t, ExternalMetricStatus_fields, ExternalMetricStatus_inline)
	Library["ExternalMetricStatus"] = skylark.NewBuiltin("ExternalMetricStatus", createExternalMetricStatus)
}

func createExternalMetricStatus(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ExternalMetricStatus{V: &autoscaling.ExternalMetricStatus{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ExternalMetricStatus) Underlying() interface{} { return t.V }
func (t ExternalMetricStatus) DeepCopy() boxed         { return ExternalMetricStatus{V: t.V.DeepCopy()} }
func (t ExternalMetricStatus) Package() util.Package   { return util.Autoscaling }
func (t ExternalMetricStatus) Type() string            { return "k8s_autoscaling_ExternalMetricStatus" }
func (t ExternalMetricStatus) String() string          { return t.V.String() }
func (t ExternalMetricStatus) Freeze()                 {} // TODO
func (t ExternalMetricStatus) Truth() skylark.Bool     { return skylark.True }
func (t ExternalMetricStatus) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ExternalMetricStatus) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ExternalMetricStatus)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ExternalMetricStatus) AttrNames() []string { return ExternalMetricStatus_attrs }
func (t ExternalMetricStatus) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ExternalMetricStatus_fields, ExternalMetricStatus_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ExternalMetricStatus) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ExternalMetricStatus_fields, ExternalMetricStatus_inline)
}

type HorizontalPodAutoscaler struct {
	V *autoscaling.HorizontalPodAutoscaler
}

var (
	_ boxed = (*HorizontalPodAutoscaler)(nil)

	HorizontalPodAutoscaler_fields = map[string]util.FieldSpec{}
	HorizontalPodAutoscaler_inline = map[string]util.FieldSpec{}
	HorizontalPodAutoscaler_attrs  []string
)

func init() {
	t := reflect.TypeOf((*autoscaling.HorizontalPodAutoscaler)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *autoscaling.HorizontalPodAutoscaler:
			return HorizontalPodAutoscaler{V: v}
		case autoscaling.HorizontalPodAutoscaler:
			return HorizontalPodAutoscaler{V: &v}
		default:
			return skylark.None
		}
	}
	HorizontalPodAutoscaler_attrs = setFieldTypes(t, HorizontalPodAutoscaler_fields, HorizontalPodAutoscaler_inline)
	Library["HorizontalPodAutoscaler"] = skylark.NewBuiltin("HorizontalPodAutoscaler", createHorizontalPodAutoscaler)
}

func createHorizontalPodAutoscaler(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := HorizontalPodAutoscaler{V: &autoscaling.HorizontalPodAutoscaler{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t HorizontalPodAutoscaler) Underlying() interface{} { return t.V }
func (t HorizontalPodAutoscaler) DeepCopy() boxed         { return HorizontalPodAutoscaler{V: t.V.DeepCopy()} }
func (t HorizontalPodAutoscaler) Package() util.Package   { return util.Autoscaling }
func (t HorizontalPodAutoscaler) Type() string            { return "k8s_autoscaling_HorizontalPodAutoscaler" }
func (t HorizontalPodAutoscaler) String() string          { return t.V.String() }
func (t HorizontalPodAutoscaler) Freeze()                 {} // TODO
func (t HorizontalPodAutoscaler) Truth() skylark.Bool     { return skylark.True }
func (t HorizontalPodAutoscaler) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t HorizontalPodAutoscaler) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*HorizontalPodAutoscaler)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t HorizontalPodAutoscaler) AttrNames() []string { return HorizontalPodAutoscaler_attrs }
func (t HorizontalPodAutoscaler) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, HorizontalPodAutoscaler_fields, HorizontalPodAutoscaler_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t HorizontalPodAutoscaler) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, HorizontalPodAutoscaler_fields, HorizontalPodAutoscaler_inline)
}

type HorizontalPodAutoscalerCondition struct {
	V *autoscaling.HorizontalPodAutoscalerCondition
}

var (
	_ boxed = (*HorizontalPodAutoscalerCondition)(nil)

	HorizontalPodAutoscalerCondition_fields = map[string]util.FieldSpec{}
	HorizontalPodAutoscalerCondition_inline = map[string]util.FieldSpec{}
	HorizontalPodAutoscalerCondition_attrs  []string
)

func init() {
	t := reflect.TypeOf((*autoscaling.HorizontalPodAutoscalerCondition)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *autoscaling.HorizontalPodAutoscalerCondition:
			return HorizontalPodAutoscalerCondition{V: v}
		case autoscaling.HorizontalPodAutoscalerCondition:
			return HorizontalPodAutoscalerCondition{V: &v}
		default:
			return skylark.None
		}
	}
	HorizontalPodAutoscalerCondition_attrs = setFieldTypes(t, HorizontalPodAutoscalerCondition_fields, HorizontalPodAutoscalerCondition_inline)
	Library["HorizontalPodAutoscalerCondition"] = skylark.NewBuiltin("HorizontalPodAutoscalerCondition", createHorizontalPodAutoscalerCondition)
}

func createHorizontalPodAutoscalerCondition(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := HorizontalPodAutoscalerCondition{V: &autoscaling.HorizontalPodAutoscalerCondition{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t HorizontalPodAutoscalerCondition) Underlying() interface{} { return t.V }
func (t HorizontalPodAutoscalerCondition) DeepCopy() boxed {
	return HorizontalPodAutoscalerCondition{V: t.V.DeepCopy()}
}
func (t HorizontalPodAutoscalerCondition) Package() util.Package { return util.Autoscaling }
func (t HorizontalPodAutoscalerCondition) Type() string {
	return "k8s_autoscaling_HorizontalPodAutoscalerCondition"
}
func (t HorizontalPodAutoscalerCondition) String() string        { return t.V.String() }
func (t HorizontalPodAutoscalerCondition) Freeze()               {} // TODO
func (t HorizontalPodAutoscalerCondition) Truth() skylark.Bool   { return skylark.True }
func (t HorizontalPodAutoscalerCondition) Hash() (uint32, error) { return 0, unhashable(t.Type()) }
func (t HorizontalPodAutoscalerCondition) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*HorizontalPodAutoscalerCondition)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t HorizontalPodAutoscalerCondition) AttrNames() []string {
	return HorizontalPodAutoscalerCondition_attrs
}
func (t HorizontalPodAutoscalerCondition) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, HorizontalPodAutoscalerCondition_fields, HorizontalPodAutoscalerCondition_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t HorizontalPodAutoscalerCondition) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, HorizontalPodAutoscalerCondition_fields, HorizontalPodAutoscalerCondition_inline)
}

type HorizontalPodAutoscalerList struct {
	V *autoscaling.HorizontalPodAutoscalerList
}

var (
	_ boxed = (*HorizontalPodAutoscalerList)(nil)

	HorizontalPodAutoscalerList_fields = map[string]util.FieldSpec{}
	HorizontalPodAutoscalerList_inline = map[string]util.FieldSpec{}
	HorizontalPodAutoscalerList_attrs  []string
)

func init() {
	t := reflect.TypeOf((*autoscaling.HorizontalPodAutoscalerList)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *autoscaling.HorizontalPodAutoscalerList:
			return HorizontalPodAutoscalerList{V: v}
		case autoscaling.HorizontalPodAutoscalerList:
			return HorizontalPodAutoscalerList{V: &v}
		default:
			return skylark.None
		}
	}
	HorizontalPodAutoscalerList_attrs = setFieldTypes(t, HorizontalPodAutoscalerList_fields, HorizontalPodAutoscalerList_inline)
	Library["HorizontalPodAutoscalerList"] = skylark.NewBuiltin("HorizontalPodAutoscalerList", createHorizontalPodAutoscalerList)
}

func createHorizontalPodAutoscalerList(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := HorizontalPodAutoscalerList{V: &autoscaling.HorizontalPodAutoscalerList{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t HorizontalPodAutoscalerList) Underlying() interface{} { return t.V }
func (t HorizontalPodAutoscalerList) DeepCopy() boxed {
	return HorizontalPodAutoscalerList{V: t.V.DeepCopy()}
}
func (t HorizontalPodAutoscalerList) Package() util.Package { return util.Autoscaling }
func (t HorizontalPodAutoscalerList) Type() string {
	return "k8s_autoscaling_HorizontalPodAutoscalerList"
}
func (t HorizontalPodAutoscalerList) String() string        { return t.V.String() }
func (t HorizontalPodAutoscalerList) Freeze()               {} // TODO
func (t HorizontalPodAutoscalerList) Truth() skylark.Bool   { return skylark.True }
func (t HorizontalPodAutoscalerList) Hash() (uint32, error) { return 0, unhashable(t.Type()) }
func (t HorizontalPodAutoscalerList) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*HorizontalPodAutoscalerList)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t HorizontalPodAutoscalerList) AttrNames() []string { return HorizontalPodAutoscalerList_attrs }
func (t HorizontalPodAutoscalerList) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, HorizontalPodAutoscalerList_fields, HorizontalPodAutoscalerList_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t HorizontalPodAutoscalerList) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, HorizontalPodAutoscalerList_fields, HorizontalPodAutoscalerList_inline)
}

type HorizontalPodAutoscalerSpec struct {
	V *autoscaling.HorizontalPodAutoscalerSpec
}

var (
	_ boxed = (*HorizontalPodAutoscalerSpec)(nil)

	HorizontalPodAutoscalerSpec_fields = map[string]util.FieldSpec{}
	HorizontalPodAutoscalerSpec_inline = map[string]util.FieldSpec{}
	HorizontalPodAutoscalerSpec_attrs  []string
)

func init() {
	t := reflect.TypeOf((*autoscaling.HorizontalPodAutoscalerSpec)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *autoscaling.HorizontalPodAutoscalerSpec:
			return HorizontalPodAutoscalerSpec{V: v}
		case autoscaling.HorizontalPodAutoscalerSpec:
			return HorizontalPodAutoscalerSpec{V: &v}
		default:
			return skylark.None
		}
	}
	HorizontalPodAutoscalerSpec_attrs = setFieldTypes(t, HorizontalPodAutoscalerSpec_fields, HorizontalPodAutoscalerSpec_inline)
	Library["HorizontalPodAutoscalerSpec"] = skylark.NewBuiltin("HorizontalPodAutoscalerSpec", createHorizontalPodAutoscalerSpec)
}

func createHorizontalPodAutoscalerSpec(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := HorizontalPodAutoscalerSpec{V: &autoscaling.HorizontalPodAutoscalerSpec{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t HorizontalPodAutoscalerSpec) Underlying() interface{} { return t.V }
func (t HorizontalPodAutoscalerSpec) DeepCopy() boxed {
	return HorizontalPodAutoscalerSpec{V: t.V.DeepCopy()}
}
func (t HorizontalPodAutoscalerSpec) Package() util.Package { return util.Autoscaling }
func (t HorizontalPodAutoscalerSpec) Type() string {
	return "k8s_autoscaling_HorizontalPodAutoscalerSpec"
}
func (t HorizontalPodAutoscalerSpec) String() string        { return t.V.String() }
func (t HorizontalPodAutoscalerSpec) Freeze()               {} // TODO
func (t HorizontalPodAutoscalerSpec) Truth() skylark.Bool   { return skylark.True }
func (t HorizontalPodAutoscalerSpec) Hash() (uint32, error) { return 0, unhashable(t.Type()) }
func (t HorizontalPodAutoscalerSpec) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*HorizontalPodAutoscalerSpec)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t HorizontalPodAutoscalerSpec) AttrNames() []string { return HorizontalPodAutoscalerSpec_attrs }
func (t HorizontalPodAutoscalerSpec) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, HorizontalPodAutoscalerSpec_fields, HorizontalPodAutoscalerSpec_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t HorizontalPodAutoscalerSpec) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, HorizontalPodAutoscalerSpec_fields, HorizontalPodAutoscalerSpec_inline)
}

type HorizontalPodAutoscalerStatus struct {
	V *autoscaling.HorizontalPodAutoscalerStatus
}

var (
	_ boxed = (*HorizontalPodAutoscalerStatus)(nil)

	HorizontalPodAutoscalerStatus_fields = map[string]util.FieldSpec{}
	HorizontalPodAutoscalerStatus_inline = map[string]util.FieldSpec{}
	HorizontalPodAutoscalerStatus_attrs  []string
)

func init() {
	t := reflect.TypeOf((*autoscaling.HorizontalPodAutoscalerStatus)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *autoscaling.HorizontalPodAutoscalerStatus:
			return HorizontalPodAutoscalerStatus{V: v}
		case autoscaling.HorizontalPodAutoscalerStatus:
			return HorizontalPodAutoscalerStatus{V: &v}
		default:
			return skylark.None
		}
	}
	HorizontalPodAutoscalerStatus_attrs = setFieldTypes(t, HorizontalPodAutoscalerStatus_fields, HorizontalPodAutoscalerStatus_inline)
	Library["HorizontalPodAutoscalerStatus"] = skylark.NewBuiltin("HorizontalPodAutoscalerStatus", createHorizontalPodAutoscalerStatus)
}

func createHorizontalPodAutoscalerStatus(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := HorizontalPodAutoscalerStatus{V: &autoscaling.HorizontalPodAutoscalerStatus{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t HorizontalPodAutoscalerStatus) Underlying() interface{} { return t.V }
func (t HorizontalPodAutoscalerStatus) DeepCopy() boxed {
	return HorizontalPodAutoscalerStatus{V: t.V.DeepCopy()}
}
func (t HorizontalPodAutoscalerStatus) Package() util.Package { return util.Autoscaling }
func (t HorizontalPodAutoscalerStatus) Type() string {
	return "k8s_autoscaling_HorizontalPodAutoscalerStatus"
}
func (t HorizontalPodAutoscalerStatus) String() string        { return t.V.String() }
func (t HorizontalPodAutoscalerStatus) Freeze()               {} // TODO
func (t HorizontalPodAutoscalerStatus) Truth() skylark.Bool   { return skylark.True }
func (t HorizontalPodAutoscalerStatus) Hash() (uint32, error) { return 0, unhashable(t.Type()) }
func (t HorizontalPodAutoscalerStatus) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*HorizontalPodAutoscalerStatus)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t HorizontalPodAutoscalerStatus) AttrNames() []string {
	return HorizontalPodAutoscalerStatus_attrs
}
func (t HorizontalPodAutoscalerStatus) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, HorizontalPodAutoscalerStatus_fields, HorizontalPodAutoscalerStatus_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t HorizontalPodAutoscalerStatus) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, HorizontalPodAutoscalerStatus_fields, HorizontalPodAutoscalerStatus_inline)
}

type MetricSpec struct {
	V *autoscaling.MetricSpec
}

var (
	_ boxed = (*MetricSpec)(nil)

	MetricSpec_fields = map[string]util.FieldSpec{}
	MetricSpec_inline = map[string]util.FieldSpec{}
	MetricSpec_attrs  []string
)

func init() {
	t := reflect.TypeOf((*autoscaling.MetricSpec)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *autoscaling.MetricSpec:
			return MetricSpec{V: v}
		case autoscaling.MetricSpec:
			return MetricSpec{V: &v}
		default:
			return skylark.None
		}
	}
	MetricSpec_attrs = setFieldTypes(t, MetricSpec_fields, MetricSpec_inline)
	Library["MetricSpec"] = skylark.NewBuiltin("MetricSpec", createMetricSpec)
}

func createMetricSpec(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := MetricSpec{V: &autoscaling.MetricSpec{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t MetricSpec) Underlying() interface{} { return t.V }
func (t MetricSpec) DeepCopy() boxed         { return MetricSpec{V: t.V.DeepCopy()} }
func (t MetricSpec) Package() util.Package   { return util.Autoscaling }
func (t MetricSpec) Type() string            { return "k8s_autoscaling_MetricSpec" }
func (t MetricSpec) String() string          { return t.V.String() }
func (t MetricSpec) Freeze()                 {} // TODO
func (t MetricSpec) Truth() skylark.Bool     { return skylark.True }
func (t MetricSpec) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t MetricSpec) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*MetricSpec)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t MetricSpec) AttrNames() []string { return MetricSpec_attrs }
func (t MetricSpec) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, MetricSpec_fields, MetricSpec_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t MetricSpec) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, MetricSpec_fields, MetricSpec_inline)
}

type MetricStatus struct {
	V *autoscaling.MetricStatus
}

var (
	_ boxed = (*MetricStatus)(nil)

	MetricStatus_fields = map[string]util.FieldSpec{}
	MetricStatus_inline = map[string]util.FieldSpec{}
	MetricStatus_attrs  []string
)

func init() {
	t := reflect.TypeOf((*autoscaling.MetricStatus)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *autoscaling.MetricStatus:
			return MetricStatus{V: v}
		case autoscaling.MetricStatus:
			return MetricStatus{V: &v}
		default:
			return skylark.None
		}
	}
	MetricStatus_attrs = setFieldTypes(t, MetricStatus_fields, MetricStatus_inline)
	Library["MetricStatus"] = skylark.NewBuiltin("MetricStatus", createMetricStatus)
}

func createMetricStatus(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := MetricStatus{V: &autoscaling.MetricStatus{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t MetricStatus) Underlying() interface{} { return t.V }
func (t MetricStatus) DeepCopy() boxed         { return MetricStatus{V: t.V.DeepCopy()} }
func (t MetricStatus) Package() util.Package   { return util.Autoscaling }
func (t MetricStatus) Type() string            { return "k8s_autoscaling_MetricStatus" }
func (t MetricStatus) String() string          { return t.V.String() }
func (t MetricStatus) Freeze()                 {} // TODO
func (t MetricStatus) Truth() skylark.Bool     { return skylark.True }
func (t MetricStatus) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t MetricStatus) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*MetricStatus)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t MetricStatus) AttrNames() []string { return MetricStatus_attrs }
func (t MetricStatus) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, MetricStatus_fields, MetricStatus_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t MetricStatus) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, MetricStatus_fields, MetricStatus_inline)
}

type ObjectMetricSource struct {
	V *autoscaling.ObjectMetricSource
}

var (
	_ boxed = (*ObjectMetricSource)(nil)

	ObjectMetricSource_fields = map[string]util.FieldSpec{}
	ObjectMetricSource_inline = map[string]util.FieldSpec{}
	ObjectMetricSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*autoscaling.ObjectMetricSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *autoscaling.ObjectMetricSource:
			return ObjectMetricSource{V: v}
		case autoscaling.ObjectMetricSource:
			return ObjectMetricSource{V: &v}
		default:
			return skylark.None
		}
	}
	ObjectMetricSource_attrs = setFieldTypes(t, ObjectMetricSource_fields, ObjectMetricSource_inline)
	Library["ObjectMetricSource"] = skylark.NewBuiltin("ObjectMetricSource", createObjectMetricSource)
}

func createObjectMetricSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ObjectMetricSource{V: &autoscaling.ObjectMetricSource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ObjectMetricSource) Underlying() interface{} { return t.V }
func (t ObjectMetricSource) DeepCopy() boxed         { return ObjectMetricSource{V: t.V.DeepCopy()} }
func (t ObjectMetricSource) Package() util.Package   { return util.Autoscaling }
func (t ObjectMetricSource) Type() string            { return "k8s_autoscaling_ObjectMetricSource" }
func (t ObjectMetricSource) String() string          { return t.V.String() }
func (t ObjectMetricSource) Freeze()                 {} // TODO
func (t ObjectMetricSource) Truth() skylark.Bool     { return skylark.True }
func (t ObjectMetricSource) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ObjectMetricSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ObjectMetricSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ObjectMetricSource) AttrNames() []string { return ObjectMetricSource_attrs }
func (t ObjectMetricSource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ObjectMetricSource_fields, ObjectMetricSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ObjectMetricSource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ObjectMetricSource_fields, ObjectMetricSource_inline)
}

type ObjectMetricStatus struct {
	V *autoscaling.ObjectMetricStatus
}

var (
	_ boxed = (*ObjectMetricStatus)(nil)

	ObjectMetricStatus_fields = map[string]util.FieldSpec{}
	ObjectMetricStatus_inline = map[string]util.FieldSpec{}
	ObjectMetricStatus_attrs  []string
)

func init() {
	t := reflect.TypeOf((*autoscaling.ObjectMetricStatus)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *autoscaling.ObjectMetricStatus:
			return ObjectMetricStatus{V: v}
		case autoscaling.ObjectMetricStatus:
			return ObjectMetricStatus{V: &v}
		default:
			return skylark.None
		}
	}
	ObjectMetricStatus_attrs = setFieldTypes(t, ObjectMetricStatus_fields, ObjectMetricStatus_inline)
	Library["ObjectMetricStatus"] = skylark.NewBuiltin("ObjectMetricStatus", createObjectMetricStatus)
}

func createObjectMetricStatus(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ObjectMetricStatus{V: &autoscaling.ObjectMetricStatus{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ObjectMetricStatus) Underlying() interface{} { return t.V }
func (t ObjectMetricStatus) DeepCopy() boxed         { return ObjectMetricStatus{V: t.V.DeepCopy()} }
func (t ObjectMetricStatus) Package() util.Package   { return util.Autoscaling }
func (t ObjectMetricStatus) Type() string            { return "k8s_autoscaling_ObjectMetricStatus" }
func (t ObjectMetricStatus) String() string          { return t.V.String() }
func (t ObjectMetricStatus) Freeze()                 {} // TODO
func (t ObjectMetricStatus) Truth() skylark.Bool     { return skylark.True }
func (t ObjectMetricStatus) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ObjectMetricStatus) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ObjectMetricStatus)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ObjectMetricStatus) AttrNames() []string { return ObjectMetricStatus_attrs }
func (t ObjectMetricStatus) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ObjectMetricStatus_fields, ObjectMetricStatus_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ObjectMetricStatus) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ObjectMetricStatus_fields, ObjectMetricStatus_inline)
}

type PodsMetricSource struct {
	V *autoscaling.PodsMetricSource
}

var (
	_ boxed = (*PodsMetricSource)(nil)

	PodsMetricSource_fields = map[string]util.FieldSpec{}
	PodsMetricSource_inline = map[string]util.FieldSpec{}
	PodsMetricSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*autoscaling.PodsMetricSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *autoscaling.PodsMetricSource:
			return PodsMetricSource{V: v}
		case autoscaling.PodsMetricSource:
			return PodsMetricSource{V: &v}
		default:
			return skylark.None
		}
	}
	PodsMetricSource_attrs = setFieldTypes(t, PodsMetricSource_fields, PodsMetricSource_inline)
	Library["PodsMetricSource"] = skylark.NewBuiltin("PodsMetricSource", createPodsMetricSource)
}

func createPodsMetricSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := PodsMetricSource{V: &autoscaling.PodsMetricSource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t PodsMetricSource) Underlying() interface{} { return t.V }
func (t PodsMetricSource) DeepCopy() boxed         { return PodsMetricSource{V: t.V.DeepCopy()} }
func (t PodsMetricSource) Package() util.Package   { return util.Autoscaling }
func (t PodsMetricSource) Type() string            { return "k8s_autoscaling_PodsMetricSource" }
func (t PodsMetricSource) String() string          { return t.V.String() }
func (t PodsMetricSource) Freeze()                 {} // TODO
func (t PodsMetricSource) Truth() skylark.Bool     { return skylark.True }
func (t PodsMetricSource) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t PodsMetricSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PodsMetricSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PodsMetricSource) AttrNames() []string { return PodsMetricSource_attrs }
func (t PodsMetricSource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, PodsMetricSource_fields, PodsMetricSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t PodsMetricSource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, PodsMetricSource_fields, PodsMetricSource_inline)
}

type PodsMetricStatus struct {
	V *autoscaling.PodsMetricStatus
}

var (
	_ boxed = (*PodsMetricStatus)(nil)

	PodsMetricStatus_fields = map[string]util.FieldSpec{}
	PodsMetricStatus_inline = map[string]util.FieldSpec{}
	PodsMetricStatus_attrs  []string
)

func init() {
	t := reflect.TypeOf((*autoscaling.PodsMetricStatus)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *autoscaling.PodsMetricStatus:
			return PodsMetricStatus{V: v}
		case autoscaling.PodsMetricStatus:
			return PodsMetricStatus{V: &v}
		default:
			return skylark.None
		}
	}
	PodsMetricStatus_attrs = setFieldTypes(t, PodsMetricStatus_fields, PodsMetricStatus_inline)
	Library["PodsMetricStatus"] = skylark.NewBuiltin("PodsMetricStatus", createPodsMetricStatus)
}

func createPodsMetricStatus(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := PodsMetricStatus{V: &autoscaling.PodsMetricStatus{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t PodsMetricStatus) Underlying() interface{} { return t.V }
func (t PodsMetricStatus) DeepCopy() boxed         { return PodsMetricStatus{V: t.V.DeepCopy()} }
func (t PodsMetricStatus) Package() util.Package   { return util.Autoscaling }
func (t PodsMetricStatus) Type() string            { return "k8s_autoscaling_PodsMetricStatus" }
func (t PodsMetricStatus) String() string          { return t.V.String() }
func (t PodsMetricStatus) Freeze()                 {} // TODO
func (t PodsMetricStatus) Truth() skylark.Bool     { return skylark.True }
func (t PodsMetricStatus) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t PodsMetricStatus) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PodsMetricStatus)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PodsMetricStatus) AttrNames() []string { return PodsMetricStatus_attrs }
func (t PodsMetricStatus) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, PodsMetricStatus_fields, PodsMetricStatus_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t PodsMetricStatus) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, PodsMetricStatus_fields, PodsMetricStatus_inline)
}

type ResourceMetricSource struct {
	V *autoscaling.ResourceMetricSource
}

var (
	_ boxed = (*ResourceMetricSource)(nil)

	ResourceMetricSource_fields = map[string]util.FieldSpec{}
	ResourceMetricSource_inline = map[string]util.FieldSpec{}
	ResourceMetricSource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*autoscaling.ResourceMetricSource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *autoscaling.ResourceMetricSource:
			return ResourceMetricSource{V: v}
		case autoscaling.ResourceMetricSource:
			return ResourceMetricSource{V: &v}
		default:
			return skylark.None
		}
	}
	ResourceMetricSource_attrs = setFieldTypes(t, ResourceMetricSource_fields, ResourceMetricSource_inline)
	Library["ResourceMetricSource"] = skylark.NewBuiltin("ResourceMetricSource", createResourceMetricSource)
}

func createResourceMetricSource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ResourceMetricSource{V: &autoscaling.ResourceMetricSource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ResourceMetricSource) Underlying() interface{} { return t.V }
func (t ResourceMetricSource) DeepCopy() boxed         { return ResourceMetricSource{V: t.V.DeepCopy()} }
func (t ResourceMetricSource) Package() util.Package   { return util.Autoscaling }
func (t ResourceMetricSource) Type() string            { return "k8s_autoscaling_ResourceMetricSource" }
func (t ResourceMetricSource) String() string          { return t.V.String() }
func (t ResourceMetricSource) Freeze()                 {} // TODO
func (t ResourceMetricSource) Truth() skylark.Bool     { return skylark.True }
func (t ResourceMetricSource) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ResourceMetricSource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ResourceMetricSource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ResourceMetricSource) AttrNames() []string { return ResourceMetricSource_attrs }
func (t ResourceMetricSource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ResourceMetricSource_fields, ResourceMetricSource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ResourceMetricSource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ResourceMetricSource_fields, ResourceMetricSource_inline)
}

type ResourceMetricStatus struct {
	V *autoscaling.ResourceMetricStatus
}

var (
	_ boxed = (*ResourceMetricStatus)(nil)

	ResourceMetricStatus_fields = map[string]util.FieldSpec{}
	ResourceMetricStatus_inline = map[string]util.FieldSpec{}
	ResourceMetricStatus_attrs  []string
)

func init() {
	t := reflect.TypeOf((*autoscaling.ResourceMetricStatus)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *autoscaling.ResourceMetricStatus:
			return ResourceMetricStatus{V: v}
		case autoscaling.ResourceMetricStatus:
			return ResourceMetricStatus{V: &v}
		default:
			return skylark.None
		}
	}
	ResourceMetricStatus_attrs = setFieldTypes(t, ResourceMetricStatus_fields, ResourceMetricStatus_inline)
	Library["ResourceMetricStatus"] = skylark.NewBuiltin("ResourceMetricStatus", createResourceMetricStatus)
}

func createResourceMetricStatus(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ResourceMetricStatus{V: &autoscaling.ResourceMetricStatus{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ResourceMetricStatus) Underlying() interface{} { return t.V }
func (t ResourceMetricStatus) DeepCopy() boxed         { return ResourceMetricStatus{V: t.V.DeepCopy()} }
func (t ResourceMetricStatus) Package() util.Package   { return util.Autoscaling }
func (t ResourceMetricStatus) Type() string            { return "k8s_autoscaling_ResourceMetricStatus" }
func (t ResourceMetricStatus) String() string          { return t.V.String() }
func (t ResourceMetricStatus) Freeze()                 {} // TODO
func (t ResourceMetricStatus) Truth() skylark.Bool     { return skylark.True }
func (t ResourceMetricStatus) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ResourceMetricStatus) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ResourceMetricStatus)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ResourceMetricStatus) AttrNames() []string { return ResourceMetricStatus_attrs }
func (t ResourceMetricStatus) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ResourceMetricStatus_fields, ResourceMetricStatus_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ResourceMetricStatus) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ResourceMetricStatus_fields, ResourceMetricStatus_inline)
}

type Scale struct {
	V *autoscaling.Scale
}

var (
	_ boxed = (*Scale)(nil)

	Scale_fields = map[string]util.FieldSpec{}
	Scale_inline = map[string]util.FieldSpec{}
	Scale_attrs  []string
)

func init() {
	t := reflect.TypeOf((*autoscaling.Scale)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *autoscaling.Scale:
			return Scale{V: v}
		case autoscaling.Scale:
			return Scale{V: &v}
		default:
			return skylark.None
		}
	}
	Scale_attrs = setFieldTypes(t, Scale_fields, Scale_inline)
	Library["Scale"] = skylark.NewBuiltin("Scale", createScale)
}

func createScale(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := Scale{V: &autoscaling.Scale{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t Scale) Underlying() interface{} { return t.V }
func (t Scale) DeepCopy() boxed         { return Scale{V: t.V.DeepCopy()} }
func (t Scale) Package() util.Package   { return util.Autoscaling }
func (t Scale) Type() string            { return "k8s_autoscaling_Scale" }
func (t Scale) String() string          { return t.V.String() }
func (t Scale) Freeze()                 {} // TODO
func (t Scale) Truth() skylark.Bool     { return skylark.True }
func (t Scale) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t Scale) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*Scale)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t Scale) AttrNames() []string { return Scale_attrs }
func (t Scale) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, Scale_fields, Scale_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t Scale) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, Scale_fields, Scale_inline)
}

type ScaleSpec struct {
	V *autoscaling.ScaleSpec
}

var (
	_ boxed = (*ScaleSpec)(nil)

	ScaleSpec_fields = map[string]util.FieldSpec{}
	ScaleSpec_inline = map[string]util.FieldSpec{}
	ScaleSpec_attrs  []string
)

func init() {
	t := reflect.TypeOf((*autoscaling.ScaleSpec)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *autoscaling.ScaleSpec:
			return ScaleSpec{V: v}
		case autoscaling.ScaleSpec:
			return ScaleSpec{V: &v}
		default:
			return skylark.None
		}
	}
	ScaleSpec_attrs = setFieldTypes(t, ScaleSpec_fields, ScaleSpec_inline)
	Library["ScaleSpec"] = skylark.NewBuiltin("ScaleSpec", createScaleSpec)
}

func createScaleSpec(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ScaleSpec{V: &autoscaling.ScaleSpec{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ScaleSpec) Underlying() interface{} { return t.V }
func (t ScaleSpec) DeepCopy() boxed         { return ScaleSpec{V: t.V.DeepCopy()} }
func (t ScaleSpec) Package() util.Package   { return util.Autoscaling }
func (t ScaleSpec) Type() string            { return "k8s_autoscaling_ScaleSpec" }
func (t ScaleSpec) String() string          { return t.V.String() }
func (t ScaleSpec) Freeze()                 {} // TODO
func (t ScaleSpec) Truth() skylark.Bool     { return skylark.True }
func (t ScaleSpec) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ScaleSpec) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ScaleSpec)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ScaleSpec) AttrNames() []string { return ScaleSpec_attrs }
func (t ScaleSpec) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ScaleSpec_fields, ScaleSpec_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ScaleSpec) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ScaleSpec_fields, ScaleSpec_inline)
}

type ScaleStatus struct {
	V *autoscaling.ScaleStatus
}

var (
	_ boxed = (*ScaleStatus)(nil)

	ScaleStatus_fields = map[string]util.FieldSpec{}
	ScaleStatus_inline = map[string]util.FieldSpec{}
	ScaleStatus_attrs  []string
)

func init() {
	t := reflect.TypeOf((*autoscaling.ScaleStatus)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *autoscaling.ScaleStatus:
			return ScaleStatus{V: v}
		case autoscaling.ScaleStatus:
			return ScaleStatus{V: &v}
		default:
			return skylark.None
		}
	}
	ScaleStatus_attrs = setFieldTypes(t, ScaleStatus_fields, ScaleStatus_inline)
	Library["ScaleStatus"] = skylark.NewBuiltin("ScaleStatus", createScaleStatus)
}

func createScaleStatus(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ScaleStatus{V: &autoscaling.ScaleStatus{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ScaleStatus) Underlying() interface{} { return t.V }
func (t ScaleStatus) DeepCopy() boxed         { return ScaleStatus{V: t.V.DeepCopy()} }
func (t ScaleStatus) Package() util.Package   { return util.Autoscaling }
func (t ScaleStatus) Type() string            { return "k8s_autoscaling_ScaleStatus" }
func (t ScaleStatus) String() string          { return t.V.String() }
func (t ScaleStatus) Freeze()                 {} // TODO
func (t ScaleStatus) Truth() skylark.Bool     { return skylark.True }
func (t ScaleStatus) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ScaleStatus) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ScaleStatus)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ScaleStatus) AttrNames() []string { return ScaleStatus_attrs }
func (t ScaleStatus) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ScaleStatus_fields, ScaleStatus_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ScaleStatus) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ScaleStatus_fields, ScaleStatus_inline)
}

type Job struct {
	V *batch.Job
}

var (
	_ boxed = (*Job)(nil)

	Job_fields = map[string]util.FieldSpec{}
	Job_inline = map[string]util.FieldSpec{}
	Job_attrs  []string
)

func init() {
	t := reflect.TypeOf((*batch.Job)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *batch.Job:
			return Job{V: v}
		case batch.Job:
			return Job{V: &v}
		default:
			return skylark.None
		}
	}
	Job_attrs = setFieldTypes(t, Job_fields, Job_inline)
	Library["Job"] = skylark.NewBuiltin("Job", createJob)
}

func createJob(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := Job{V: &batch.Job{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t Job) Underlying() interface{} { return t.V }
func (t Job) DeepCopy() boxed         { return Job{V: t.V.DeepCopy()} }
func (t Job) Package() util.Package   { return util.Batch }
func (t Job) Type() string            { return "k8s_batch_Job" }
func (t Job) String() string          { return t.V.String() }
func (t Job) Freeze()                 {} // TODO
func (t Job) Truth() skylark.Bool     { return skylark.True }
func (t Job) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t Job) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*Job)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t Job) AttrNames() []string { return Job_attrs }
func (t Job) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, Job_fields, Job_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t Job) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, Job_fields, Job_inline)
}

type JobCondition struct {
	V *batch.JobCondition
}

var (
	_ boxed = (*JobCondition)(nil)

	JobCondition_fields = map[string]util.FieldSpec{}
	JobCondition_inline = map[string]util.FieldSpec{}
	JobCondition_attrs  []string
)

func init() {
	t := reflect.TypeOf((*batch.JobCondition)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *batch.JobCondition:
			return JobCondition{V: v}
		case batch.JobCondition:
			return JobCondition{V: &v}
		default:
			return skylark.None
		}
	}
	JobCondition_attrs = setFieldTypes(t, JobCondition_fields, JobCondition_inline)
	Library["JobCondition"] = skylark.NewBuiltin("JobCondition", createJobCondition)
}

func createJobCondition(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := JobCondition{V: &batch.JobCondition{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t JobCondition) Underlying() interface{} { return t.V }
func (t JobCondition) DeepCopy() boxed         { return JobCondition{V: t.V.DeepCopy()} }
func (t JobCondition) Package() util.Package   { return util.Batch }
func (t JobCondition) Type() string            { return "k8s_batch_JobCondition" }
func (t JobCondition) String() string          { return t.V.String() }
func (t JobCondition) Freeze()                 {} // TODO
func (t JobCondition) Truth() skylark.Bool     { return skylark.True }
func (t JobCondition) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t JobCondition) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*JobCondition)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t JobCondition) AttrNames() []string { return JobCondition_attrs }
func (t JobCondition) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, JobCondition_fields, JobCondition_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t JobCondition) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, JobCondition_fields, JobCondition_inline)
}

type JobList struct {
	V *batch.JobList
}

var (
	_ boxed = (*JobList)(nil)

	JobList_fields = map[string]util.FieldSpec{}
	JobList_inline = map[string]util.FieldSpec{}
	JobList_attrs  []string
)

func init() {
	t := reflect.TypeOf((*batch.JobList)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *batch.JobList:
			return JobList{V: v}
		case batch.JobList:
			return JobList{V: &v}
		default:
			return skylark.None
		}
	}
	JobList_attrs = setFieldTypes(t, JobList_fields, JobList_inline)
	Library["JobList"] = skylark.NewBuiltin("JobList", createJobList)
}

func createJobList(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := JobList{V: &batch.JobList{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t JobList) Underlying() interface{} { return t.V }
func (t JobList) DeepCopy() boxed         { return JobList{V: t.V.DeepCopy()} }
func (t JobList) Package() util.Package   { return util.Batch }
func (t JobList) Type() string            { return "k8s_batch_JobList" }
func (t JobList) String() string          { return t.V.String() }
func (t JobList) Freeze()                 {} // TODO
func (t JobList) Truth() skylark.Bool     { return skylark.True }
func (t JobList) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t JobList) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*JobList)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t JobList) AttrNames() []string { return JobList_attrs }
func (t JobList) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, JobList_fields, JobList_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t JobList) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, JobList_fields, JobList_inline)
}

type JobSpec struct {
	V *batch.JobSpec
}

var (
	_ boxed = (*JobSpec)(nil)

	JobSpec_fields = map[string]util.FieldSpec{}
	JobSpec_inline = map[string]util.FieldSpec{}
	JobSpec_attrs  []string
)

func init() {
	t := reflect.TypeOf((*batch.JobSpec)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *batch.JobSpec:
			return JobSpec{V: v}
		case batch.JobSpec:
			return JobSpec{V: &v}
		default:
			return skylark.None
		}
	}
	JobSpec_attrs = setFieldTypes(t, JobSpec_fields, JobSpec_inline)
	Library["JobSpec"] = skylark.NewBuiltin("JobSpec", createJobSpec)
}

func createJobSpec(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := JobSpec{V: &batch.JobSpec{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t JobSpec) Underlying() interface{} { return t.V }
func (t JobSpec) DeepCopy() boxed         { return JobSpec{V: t.V.DeepCopy()} }
func (t JobSpec) Package() util.Package   { return util.Batch }
func (t JobSpec) Type() string            { return "k8s_batch_JobSpec" }
func (t JobSpec) String() string          { return t.V.String() }
func (t JobSpec) Freeze()                 {} // TODO
func (t JobSpec) Truth() skylark.Bool     { return skylark.True }
func (t JobSpec) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t JobSpec) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*JobSpec)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t JobSpec) AttrNames() []string { return JobSpec_attrs }
func (t JobSpec) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, JobSpec_fields, JobSpec_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t JobSpec) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, JobSpec_fields, JobSpec_inline)
}

type JobStatus struct {
	V *batch.JobStatus
}

var (
	_ boxed = (*JobStatus)(nil)

	JobStatus_fields = map[string]util.FieldSpec{}
	JobStatus_inline = map[string]util.FieldSpec{}
	JobStatus_attrs  []string
)

func init() {
	t := reflect.TypeOf((*batch.JobStatus)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *batch.JobStatus:
			return JobStatus{V: v}
		case batch.JobStatus:
			return JobStatus{V: &v}
		default:
			return skylark.None
		}
	}
	JobStatus_attrs = setFieldTypes(t, JobStatus_fields, JobStatus_inline)
	Library["JobStatus"] = skylark.NewBuiltin("JobStatus", createJobStatus)
}

func createJobStatus(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := JobStatus{V: &batch.JobStatus{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t JobStatus) Underlying() interface{} { return t.V }
func (t JobStatus) DeepCopy() boxed         { return JobStatus{V: t.V.DeepCopy()} }
func (t JobStatus) Package() util.Package   { return util.Batch }
func (t JobStatus) Type() string            { return "k8s_batch_JobStatus" }
func (t JobStatus) String() string          { return t.V.String() }
func (t JobStatus) Freeze()                 {} // TODO
func (t JobStatus) Truth() skylark.Bool     { return skylark.True }
func (t JobStatus) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t JobStatus) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*JobStatus)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t JobStatus) AttrNames() []string { return JobStatus_attrs }
func (t JobStatus) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, JobStatus_fields, JobStatus_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t JobStatus) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, JobStatus_fields, JobStatus_inline)
}

type BoundObjectReference struct {
	V *authentication.BoundObjectReference
}

var (
	_ boxed = (*BoundObjectReference)(nil)

	BoundObjectReference_fields = map[string]util.FieldSpec{}
	BoundObjectReference_inline = map[string]util.FieldSpec{}
	BoundObjectReference_attrs  []string
)

func init() {
	t := reflect.TypeOf((*authentication.BoundObjectReference)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *authentication.BoundObjectReference:
			return BoundObjectReference{V: v}
		case authentication.BoundObjectReference:
			return BoundObjectReference{V: &v}
		default:
			return skylark.None
		}
	}
	BoundObjectReference_attrs = setFieldTypes(t, BoundObjectReference_fields, BoundObjectReference_inline)
	Library["BoundObjectReference"] = skylark.NewBuiltin("BoundObjectReference", createBoundObjectReference)
}

func createBoundObjectReference(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := BoundObjectReference{V: &authentication.BoundObjectReference{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t BoundObjectReference) Underlying() interface{} { return t.V }
func (t BoundObjectReference) DeepCopy() boxed         { return BoundObjectReference{V: t.V.DeepCopy()} }
func (t BoundObjectReference) Package() util.Package   { return util.Authentication }
func (t BoundObjectReference) Type() string            { return "k8s_authentication_BoundObjectReference" }
func (t BoundObjectReference) String() string          { return t.V.String() }
func (t BoundObjectReference) Freeze()                 {} // TODO
func (t BoundObjectReference) Truth() skylark.Bool     { return skylark.True }
func (t BoundObjectReference) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t BoundObjectReference) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*BoundObjectReference)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t BoundObjectReference) AttrNames() []string { return BoundObjectReference_attrs }
func (t BoundObjectReference) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, BoundObjectReference_fields, BoundObjectReference_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t BoundObjectReference) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, BoundObjectReference_fields, BoundObjectReference_inline)
}

type TokenRequest struct {
	V *authentication.TokenRequest
}

var (
	_ boxed = (*TokenRequest)(nil)

	TokenRequest_fields = map[string]util.FieldSpec{}
	TokenRequest_inline = map[string]util.FieldSpec{}
	TokenRequest_attrs  []string
)

func init() {
	t := reflect.TypeOf((*authentication.TokenRequest)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *authentication.TokenRequest:
			return TokenRequest{V: v}
		case authentication.TokenRequest:
			return TokenRequest{V: &v}
		default:
			return skylark.None
		}
	}
	TokenRequest_attrs = setFieldTypes(t, TokenRequest_fields, TokenRequest_inline)
	Library["TokenRequest"] = skylark.NewBuiltin("TokenRequest", createTokenRequest)
}

func createTokenRequest(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := TokenRequest{V: &authentication.TokenRequest{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t TokenRequest) Underlying() interface{} { return t.V }
func (t TokenRequest) DeepCopy() boxed         { return TokenRequest{V: t.V.DeepCopy()} }
func (t TokenRequest) Package() util.Package   { return util.Authentication }
func (t TokenRequest) Type() string            { return "k8s_authentication_TokenRequest" }
func (t TokenRequest) String() string          { return t.V.String() }
func (t TokenRequest) Freeze()                 {} // TODO
func (t TokenRequest) Truth() skylark.Bool     { return skylark.True }
func (t TokenRequest) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t TokenRequest) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*TokenRequest)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t TokenRequest) AttrNames() []string { return TokenRequest_attrs }
func (t TokenRequest) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, TokenRequest_fields, TokenRequest_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t TokenRequest) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, TokenRequest_fields, TokenRequest_inline)
}

type TokenRequestSpec struct {
	V *authentication.TokenRequestSpec
}

var (
	_ boxed = (*TokenRequestSpec)(nil)

	TokenRequestSpec_fields = map[string]util.FieldSpec{}
	TokenRequestSpec_inline = map[string]util.FieldSpec{}
	TokenRequestSpec_attrs  []string
)

func init() {
	t := reflect.TypeOf((*authentication.TokenRequestSpec)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *authentication.TokenRequestSpec:
			return TokenRequestSpec{V: v}
		case authentication.TokenRequestSpec:
			return TokenRequestSpec{V: &v}
		default:
			return skylark.None
		}
	}
	TokenRequestSpec_attrs = setFieldTypes(t, TokenRequestSpec_fields, TokenRequestSpec_inline)
	Library["TokenRequestSpec"] = skylark.NewBuiltin("TokenRequestSpec", createTokenRequestSpec)
}

func createTokenRequestSpec(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := TokenRequestSpec{V: &authentication.TokenRequestSpec{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t TokenRequestSpec) Underlying() interface{} { return t.V }
func (t TokenRequestSpec) DeepCopy() boxed         { return TokenRequestSpec{V: t.V.DeepCopy()} }
func (t TokenRequestSpec) Package() util.Package   { return util.Authentication }
func (t TokenRequestSpec) Type() string            { return "k8s_authentication_TokenRequestSpec" }
func (t TokenRequestSpec) String() string          { return t.V.String() }
func (t TokenRequestSpec) Freeze()                 {} // TODO
func (t TokenRequestSpec) Truth() skylark.Bool     { return skylark.True }
func (t TokenRequestSpec) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t TokenRequestSpec) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*TokenRequestSpec)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t TokenRequestSpec) AttrNames() []string { return TokenRequestSpec_attrs }
func (t TokenRequestSpec) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, TokenRequestSpec_fields, TokenRequestSpec_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t TokenRequestSpec) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, TokenRequestSpec_fields, TokenRequestSpec_inline)
}

type TokenRequestStatus struct {
	V *authentication.TokenRequestStatus
}

var (
	_ boxed = (*TokenRequestStatus)(nil)

	TokenRequestStatus_fields = map[string]util.FieldSpec{}
	TokenRequestStatus_inline = map[string]util.FieldSpec{}
	TokenRequestStatus_attrs  []string
)

func init() {
	t := reflect.TypeOf((*authentication.TokenRequestStatus)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *authentication.TokenRequestStatus:
			return TokenRequestStatus{V: v}
		case authentication.TokenRequestStatus:
			return TokenRequestStatus{V: &v}
		default:
			return skylark.None
		}
	}
	TokenRequestStatus_attrs = setFieldTypes(t, TokenRequestStatus_fields, TokenRequestStatus_inline)
	Library["TokenRequestStatus"] = skylark.NewBuiltin("TokenRequestStatus", createTokenRequestStatus)
}

func createTokenRequestStatus(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := TokenRequestStatus{V: &authentication.TokenRequestStatus{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t TokenRequestStatus) Underlying() interface{} { return t.V }
func (t TokenRequestStatus) DeepCopy() boxed         { return TokenRequestStatus{V: t.V.DeepCopy()} }
func (t TokenRequestStatus) Package() util.Package   { return util.Authentication }
func (t TokenRequestStatus) Type() string            { return "k8s_authentication_TokenRequestStatus" }
func (t TokenRequestStatus) String() string          { return t.V.String() }
func (t TokenRequestStatus) Freeze()                 {} // TODO
func (t TokenRequestStatus) Truth() skylark.Bool     { return skylark.True }
func (t TokenRequestStatus) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t TokenRequestStatus) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*TokenRequestStatus)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t TokenRequestStatus) AttrNames() []string { return TokenRequestStatus_attrs }
func (t TokenRequestStatus) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, TokenRequestStatus_fields, TokenRequestStatus_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t TokenRequestStatus) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, TokenRequestStatus_fields, TokenRequestStatus_inline)
}

type TokenReview struct {
	V *authentication.TokenReview
}

var (
	_ boxed = (*TokenReview)(nil)

	TokenReview_fields = map[string]util.FieldSpec{}
	TokenReview_inline = map[string]util.FieldSpec{}
	TokenReview_attrs  []string
)

func init() {
	t := reflect.TypeOf((*authentication.TokenReview)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *authentication.TokenReview:
			return TokenReview{V: v}
		case authentication.TokenReview:
			return TokenReview{V: &v}
		default:
			return skylark.None
		}
	}
	TokenReview_attrs = setFieldTypes(t, TokenReview_fields, TokenReview_inline)
	Library["TokenReview"] = skylark.NewBuiltin("TokenReview", createTokenReview)
}

func createTokenReview(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := TokenReview{V: &authentication.TokenReview{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t TokenReview) Underlying() interface{} { return t.V }
func (t TokenReview) DeepCopy() boxed         { return TokenReview{V: t.V.DeepCopy()} }
func (t TokenReview) Package() util.Package   { return util.Authentication }
func (t TokenReview) Type() string            { return "k8s_authentication_TokenReview" }
func (t TokenReview) String() string          { return t.V.String() }
func (t TokenReview) Freeze()                 {} // TODO
func (t TokenReview) Truth() skylark.Bool     { return skylark.True }
func (t TokenReview) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t TokenReview) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*TokenReview)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t TokenReview) AttrNames() []string { return TokenReview_attrs }
func (t TokenReview) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, TokenReview_fields, TokenReview_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t TokenReview) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, TokenReview_fields, TokenReview_inline)
}

type TokenReviewSpec struct {
	V *authentication.TokenReviewSpec
}

var (
	_ boxed = (*TokenReviewSpec)(nil)

	TokenReviewSpec_fields = map[string]util.FieldSpec{}
	TokenReviewSpec_inline = map[string]util.FieldSpec{}
	TokenReviewSpec_attrs  []string
)

func init() {
	t := reflect.TypeOf((*authentication.TokenReviewSpec)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *authentication.TokenReviewSpec:
			return TokenReviewSpec{V: v}
		case authentication.TokenReviewSpec:
			return TokenReviewSpec{V: &v}
		default:
			return skylark.None
		}
	}
	TokenReviewSpec_attrs = setFieldTypes(t, TokenReviewSpec_fields, TokenReviewSpec_inline)
	Library["TokenReviewSpec"] = skylark.NewBuiltin("TokenReviewSpec", createTokenReviewSpec)
}

func createTokenReviewSpec(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := TokenReviewSpec{V: &authentication.TokenReviewSpec{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t TokenReviewSpec) Underlying() interface{} { return t.V }
func (t TokenReviewSpec) DeepCopy() boxed         { return TokenReviewSpec{V: t.V.DeepCopy()} }
func (t TokenReviewSpec) Package() util.Package   { return util.Authentication }
func (t TokenReviewSpec) Type() string            { return "k8s_authentication_TokenReviewSpec" }
func (t TokenReviewSpec) String() string          { return t.V.String() }
func (t TokenReviewSpec) Freeze()                 {} // TODO
func (t TokenReviewSpec) Truth() skylark.Bool     { return skylark.True }
func (t TokenReviewSpec) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t TokenReviewSpec) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*TokenReviewSpec)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t TokenReviewSpec) AttrNames() []string { return TokenReviewSpec_attrs }
func (t TokenReviewSpec) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, TokenReviewSpec_fields, TokenReviewSpec_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t TokenReviewSpec) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, TokenReviewSpec_fields, TokenReviewSpec_inline)
}

type TokenReviewStatus struct {
	V *authentication.TokenReviewStatus
}

var (
	_ boxed = (*TokenReviewStatus)(nil)

	TokenReviewStatus_fields = map[string]util.FieldSpec{}
	TokenReviewStatus_inline = map[string]util.FieldSpec{}
	TokenReviewStatus_attrs  []string
)

func init() {
	t := reflect.TypeOf((*authentication.TokenReviewStatus)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *authentication.TokenReviewStatus:
			return TokenReviewStatus{V: v}
		case authentication.TokenReviewStatus:
			return TokenReviewStatus{V: &v}
		default:
			return skylark.None
		}
	}
	TokenReviewStatus_attrs = setFieldTypes(t, TokenReviewStatus_fields, TokenReviewStatus_inline)
	Library["TokenReviewStatus"] = skylark.NewBuiltin("TokenReviewStatus", createTokenReviewStatus)
}

func createTokenReviewStatus(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := TokenReviewStatus{V: &authentication.TokenReviewStatus{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t TokenReviewStatus) Underlying() interface{} { return t.V }
func (t TokenReviewStatus) DeepCopy() boxed         { return TokenReviewStatus{V: t.V.DeepCopy()} }
func (t TokenReviewStatus) Package() util.Package   { return util.Authentication }
func (t TokenReviewStatus) Type() string            { return "k8s_authentication_TokenReviewStatus" }
func (t TokenReviewStatus) String() string          { return t.V.String() }
func (t TokenReviewStatus) Freeze()                 {} // TODO
func (t TokenReviewStatus) Truth() skylark.Bool     { return skylark.True }
func (t TokenReviewStatus) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t TokenReviewStatus) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*TokenReviewStatus)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t TokenReviewStatus) AttrNames() []string { return TokenReviewStatus_attrs }
func (t TokenReviewStatus) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, TokenReviewStatus_fields, TokenReviewStatus_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t TokenReviewStatus) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, TokenReviewStatus_fields, TokenReviewStatus_inline)
}

type UserInfo struct {
	V *authentication.UserInfo
}

var (
	_ boxed = (*UserInfo)(nil)

	UserInfo_fields = map[string]util.FieldSpec{}
	UserInfo_inline = map[string]util.FieldSpec{}
	UserInfo_attrs  []string
)

func init() {
	t := reflect.TypeOf((*authentication.UserInfo)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *authentication.UserInfo:
			return UserInfo{V: v}
		case authentication.UserInfo:
			return UserInfo{V: &v}
		default:
			return skylark.None
		}
	}
	UserInfo_attrs = setFieldTypes(t, UserInfo_fields, UserInfo_inline)
	Library["UserInfo"] = skylark.NewBuiltin("UserInfo", createUserInfo)
}

func createUserInfo(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := UserInfo{V: &authentication.UserInfo{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t UserInfo) Underlying() interface{} { return t.V }
func (t UserInfo) DeepCopy() boxed         { return UserInfo{V: t.V.DeepCopy()} }
func (t UserInfo) Package() util.Package   { return util.Authentication }
func (t UserInfo) Type() string            { return "k8s_authentication_UserInfo" }
func (t UserInfo) String() string          { return t.V.String() }
func (t UserInfo) Freeze()                 {} // TODO
func (t UserInfo) Truth() skylark.Bool     { return skylark.True }
func (t UserInfo) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t UserInfo) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*UserInfo)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t UserInfo) AttrNames() []string { return UserInfo_attrs }
func (t UserInfo) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, UserInfo_fields, UserInfo_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t UserInfo) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, UserInfo_fields, UserInfo_inline)
}

type LocalSubjectAccessReview struct {
	V *authorization.LocalSubjectAccessReview
}

var (
	_ boxed = (*LocalSubjectAccessReview)(nil)

	LocalSubjectAccessReview_fields = map[string]util.FieldSpec{}
	LocalSubjectAccessReview_inline = map[string]util.FieldSpec{}
	LocalSubjectAccessReview_attrs  []string
)

func init() {
	t := reflect.TypeOf((*authorization.LocalSubjectAccessReview)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *authorization.LocalSubjectAccessReview:
			return LocalSubjectAccessReview{V: v}
		case authorization.LocalSubjectAccessReview:
			return LocalSubjectAccessReview{V: &v}
		default:
			return skylark.None
		}
	}
	LocalSubjectAccessReview_attrs = setFieldTypes(t, LocalSubjectAccessReview_fields, LocalSubjectAccessReview_inline)
	Library["LocalSubjectAccessReview"] = skylark.NewBuiltin("LocalSubjectAccessReview", createLocalSubjectAccessReview)
}

func createLocalSubjectAccessReview(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := LocalSubjectAccessReview{V: &authorization.LocalSubjectAccessReview{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t LocalSubjectAccessReview) Underlying() interface{} { return t.V }
func (t LocalSubjectAccessReview) DeepCopy() boxed         { return LocalSubjectAccessReview{V: t.V.DeepCopy()} }
func (t LocalSubjectAccessReview) Package() util.Package   { return util.Authorization }
func (t LocalSubjectAccessReview) Type() string            { return "k8s_authorization_LocalSubjectAccessReview" }
func (t LocalSubjectAccessReview) String() string          { return t.V.String() }
func (t LocalSubjectAccessReview) Freeze()                 {} // TODO
func (t LocalSubjectAccessReview) Truth() skylark.Bool     { return skylark.True }
func (t LocalSubjectAccessReview) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t LocalSubjectAccessReview) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*LocalSubjectAccessReview)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t LocalSubjectAccessReview) AttrNames() []string { return LocalSubjectAccessReview_attrs }
func (t LocalSubjectAccessReview) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, LocalSubjectAccessReview_fields, LocalSubjectAccessReview_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t LocalSubjectAccessReview) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, LocalSubjectAccessReview_fields, LocalSubjectAccessReview_inline)
}

type NonResourceAttributes struct {
	V *authorization.NonResourceAttributes
}

var (
	_ boxed = (*NonResourceAttributes)(nil)

	NonResourceAttributes_fields = map[string]util.FieldSpec{}
	NonResourceAttributes_inline = map[string]util.FieldSpec{}
	NonResourceAttributes_attrs  []string
)

func init() {
	t := reflect.TypeOf((*authorization.NonResourceAttributes)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *authorization.NonResourceAttributes:
			return NonResourceAttributes{V: v}
		case authorization.NonResourceAttributes:
			return NonResourceAttributes{V: &v}
		default:
			return skylark.None
		}
	}
	NonResourceAttributes_attrs = setFieldTypes(t, NonResourceAttributes_fields, NonResourceAttributes_inline)
	Library["NonResourceAttributes"] = skylark.NewBuiltin("NonResourceAttributes", createNonResourceAttributes)
}

func createNonResourceAttributes(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := NonResourceAttributes{V: &authorization.NonResourceAttributes{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t NonResourceAttributes) Underlying() interface{} { return t.V }
func (t NonResourceAttributes) DeepCopy() boxed         { return NonResourceAttributes{V: t.V.DeepCopy()} }
func (t NonResourceAttributes) Package() util.Package   { return util.Authorization }
func (t NonResourceAttributes) Type() string            { return "k8s_authorization_NonResourceAttributes" }
func (t NonResourceAttributes) String() string          { return t.V.String() }
func (t NonResourceAttributes) Freeze()                 {} // TODO
func (t NonResourceAttributes) Truth() skylark.Bool     { return skylark.True }
func (t NonResourceAttributes) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t NonResourceAttributes) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*NonResourceAttributes)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t NonResourceAttributes) AttrNames() []string { return NonResourceAttributes_attrs }
func (t NonResourceAttributes) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, NonResourceAttributes_fields, NonResourceAttributes_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t NonResourceAttributes) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, NonResourceAttributes_fields, NonResourceAttributes_inline)
}

type NonResourceRule struct {
	V *authorization.NonResourceRule
}

var (
	_ boxed = (*NonResourceRule)(nil)

	NonResourceRule_fields = map[string]util.FieldSpec{}
	NonResourceRule_inline = map[string]util.FieldSpec{}
	NonResourceRule_attrs  []string
)

func init() {
	t := reflect.TypeOf((*authorization.NonResourceRule)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *authorization.NonResourceRule:
			return NonResourceRule{V: v}
		case authorization.NonResourceRule:
			return NonResourceRule{V: &v}
		default:
			return skylark.None
		}
	}
	NonResourceRule_attrs = setFieldTypes(t, NonResourceRule_fields, NonResourceRule_inline)
	Library["NonResourceRule"] = skylark.NewBuiltin("NonResourceRule", createNonResourceRule)
}

func createNonResourceRule(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := NonResourceRule{V: &authorization.NonResourceRule{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t NonResourceRule) Underlying() interface{} { return t.V }
func (t NonResourceRule) DeepCopy() boxed         { return NonResourceRule{V: t.V.DeepCopy()} }
func (t NonResourceRule) Package() util.Package   { return util.Authorization }
func (t NonResourceRule) Type() string            { return "k8s_authorization_NonResourceRule" }
func (t NonResourceRule) String() string          { return t.V.String() }
func (t NonResourceRule) Freeze()                 {} // TODO
func (t NonResourceRule) Truth() skylark.Bool     { return skylark.True }
func (t NonResourceRule) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t NonResourceRule) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*NonResourceRule)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t NonResourceRule) AttrNames() []string { return NonResourceRule_attrs }
func (t NonResourceRule) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, NonResourceRule_fields, NonResourceRule_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t NonResourceRule) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, NonResourceRule_fields, NonResourceRule_inline)
}

type ResourceAttributes struct {
	V *authorization.ResourceAttributes
}

var (
	_ boxed = (*ResourceAttributes)(nil)

	ResourceAttributes_fields = map[string]util.FieldSpec{}
	ResourceAttributes_inline = map[string]util.FieldSpec{}
	ResourceAttributes_attrs  []string
)

func init() {
	t := reflect.TypeOf((*authorization.ResourceAttributes)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *authorization.ResourceAttributes:
			return ResourceAttributes{V: v}
		case authorization.ResourceAttributes:
			return ResourceAttributes{V: &v}
		default:
			return skylark.None
		}
	}
	ResourceAttributes_attrs = setFieldTypes(t, ResourceAttributes_fields, ResourceAttributes_inline)
	Library["ResourceAttributes"] = skylark.NewBuiltin("ResourceAttributes", createResourceAttributes)
}

func createResourceAttributes(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ResourceAttributes{V: &authorization.ResourceAttributes{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ResourceAttributes) Underlying() interface{} { return t.V }
func (t ResourceAttributes) DeepCopy() boxed         { return ResourceAttributes{V: t.V.DeepCopy()} }
func (t ResourceAttributes) Package() util.Package   { return util.Authorization }
func (t ResourceAttributes) Type() string            { return "k8s_authorization_ResourceAttributes" }
func (t ResourceAttributes) String() string          { return t.V.String() }
func (t ResourceAttributes) Freeze()                 {} // TODO
func (t ResourceAttributes) Truth() skylark.Bool     { return skylark.True }
func (t ResourceAttributes) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ResourceAttributes) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ResourceAttributes)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ResourceAttributes) AttrNames() []string { return ResourceAttributes_attrs }
func (t ResourceAttributes) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ResourceAttributes_fields, ResourceAttributes_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ResourceAttributes) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ResourceAttributes_fields, ResourceAttributes_inline)
}

type ResourceRule struct {
	V *authorization.ResourceRule
}

var (
	_ boxed = (*ResourceRule)(nil)

	ResourceRule_fields = map[string]util.FieldSpec{}
	ResourceRule_inline = map[string]util.FieldSpec{}
	ResourceRule_attrs  []string
)

func init() {
	t := reflect.TypeOf((*authorization.ResourceRule)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *authorization.ResourceRule:
			return ResourceRule{V: v}
		case authorization.ResourceRule:
			return ResourceRule{V: &v}
		default:
			return skylark.None
		}
	}
	ResourceRule_attrs = setFieldTypes(t, ResourceRule_fields, ResourceRule_inline)
	Library["ResourceRule"] = skylark.NewBuiltin("ResourceRule", createResourceRule)
}

func createResourceRule(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ResourceRule{V: &authorization.ResourceRule{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ResourceRule) Underlying() interface{} { return t.V }
func (t ResourceRule) DeepCopy() boxed         { return ResourceRule{V: t.V.DeepCopy()} }
func (t ResourceRule) Package() util.Package   { return util.Authorization }
func (t ResourceRule) Type() string            { return "k8s_authorization_ResourceRule" }
func (t ResourceRule) String() string          { return t.V.String() }
func (t ResourceRule) Freeze()                 {} // TODO
func (t ResourceRule) Truth() skylark.Bool     { return skylark.True }
func (t ResourceRule) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ResourceRule) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ResourceRule)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ResourceRule) AttrNames() []string { return ResourceRule_attrs }
func (t ResourceRule) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ResourceRule_fields, ResourceRule_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ResourceRule) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ResourceRule_fields, ResourceRule_inline)
}

type SelfSubjectAccessReview struct {
	V *authorization.SelfSubjectAccessReview
}

var (
	_ boxed = (*SelfSubjectAccessReview)(nil)

	SelfSubjectAccessReview_fields = map[string]util.FieldSpec{}
	SelfSubjectAccessReview_inline = map[string]util.FieldSpec{}
	SelfSubjectAccessReview_attrs  []string
)

func init() {
	t := reflect.TypeOf((*authorization.SelfSubjectAccessReview)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *authorization.SelfSubjectAccessReview:
			return SelfSubjectAccessReview{V: v}
		case authorization.SelfSubjectAccessReview:
			return SelfSubjectAccessReview{V: &v}
		default:
			return skylark.None
		}
	}
	SelfSubjectAccessReview_attrs = setFieldTypes(t, SelfSubjectAccessReview_fields, SelfSubjectAccessReview_inline)
	Library["SelfSubjectAccessReview"] = skylark.NewBuiltin("SelfSubjectAccessReview", createSelfSubjectAccessReview)
}

func createSelfSubjectAccessReview(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := SelfSubjectAccessReview{V: &authorization.SelfSubjectAccessReview{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t SelfSubjectAccessReview) Underlying() interface{} { return t.V }
func (t SelfSubjectAccessReview) DeepCopy() boxed         { return SelfSubjectAccessReview{V: t.V.DeepCopy()} }
func (t SelfSubjectAccessReview) Package() util.Package   { return util.Authorization }
func (t SelfSubjectAccessReview) Type() string            { return "k8s_authorization_SelfSubjectAccessReview" }
func (t SelfSubjectAccessReview) String() string          { return t.V.String() }
func (t SelfSubjectAccessReview) Freeze()                 {} // TODO
func (t SelfSubjectAccessReview) Truth() skylark.Bool     { return skylark.True }
func (t SelfSubjectAccessReview) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t SelfSubjectAccessReview) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*SelfSubjectAccessReview)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t SelfSubjectAccessReview) AttrNames() []string { return SelfSubjectAccessReview_attrs }
func (t SelfSubjectAccessReview) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, SelfSubjectAccessReview_fields, SelfSubjectAccessReview_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t SelfSubjectAccessReview) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, SelfSubjectAccessReview_fields, SelfSubjectAccessReview_inline)
}

type SelfSubjectAccessReviewSpec struct {
	V *authorization.SelfSubjectAccessReviewSpec
}

var (
	_ boxed = (*SelfSubjectAccessReviewSpec)(nil)

	SelfSubjectAccessReviewSpec_fields = map[string]util.FieldSpec{}
	SelfSubjectAccessReviewSpec_inline = map[string]util.FieldSpec{}
	SelfSubjectAccessReviewSpec_attrs  []string
)

func init() {
	t := reflect.TypeOf((*authorization.SelfSubjectAccessReviewSpec)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *authorization.SelfSubjectAccessReviewSpec:
			return SelfSubjectAccessReviewSpec{V: v}
		case authorization.SelfSubjectAccessReviewSpec:
			return SelfSubjectAccessReviewSpec{V: &v}
		default:
			return skylark.None
		}
	}
	SelfSubjectAccessReviewSpec_attrs = setFieldTypes(t, SelfSubjectAccessReviewSpec_fields, SelfSubjectAccessReviewSpec_inline)
	Library["SelfSubjectAccessReviewSpec"] = skylark.NewBuiltin("SelfSubjectAccessReviewSpec", createSelfSubjectAccessReviewSpec)
}

func createSelfSubjectAccessReviewSpec(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := SelfSubjectAccessReviewSpec{V: &authorization.SelfSubjectAccessReviewSpec{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t SelfSubjectAccessReviewSpec) Underlying() interface{} { return t.V }
func (t SelfSubjectAccessReviewSpec) DeepCopy() boxed {
	return SelfSubjectAccessReviewSpec{V: t.V.DeepCopy()}
}
func (t SelfSubjectAccessReviewSpec) Package() util.Package { return util.Authorization }
func (t SelfSubjectAccessReviewSpec) Type() string {
	return "k8s_authorization_SelfSubjectAccessReviewSpec"
}
func (t SelfSubjectAccessReviewSpec) String() string        { return t.V.String() }
func (t SelfSubjectAccessReviewSpec) Freeze()               {} // TODO
func (t SelfSubjectAccessReviewSpec) Truth() skylark.Bool   { return skylark.True }
func (t SelfSubjectAccessReviewSpec) Hash() (uint32, error) { return 0, unhashable(t.Type()) }
func (t SelfSubjectAccessReviewSpec) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*SelfSubjectAccessReviewSpec)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t SelfSubjectAccessReviewSpec) AttrNames() []string { return SelfSubjectAccessReviewSpec_attrs }
func (t SelfSubjectAccessReviewSpec) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, SelfSubjectAccessReviewSpec_fields, SelfSubjectAccessReviewSpec_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t SelfSubjectAccessReviewSpec) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, SelfSubjectAccessReviewSpec_fields, SelfSubjectAccessReviewSpec_inline)
}

type SelfSubjectRulesReview struct {
	V *authorization.SelfSubjectRulesReview
}

var (
	_ boxed = (*SelfSubjectRulesReview)(nil)

	SelfSubjectRulesReview_fields = map[string]util.FieldSpec{}
	SelfSubjectRulesReview_inline = map[string]util.FieldSpec{}
	SelfSubjectRulesReview_attrs  []string
)

func init() {
	t := reflect.TypeOf((*authorization.SelfSubjectRulesReview)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *authorization.SelfSubjectRulesReview:
			return SelfSubjectRulesReview{V: v}
		case authorization.SelfSubjectRulesReview:
			return SelfSubjectRulesReview{V: &v}
		default:
			return skylark.None
		}
	}
	SelfSubjectRulesReview_attrs = setFieldTypes(t, SelfSubjectRulesReview_fields, SelfSubjectRulesReview_inline)
	Library["SelfSubjectRulesReview"] = skylark.NewBuiltin("SelfSubjectRulesReview", createSelfSubjectRulesReview)
}

func createSelfSubjectRulesReview(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := SelfSubjectRulesReview{V: &authorization.SelfSubjectRulesReview{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t SelfSubjectRulesReview) Underlying() interface{} { return t.V }
func (t SelfSubjectRulesReview) DeepCopy() boxed         { return SelfSubjectRulesReview{V: t.V.DeepCopy()} }
func (t SelfSubjectRulesReview) Package() util.Package   { return util.Authorization }
func (t SelfSubjectRulesReview) Type() string            { return "k8s_authorization_SelfSubjectRulesReview" }
func (t SelfSubjectRulesReview) String() string          { return t.V.String() }
func (t SelfSubjectRulesReview) Freeze()                 {} // TODO
func (t SelfSubjectRulesReview) Truth() skylark.Bool     { return skylark.True }
func (t SelfSubjectRulesReview) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t SelfSubjectRulesReview) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*SelfSubjectRulesReview)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t SelfSubjectRulesReview) AttrNames() []string { return SelfSubjectRulesReview_attrs }
func (t SelfSubjectRulesReview) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, SelfSubjectRulesReview_fields, SelfSubjectRulesReview_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t SelfSubjectRulesReview) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, SelfSubjectRulesReview_fields, SelfSubjectRulesReview_inline)
}

type SelfSubjectRulesReviewSpec struct {
	V *authorization.SelfSubjectRulesReviewSpec
}

var (
	_ boxed = (*SelfSubjectRulesReviewSpec)(nil)

	SelfSubjectRulesReviewSpec_fields = map[string]util.FieldSpec{}
	SelfSubjectRulesReviewSpec_inline = map[string]util.FieldSpec{}
	SelfSubjectRulesReviewSpec_attrs  []string
)

func init() {
	t := reflect.TypeOf((*authorization.SelfSubjectRulesReviewSpec)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *authorization.SelfSubjectRulesReviewSpec:
			return SelfSubjectRulesReviewSpec{V: v}
		case authorization.SelfSubjectRulesReviewSpec:
			return SelfSubjectRulesReviewSpec{V: &v}
		default:
			return skylark.None
		}
	}
	SelfSubjectRulesReviewSpec_attrs = setFieldTypes(t, SelfSubjectRulesReviewSpec_fields, SelfSubjectRulesReviewSpec_inline)
	Library["SelfSubjectRulesReviewSpec"] = skylark.NewBuiltin("SelfSubjectRulesReviewSpec", createSelfSubjectRulesReviewSpec)
}

func createSelfSubjectRulesReviewSpec(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := SelfSubjectRulesReviewSpec{V: &authorization.SelfSubjectRulesReviewSpec{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t SelfSubjectRulesReviewSpec) Underlying() interface{} { return t.V }
func (t SelfSubjectRulesReviewSpec) DeepCopy() boxed {
	return SelfSubjectRulesReviewSpec{V: t.V.DeepCopy()}
}
func (t SelfSubjectRulesReviewSpec) Package() util.Package { return util.Authorization }
func (t SelfSubjectRulesReviewSpec) Type() string {
	return "k8s_authorization_SelfSubjectRulesReviewSpec"
}
func (t SelfSubjectRulesReviewSpec) String() string        { return t.V.String() }
func (t SelfSubjectRulesReviewSpec) Freeze()               {} // TODO
func (t SelfSubjectRulesReviewSpec) Truth() skylark.Bool   { return skylark.True }
func (t SelfSubjectRulesReviewSpec) Hash() (uint32, error) { return 0, unhashable(t.Type()) }
func (t SelfSubjectRulesReviewSpec) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*SelfSubjectRulesReviewSpec)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t SelfSubjectRulesReviewSpec) AttrNames() []string { return SelfSubjectRulesReviewSpec_attrs }
func (t SelfSubjectRulesReviewSpec) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, SelfSubjectRulesReviewSpec_fields, SelfSubjectRulesReviewSpec_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t SelfSubjectRulesReviewSpec) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, SelfSubjectRulesReviewSpec_fields, SelfSubjectRulesReviewSpec_inline)
}

type SubjectAccessReview struct {
	V *authorization.SubjectAccessReview
}

var (
	_ boxed = (*SubjectAccessReview)(nil)

	SubjectAccessReview_fields = map[string]util.FieldSpec{}
	SubjectAccessReview_inline = map[string]util.FieldSpec{}
	SubjectAccessReview_attrs  []string
)

func init() {
	t := reflect.TypeOf((*authorization.SubjectAccessReview)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *authorization.SubjectAccessReview:
			return SubjectAccessReview{V: v}
		case authorization.SubjectAccessReview:
			return SubjectAccessReview{V: &v}
		default:
			return skylark.None
		}
	}
	SubjectAccessReview_attrs = setFieldTypes(t, SubjectAccessReview_fields, SubjectAccessReview_inline)
	Library["SubjectAccessReview"] = skylark.NewBuiltin("SubjectAccessReview", createSubjectAccessReview)
}

func createSubjectAccessReview(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := SubjectAccessReview{V: &authorization.SubjectAccessReview{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t SubjectAccessReview) Underlying() interface{} { return t.V }
func (t SubjectAccessReview) DeepCopy() boxed         { return SubjectAccessReview{V: t.V.DeepCopy()} }
func (t SubjectAccessReview) Package() util.Package   { return util.Authorization }
func (t SubjectAccessReview) Type() string            { return "k8s_authorization_SubjectAccessReview" }
func (t SubjectAccessReview) String() string          { return t.V.String() }
func (t SubjectAccessReview) Freeze()                 {} // TODO
func (t SubjectAccessReview) Truth() skylark.Bool     { return skylark.True }
func (t SubjectAccessReview) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t SubjectAccessReview) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*SubjectAccessReview)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t SubjectAccessReview) AttrNames() []string { return SubjectAccessReview_attrs }
func (t SubjectAccessReview) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, SubjectAccessReview_fields, SubjectAccessReview_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t SubjectAccessReview) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, SubjectAccessReview_fields, SubjectAccessReview_inline)
}

type SubjectAccessReviewSpec struct {
	V *authorization.SubjectAccessReviewSpec
}

var (
	_ boxed = (*SubjectAccessReviewSpec)(nil)

	SubjectAccessReviewSpec_fields = map[string]util.FieldSpec{}
	SubjectAccessReviewSpec_inline = map[string]util.FieldSpec{}
	SubjectAccessReviewSpec_attrs  []string
)

func init() {
	t := reflect.TypeOf((*authorization.SubjectAccessReviewSpec)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *authorization.SubjectAccessReviewSpec:
			return SubjectAccessReviewSpec{V: v}
		case authorization.SubjectAccessReviewSpec:
			return SubjectAccessReviewSpec{V: &v}
		default:
			return skylark.None
		}
	}
	SubjectAccessReviewSpec_attrs = setFieldTypes(t, SubjectAccessReviewSpec_fields, SubjectAccessReviewSpec_inline)
	Library["SubjectAccessReviewSpec"] = skylark.NewBuiltin("SubjectAccessReviewSpec", createSubjectAccessReviewSpec)
}

func createSubjectAccessReviewSpec(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := SubjectAccessReviewSpec{V: &authorization.SubjectAccessReviewSpec{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t SubjectAccessReviewSpec) Underlying() interface{} { return t.V }
func (t SubjectAccessReviewSpec) DeepCopy() boxed         { return SubjectAccessReviewSpec{V: t.V.DeepCopy()} }
func (t SubjectAccessReviewSpec) Package() util.Package   { return util.Authorization }
func (t SubjectAccessReviewSpec) Type() string            { return "k8s_authorization_SubjectAccessReviewSpec" }
func (t SubjectAccessReviewSpec) String() string          { return t.V.String() }
func (t SubjectAccessReviewSpec) Freeze()                 {} // TODO
func (t SubjectAccessReviewSpec) Truth() skylark.Bool     { return skylark.True }
func (t SubjectAccessReviewSpec) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t SubjectAccessReviewSpec) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*SubjectAccessReviewSpec)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t SubjectAccessReviewSpec) AttrNames() []string { return SubjectAccessReviewSpec_attrs }
func (t SubjectAccessReviewSpec) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, SubjectAccessReviewSpec_fields, SubjectAccessReviewSpec_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t SubjectAccessReviewSpec) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, SubjectAccessReviewSpec_fields, SubjectAccessReviewSpec_inline)
}

type SubjectAccessReviewStatus struct {
	V *authorization.SubjectAccessReviewStatus
}

var (
	_ boxed = (*SubjectAccessReviewStatus)(nil)

	SubjectAccessReviewStatus_fields = map[string]util.FieldSpec{}
	SubjectAccessReviewStatus_inline = map[string]util.FieldSpec{}
	SubjectAccessReviewStatus_attrs  []string
)

func init() {
	t := reflect.TypeOf((*authorization.SubjectAccessReviewStatus)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *authorization.SubjectAccessReviewStatus:
			return SubjectAccessReviewStatus{V: v}
		case authorization.SubjectAccessReviewStatus:
			return SubjectAccessReviewStatus{V: &v}
		default:
			return skylark.None
		}
	}
	SubjectAccessReviewStatus_attrs = setFieldTypes(t, SubjectAccessReviewStatus_fields, SubjectAccessReviewStatus_inline)
	Library["SubjectAccessReviewStatus"] = skylark.NewBuiltin("SubjectAccessReviewStatus", createSubjectAccessReviewStatus)
}

func createSubjectAccessReviewStatus(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := SubjectAccessReviewStatus{V: &authorization.SubjectAccessReviewStatus{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t SubjectAccessReviewStatus) Underlying() interface{} { return t.V }
func (t SubjectAccessReviewStatus) DeepCopy() boxed {
	return SubjectAccessReviewStatus{V: t.V.DeepCopy()}
}
func (t SubjectAccessReviewStatus) Package() util.Package { return util.Authorization }
func (t SubjectAccessReviewStatus) Type() string          { return "k8s_authorization_SubjectAccessReviewStatus" }
func (t SubjectAccessReviewStatus) String() string        { return t.V.String() }
func (t SubjectAccessReviewStatus) Freeze()               {} // TODO
func (t SubjectAccessReviewStatus) Truth() skylark.Bool   { return skylark.True }
func (t SubjectAccessReviewStatus) Hash() (uint32, error) { return 0, unhashable(t.Type()) }
func (t SubjectAccessReviewStatus) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*SubjectAccessReviewStatus)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t SubjectAccessReviewStatus) AttrNames() []string { return SubjectAccessReviewStatus_attrs }
func (t SubjectAccessReviewStatus) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, SubjectAccessReviewStatus_fields, SubjectAccessReviewStatus_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t SubjectAccessReviewStatus) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, SubjectAccessReviewStatus_fields, SubjectAccessReviewStatus_inline)
}

type SubjectRulesReviewStatus struct {
	V *authorization.SubjectRulesReviewStatus
}

var (
	_ boxed = (*SubjectRulesReviewStatus)(nil)

	SubjectRulesReviewStatus_fields = map[string]util.FieldSpec{}
	SubjectRulesReviewStatus_inline = map[string]util.FieldSpec{}
	SubjectRulesReviewStatus_attrs  []string
)

func init() {
	t := reflect.TypeOf((*authorization.SubjectRulesReviewStatus)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *authorization.SubjectRulesReviewStatus:
			return SubjectRulesReviewStatus{V: v}
		case authorization.SubjectRulesReviewStatus:
			return SubjectRulesReviewStatus{V: &v}
		default:
			return skylark.None
		}
	}
	SubjectRulesReviewStatus_attrs = setFieldTypes(t, SubjectRulesReviewStatus_fields, SubjectRulesReviewStatus_inline)
	Library["SubjectRulesReviewStatus"] = skylark.NewBuiltin("SubjectRulesReviewStatus", createSubjectRulesReviewStatus)
}

func createSubjectRulesReviewStatus(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := SubjectRulesReviewStatus{V: &authorization.SubjectRulesReviewStatus{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t SubjectRulesReviewStatus) Underlying() interface{} { return t.V }
func (t SubjectRulesReviewStatus) DeepCopy() boxed         { return SubjectRulesReviewStatus{V: t.V.DeepCopy()} }
func (t SubjectRulesReviewStatus) Package() util.Package   { return util.Authorization }
func (t SubjectRulesReviewStatus) Type() string            { return "k8s_authorization_SubjectRulesReviewStatus" }
func (t SubjectRulesReviewStatus) String() string          { return t.V.String() }
func (t SubjectRulesReviewStatus) Freeze()                 {} // TODO
func (t SubjectRulesReviewStatus) Truth() skylark.Bool     { return skylark.True }
func (t SubjectRulesReviewStatus) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t SubjectRulesReviewStatus) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*SubjectRulesReviewStatus)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t SubjectRulesReviewStatus) AttrNames() []string { return SubjectRulesReviewStatus_attrs }
func (t SubjectRulesReviewStatus) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, SubjectRulesReviewStatus_fields, SubjectRulesReviewStatus_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t SubjectRulesReviewStatus) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, SubjectRulesReviewStatus_fields, SubjectRulesReviewStatus_inline)
}

type IPBlock struct {
	V *networking.IPBlock
}

var (
	_ boxed = (*IPBlock)(nil)

	IPBlock_fields = map[string]util.FieldSpec{}
	IPBlock_inline = map[string]util.FieldSpec{}
	IPBlock_attrs  []string
)

func init() {
	t := reflect.TypeOf((*networking.IPBlock)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *networking.IPBlock:
			return IPBlock{V: v}
		case networking.IPBlock:
			return IPBlock{V: &v}
		default:
			return skylark.None
		}
	}
	IPBlock_attrs = setFieldTypes(t, IPBlock_fields, IPBlock_inline)
	Library["IPBlock"] = skylark.NewBuiltin("IPBlock", createIPBlock)
}

func createIPBlock(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := IPBlock{V: &networking.IPBlock{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t IPBlock) Underlying() interface{} { return t.V }
func (t IPBlock) DeepCopy() boxed         { return IPBlock{V: t.V.DeepCopy()} }
func (t IPBlock) Package() util.Package   { return util.Networking }
func (t IPBlock) Type() string            { return "k8s_networking_IPBlock" }
func (t IPBlock) String() string          { return t.V.String() }
func (t IPBlock) Freeze()                 {} // TODO
func (t IPBlock) Truth() skylark.Bool     { return skylark.True }
func (t IPBlock) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t IPBlock) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*IPBlock)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t IPBlock) AttrNames() []string { return IPBlock_attrs }
func (t IPBlock) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, IPBlock_fields, IPBlock_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t IPBlock) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, IPBlock_fields, IPBlock_inline)
}

type NetworkPolicy struct {
	V *networking.NetworkPolicy
}

var (
	_ boxed = (*NetworkPolicy)(nil)

	NetworkPolicy_fields = map[string]util.FieldSpec{}
	NetworkPolicy_inline = map[string]util.FieldSpec{}
	NetworkPolicy_attrs  []string
)

func init() {
	t := reflect.TypeOf((*networking.NetworkPolicy)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *networking.NetworkPolicy:
			return NetworkPolicy{V: v}
		case networking.NetworkPolicy:
			return NetworkPolicy{V: &v}
		default:
			return skylark.None
		}
	}
	NetworkPolicy_attrs = setFieldTypes(t, NetworkPolicy_fields, NetworkPolicy_inline)
	Library["NetworkPolicy"] = skylark.NewBuiltin("NetworkPolicy", createNetworkPolicy)
}

func createNetworkPolicy(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := NetworkPolicy{V: &networking.NetworkPolicy{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t NetworkPolicy) Underlying() interface{} { return t.V }
func (t NetworkPolicy) DeepCopy() boxed         { return NetworkPolicy{V: t.V.DeepCopy()} }
func (t NetworkPolicy) Package() util.Package   { return util.Networking }
func (t NetworkPolicy) Type() string            { return "k8s_networking_NetworkPolicy" }
func (t NetworkPolicy) String() string          { return t.V.String() }
func (t NetworkPolicy) Freeze()                 {} // TODO
func (t NetworkPolicy) Truth() skylark.Bool     { return skylark.True }
func (t NetworkPolicy) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t NetworkPolicy) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*NetworkPolicy)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t NetworkPolicy) AttrNames() []string { return NetworkPolicy_attrs }
func (t NetworkPolicy) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, NetworkPolicy_fields, NetworkPolicy_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t NetworkPolicy) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, NetworkPolicy_fields, NetworkPolicy_inline)
}

type NetworkPolicyEgressRule struct {
	V *networking.NetworkPolicyEgressRule
}

var (
	_ boxed = (*NetworkPolicyEgressRule)(nil)

	NetworkPolicyEgressRule_fields = map[string]util.FieldSpec{}
	NetworkPolicyEgressRule_inline = map[string]util.FieldSpec{}
	NetworkPolicyEgressRule_attrs  []string
)

func init() {
	t := reflect.TypeOf((*networking.NetworkPolicyEgressRule)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *networking.NetworkPolicyEgressRule:
			return NetworkPolicyEgressRule{V: v}
		case networking.NetworkPolicyEgressRule:
			return NetworkPolicyEgressRule{V: &v}
		default:
			return skylark.None
		}
	}
	NetworkPolicyEgressRule_attrs = setFieldTypes(t, NetworkPolicyEgressRule_fields, NetworkPolicyEgressRule_inline)
	Library["NetworkPolicyEgressRule"] = skylark.NewBuiltin("NetworkPolicyEgressRule", createNetworkPolicyEgressRule)
}

func createNetworkPolicyEgressRule(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := NetworkPolicyEgressRule{V: &networking.NetworkPolicyEgressRule{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t NetworkPolicyEgressRule) Underlying() interface{} { return t.V }
func (t NetworkPolicyEgressRule) DeepCopy() boxed         { return NetworkPolicyEgressRule{V: t.V.DeepCopy()} }
func (t NetworkPolicyEgressRule) Package() util.Package   { return util.Networking }
func (t NetworkPolicyEgressRule) Type() string            { return "k8s_networking_NetworkPolicyEgressRule" }
func (t NetworkPolicyEgressRule) String() string          { return t.V.String() }
func (t NetworkPolicyEgressRule) Freeze()                 {} // TODO
func (t NetworkPolicyEgressRule) Truth() skylark.Bool     { return skylark.True }
func (t NetworkPolicyEgressRule) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t NetworkPolicyEgressRule) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*NetworkPolicyEgressRule)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t NetworkPolicyEgressRule) AttrNames() []string { return NetworkPolicyEgressRule_attrs }
func (t NetworkPolicyEgressRule) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, NetworkPolicyEgressRule_fields, NetworkPolicyEgressRule_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t NetworkPolicyEgressRule) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, NetworkPolicyEgressRule_fields, NetworkPolicyEgressRule_inline)
}

type NetworkPolicyIngressRule struct {
	V *networking.NetworkPolicyIngressRule
}

var (
	_ boxed = (*NetworkPolicyIngressRule)(nil)

	NetworkPolicyIngressRule_fields = map[string]util.FieldSpec{}
	NetworkPolicyIngressRule_inline = map[string]util.FieldSpec{}
	NetworkPolicyIngressRule_attrs  []string
)

func init() {
	t := reflect.TypeOf((*networking.NetworkPolicyIngressRule)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *networking.NetworkPolicyIngressRule:
			return NetworkPolicyIngressRule{V: v}
		case networking.NetworkPolicyIngressRule:
			return NetworkPolicyIngressRule{V: &v}
		default:
			return skylark.None
		}
	}
	NetworkPolicyIngressRule_attrs = setFieldTypes(t, NetworkPolicyIngressRule_fields, NetworkPolicyIngressRule_inline)
	Library["NetworkPolicyIngressRule"] = skylark.NewBuiltin("NetworkPolicyIngressRule", createNetworkPolicyIngressRule)
}

func createNetworkPolicyIngressRule(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := NetworkPolicyIngressRule{V: &networking.NetworkPolicyIngressRule{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t NetworkPolicyIngressRule) Underlying() interface{} { return t.V }
func (t NetworkPolicyIngressRule) DeepCopy() boxed         { return NetworkPolicyIngressRule{V: t.V.DeepCopy()} }
func (t NetworkPolicyIngressRule) Package() util.Package   { return util.Networking }
func (t NetworkPolicyIngressRule) Type() string            { return "k8s_networking_NetworkPolicyIngressRule" }
func (t NetworkPolicyIngressRule) String() string          { return t.V.String() }
func (t NetworkPolicyIngressRule) Freeze()                 {} // TODO
func (t NetworkPolicyIngressRule) Truth() skylark.Bool     { return skylark.True }
func (t NetworkPolicyIngressRule) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t NetworkPolicyIngressRule) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*NetworkPolicyIngressRule)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t NetworkPolicyIngressRule) AttrNames() []string { return NetworkPolicyIngressRule_attrs }
func (t NetworkPolicyIngressRule) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, NetworkPolicyIngressRule_fields, NetworkPolicyIngressRule_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t NetworkPolicyIngressRule) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, NetworkPolicyIngressRule_fields, NetworkPolicyIngressRule_inline)
}

type NetworkPolicyList struct {
	V *networking.NetworkPolicyList
}

var (
	_ boxed = (*NetworkPolicyList)(nil)

	NetworkPolicyList_fields = map[string]util.FieldSpec{}
	NetworkPolicyList_inline = map[string]util.FieldSpec{}
	NetworkPolicyList_attrs  []string
)

func init() {
	t := reflect.TypeOf((*networking.NetworkPolicyList)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *networking.NetworkPolicyList:
			return NetworkPolicyList{V: v}
		case networking.NetworkPolicyList:
			return NetworkPolicyList{V: &v}
		default:
			return skylark.None
		}
	}
	NetworkPolicyList_attrs = setFieldTypes(t, NetworkPolicyList_fields, NetworkPolicyList_inline)
	Library["NetworkPolicyList"] = skylark.NewBuiltin("NetworkPolicyList", createNetworkPolicyList)
}

func createNetworkPolicyList(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := NetworkPolicyList{V: &networking.NetworkPolicyList{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t NetworkPolicyList) Underlying() interface{} { return t.V }
func (t NetworkPolicyList) DeepCopy() boxed         { return NetworkPolicyList{V: t.V.DeepCopy()} }
func (t NetworkPolicyList) Package() util.Package   { return util.Networking }
func (t NetworkPolicyList) Type() string            { return "k8s_networking_NetworkPolicyList" }
func (t NetworkPolicyList) String() string          { return t.V.String() }
func (t NetworkPolicyList) Freeze()                 {} // TODO
func (t NetworkPolicyList) Truth() skylark.Bool     { return skylark.True }
func (t NetworkPolicyList) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t NetworkPolicyList) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*NetworkPolicyList)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t NetworkPolicyList) AttrNames() []string { return NetworkPolicyList_attrs }
func (t NetworkPolicyList) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, NetworkPolicyList_fields, NetworkPolicyList_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t NetworkPolicyList) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, NetworkPolicyList_fields, NetworkPolicyList_inline)
}

type NetworkPolicyPeer struct {
	V *networking.NetworkPolicyPeer
}

var (
	_ boxed = (*NetworkPolicyPeer)(nil)

	NetworkPolicyPeer_fields = map[string]util.FieldSpec{}
	NetworkPolicyPeer_inline = map[string]util.FieldSpec{}
	NetworkPolicyPeer_attrs  []string
)

func init() {
	t := reflect.TypeOf((*networking.NetworkPolicyPeer)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *networking.NetworkPolicyPeer:
			return NetworkPolicyPeer{V: v}
		case networking.NetworkPolicyPeer:
			return NetworkPolicyPeer{V: &v}
		default:
			return skylark.None
		}
	}
	NetworkPolicyPeer_attrs = setFieldTypes(t, NetworkPolicyPeer_fields, NetworkPolicyPeer_inline)
	Library["NetworkPolicyPeer"] = skylark.NewBuiltin("NetworkPolicyPeer", createNetworkPolicyPeer)
}

func createNetworkPolicyPeer(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := NetworkPolicyPeer{V: &networking.NetworkPolicyPeer{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t NetworkPolicyPeer) Underlying() interface{} { return t.V }
func (t NetworkPolicyPeer) DeepCopy() boxed         { return NetworkPolicyPeer{V: t.V.DeepCopy()} }
func (t NetworkPolicyPeer) Package() util.Package   { return util.Networking }
func (t NetworkPolicyPeer) Type() string            { return "k8s_networking_NetworkPolicyPeer" }
func (t NetworkPolicyPeer) String() string          { return t.V.String() }
func (t NetworkPolicyPeer) Freeze()                 {} // TODO
func (t NetworkPolicyPeer) Truth() skylark.Bool     { return skylark.True }
func (t NetworkPolicyPeer) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t NetworkPolicyPeer) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*NetworkPolicyPeer)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t NetworkPolicyPeer) AttrNames() []string { return NetworkPolicyPeer_attrs }
func (t NetworkPolicyPeer) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, NetworkPolicyPeer_fields, NetworkPolicyPeer_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t NetworkPolicyPeer) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, NetworkPolicyPeer_fields, NetworkPolicyPeer_inline)
}

type NetworkPolicyPort struct {
	V *networking.NetworkPolicyPort
}

var (
	_ boxed = (*NetworkPolicyPort)(nil)

	NetworkPolicyPort_fields = map[string]util.FieldSpec{}
	NetworkPolicyPort_inline = map[string]util.FieldSpec{}
	NetworkPolicyPort_attrs  []string
)

func init() {
	t := reflect.TypeOf((*networking.NetworkPolicyPort)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *networking.NetworkPolicyPort:
			return NetworkPolicyPort{V: v}
		case networking.NetworkPolicyPort:
			return NetworkPolicyPort{V: &v}
		default:
			return skylark.None
		}
	}
	NetworkPolicyPort_attrs = setFieldTypes(t, NetworkPolicyPort_fields, NetworkPolicyPort_inline)
	Library["NetworkPolicyPort"] = skylark.NewBuiltin("NetworkPolicyPort", createNetworkPolicyPort)
}

func createNetworkPolicyPort(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := NetworkPolicyPort{V: &networking.NetworkPolicyPort{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t NetworkPolicyPort) Underlying() interface{} { return t.V }
func (t NetworkPolicyPort) DeepCopy() boxed         { return NetworkPolicyPort{V: t.V.DeepCopy()} }
func (t NetworkPolicyPort) Package() util.Package   { return util.Networking }
func (t NetworkPolicyPort) Type() string            { return "k8s_networking_NetworkPolicyPort" }
func (t NetworkPolicyPort) String() string          { return t.V.String() }
func (t NetworkPolicyPort) Freeze()                 {} // TODO
func (t NetworkPolicyPort) Truth() skylark.Bool     { return skylark.True }
func (t NetworkPolicyPort) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t NetworkPolicyPort) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*NetworkPolicyPort)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t NetworkPolicyPort) AttrNames() []string { return NetworkPolicyPort_attrs }
func (t NetworkPolicyPort) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, NetworkPolicyPort_fields, NetworkPolicyPort_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t NetworkPolicyPort) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, NetworkPolicyPort_fields, NetworkPolicyPort_inline)
}

type NetworkPolicySpec struct {
	V *networking.NetworkPolicySpec
}

var (
	_ boxed = (*NetworkPolicySpec)(nil)

	NetworkPolicySpec_fields = map[string]util.FieldSpec{}
	NetworkPolicySpec_inline = map[string]util.FieldSpec{}
	NetworkPolicySpec_attrs  []string
)

func init() {
	t := reflect.TypeOf((*networking.NetworkPolicySpec)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *networking.NetworkPolicySpec:
			return NetworkPolicySpec{V: v}
		case networking.NetworkPolicySpec:
			return NetworkPolicySpec{V: &v}
		default:
			return skylark.None
		}
	}
	NetworkPolicySpec_attrs = setFieldTypes(t, NetworkPolicySpec_fields, NetworkPolicySpec_inline)
	Library["NetworkPolicySpec"] = skylark.NewBuiltin("NetworkPolicySpec", createNetworkPolicySpec)
}

func createNetworkPolicySpec(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := NetworkPolicySpec{V: &networking.NetworkPolicySpec{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t NetworkPolicySpec) Underlying() interface{} { return t.V }
func (t NetworkPolicySpec) DeepCopy() boxed         { return NetworkPolicySpec{V: t.V.DeepCopy()} }
func (t NetworkPolicySpec) Package() util.Package   { return util.Networking }
func (t NetworkPolicySpec) Type() string            { return "k8s_networking_NetworkPolicySpec" }
func (t NetworkPolicySpec) String() string          { return t.V.String() }
func (t NetworkPolicySpec) Freeze()                 {} // TODO
func (t NetworkPolicySpec) Truth() skylark.Bool     { return skylark.True }
func (t NetworkPolicySpec) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t NetworkPolicySpec) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*NetworkPolicySpec)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t NetworkPolicySpec) AttrNames() []string { return NetworkPolicySpec_attrs }
func (t NetworkPolicySpec) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, NetworkPolicySpec_fields, NetworkPolicySpec_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t NetworkPolicySpec) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, NetworkPolicySpec_fields, NetworkPolicySpec_inline)
}

type AggregationRule struct {
	V *rbac.AggregationRule
}

var (
	_ boxed = (*AggregationRule)(nil)

	AggregationRule_fields = map[string]util.FieldSpec{}
	AggregationRule_inline = map[string]util.FieldSpec{}
	AggregationRule_attrs  []string
)

func init() {
	t := reflect.TypeOf((*rbac.AggregationRule)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *rbac.AggregationRule:
			return AggregationRule{V: v}
		case rbac.AggregationRule:
			return AggregationRule{V: &v}
		default:
			return skylark.None
		}
	}
	AggregationRule_attrs = setFieldTypes(t, AggregationRule_fields, AggregationRule_inline)
	Library["AggregationRule"] = skylark.NewBuiltin("AggregationRule", createAggregationRule)
}

func createAggregationRule(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := AggregationRule{V: &rbac.AggregationRule{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t AggregationRule) Underlying() interface{} { return t.V }
func (t AggregationRule) DeepCopy() boxed         { return AggregationRule{V: t.V.DeepCopy()} }
func (t AggregationRule) Package() util.Package   { return util.Rbac }
func (t AggregationRule) Type() string            { return "k8s_rbac_AggregationRule" }
func (t AggregationRule) String() string          { return t.V.String() }
func (t AggregationRule) Freeze()                 {} // TODO
func (t AggregationRule) Truth() skylark.Bool     { return skylark.True }
func (t AggregationRule) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t AggregationRule) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*AggregationRule)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t AggregationRule) AttrNames() []string { return AggregationRule_attrs }
func (t AggregationRule) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, AggregationRule_fields, AggregationRule_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t AggregationRule) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, AggregationRule_fields, AggregationRule_inline)
}

type ClusterRole struct {
	V *rbac.ClusterRole
}

var (
	_ boxed = (*ClusterRole)(nil)

	ClusterRole_fields = map[string]util.FieldSpec{}
	ClusterRole_inline = map[string]util.FieldSpec{}
	ClusterRole_attrs  []string
)

func init() {
	t := reflect.TypeOf((*rbac.ClusterRole)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *rbac.ClusterRole:
			return ClusterRole{V: v}
		case rbac.ClusterRole:
			return ClusterRole{V: &v}
		default:
			return skylark.None
		}
	}
	ClusterRole_attrs = setFieldTypes(t, ClusterRole_fields, ClusterRole_inline)
	Library["ClusterRole"] = skylark.NewBuiltin("ClusterRole", createClusterRole)
}

func createClusterRole(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ClusterRole{V: &rbac.ClusterRole{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ClusterRole) Underlying() interface{} { return t.V }
func (t ClusterRole) DeepCopy() boxed         { return ClusterRole{V: t.V.DeepCopy()} }
func (t ClusterRole) Package() util.Package   { return util.Rbac }
func (t ClusterRole) Type() string            { return "k8s_rbac_ClusterRole" }
func (t ClusterRole) String() string          { return t.V.String() }
func (t ClusterRole) Freeze()                 {} // TODO
func (t ClusterRole) Truth() skylark.Bool     { return skylark.True }
func (t ClusterRole) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ClusterRole) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ClusterRole)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ClusterRole) AttrNames() []string { return ClusterRole_attrs }
func (t ClusterRole) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ClusterRole_fields, ClusterRole_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ClusterRole) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ClusterRole_fields, ClusterRole_inline)
}

type ClusterRoleBinding struct {
	V *rbac.ClusterRoleBinding
}

var (
	_ boxed = (*ClusterRoleBinding)(nil)

	ClusterRoleBinding_fields = map[string]util.FieldSpec{}
	ClusterRoleBinding_inline = map[string]util.FieldSpec{}
	ClusterRoleBinding_attrs  []string
)

func init() {
	t := reflect.TypeOf((*rbac.ClusterRoleBinding)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *rbac.ClusterRoleBinding:
			return ClusterRoleBinding{V: v}
		case rbac.ClusterRoleBinding:
			return ClusterRoleBinding{V: &v}
		default:
			return skylark.None
		}
	}
	ClusterRoleBinding_attrs = setFieldTypes(t, ClusterRoleBinding_fields, ClusterRoleBinding_inline)
	Library["ClusterRoleBinding"] = skylark.NewBuiltin("ClusterRoleBinding", createClusterRoleBinding)
}

func createClusterRoleBinding(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ClusterRoleBinding{V: &rbac.ClusterRoleBinding{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ClusterRoleBinding) Underlying() interface{} { return t.V }
func (t ClusterRoleBinding) DeepCopy() boxed         { return ClusterRoleBinding{V: t.V.DeepCopy()} }
func (t ClusterRoleBinding) Package() util.Package   { return util.Rbac }
func (t ClusterRoleBinding) Type() string            { return "k8s_rbac_ClusterRoleBinding" }
func (t ClusterRoleBinding) String() string          { return t.V.String() }
func (t ClusterRoleBinding) Freeze()                 {} // TODO
func (t ClusterRoleBinding) Truth() skylark.Bool     { return skylark.True }
func (t ClusterRoleBinding) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ClusterRoleBinding) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ClusterRoleBinding)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ClusterRoleBinding) AttrNames() []string { return ClusterRoleBinding_attrs }
func (t ClusterRoleBinding) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ClusterRoleBinding_fields, ClusterRoleBinding_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ClusterRoleBinding) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ClusterRoleBinding_fields, ClusterRoleBinding_inline)
}

type ClusterRoleBindingList struct {
	V *rbac.ClusterRoleBindingList
}

var (
	_ boxed = (*ClusterRoleBindingList)(nil)

	ClusterRoleBindingList_fields = map[string]util.FieldSpec{}
	ClusterRoleBindingList_inline = map[string]util.FieldSpec{}
	ClusterRoleBindingList_attrs  []string
)

func init() {
	t := reflect.TypeOf((*rbac.ClusterRoleBindingList)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *rbac.ClusterRoleBindingList:
			return ClusterRoleBindingList{V: v}
		case rbac.ClusterRoleBindingList:
			return ClusterRoleBindingList{V: &v}
		default:
			return skylark.None
		}
	}
	ClusterRoleBindingList_attrs = setFieldTypes(t, ClusterRoleBindingList_fields, ClusterRoleBindingList_inline)
	Library["ClusterRoleBindingList"] = skylark.NewBuiltin("ClusterRoleBindingList", createClusterRoleBindingList)
}

func createClusterRoleBindingList(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ClusterRoleBindingList{V: &rbac.ClusterRoleBindingList{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ClusterRoleBindingList) Underlying() interface{} { return t.V }
func (t ClusterRoleBindingList) DeepCopy() boxed         { return ClusterRoleBindingList{V: t.V.DeepCopy()} }
func (t ClusterRoleBindingList) Package() util.Package   { return util.Rbac }
func (t ClusterRoleBindingList) Type() string            { return "k8s_rbac_ClusterRoleBindingList" }
func (t ClusterRoleBindingList) String() string          { return t.V.String() }
func (t ClusterRoleBindingList) Freeze()                 {} // TODO
func (t ClusterRoleBindingList) Truth() skylark.Bool     { return skylark.True }
func (t ClusterRoleBindingList) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ClusterRoleBindingList) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ClusterRoleBindingList)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ClusterRoleBindingList) AttrNames() []string { return ClusterRoleBindingList_attrs }
func (t ClusterRoleBindingList) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ClusterRoleBindingList_fields, ClusterRoleBindingList_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ClusterRoleBindingList) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ClusterRoleBindingList_fields, ClusterRoleBindingList_inline)
}

type ClusterRoleList struct {
	V *rbac.ClusterRoleList
}

var (
	_ boxed = (*ClusterRoleList)(nil)

	ClusterRoleList_fields = map[string]util.FieldSpec{}
	ClusterRoleList_inline = map[string]util.FieldSpec{}
	ClusterRoleList_attrs  []string
)

func init() {
	t := reflect.TypeOf((*rbac.ClusterRoleList)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *rbac.ClusterRoleList:
			return ClusterRoleList{V: v}
		case rbac.ClusterRoleList:
			return ClusterRoleList{V: &v}
		default:
			return skylark.None
		}
	}
	ClusterRoleList_attrs = setFieldTypes(t, ClusterRoleList_fields, ClusterRoleList_inline)
	Library["ClusterRoleList"] = skylark.NewBuiltin("ClusterRoleList", createClusterRoleList)
}

func createClusterRoleList(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ClusterRoleList{V: &rbac.ClusterRoleList{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ClusterRoleList) Underlying() interface{} { return t.V }
func (t ClusterRoleList) DeepCopy() boxed         { return ClusterRoleList{V: t.V.DeepCopy()} }
func (t ClusterRoleList) Package() util.Package   { return util.Rbac }
func (t ClusterRoleList) Type() string            { return "k8s_rbac_ClusterRoleList" }
func (t ClusterRoleList) String() string          { return t.V.String() }
func (t ClusterRoleList) Freeze()                 {} // TODO
func (t ClusterRoleList) Truth() skylark.Bool     { return skylark.True }
func (t ClusterRoleList) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ClusterRoleList) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ClusterRoleList)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ClusterRoleList) AttrNames() []string { return ClusterRoleList_attrs }
func (t ClusterRoleList) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ClusterRoleList_fields, ClusterRoleList_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ClusterRoleList) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ClusterRoleList_fields, ClusterRoleList_inline)
}

type PolicyRule struct {
	V *rbac.PolicyRule
}

var (
	_ boxed = (*PolicyRule)(nil)

	PolicyRule_fields = map[string]util.FieldSpec{}
	PolicyRule_inline = map[string]util.FieldSpec{}
	PolicyRule_attrs  []string
)

func init() {
	t := reflect.TypeOf((*rbac.PolicyRule)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *rbac.PolicyRule:
			return PolicyRule{V: v}
		case rbac.PolicyRule:
			return PolicyRule{V: &v}
		default:
			return skylark.None
		}
	}
	PolicyRule_attrs = setFieldTypes(t, PolicyRule_fields, PolicyRule_inline)
	Library["PolicyRule"] = skylark.NewBuiltin("PolicyRule", createPolicyRule)
}

func createPolicyRule(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := PolicyRule{V: &rbac.PolicyRule{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t PolicyRule) Underlying() interface{} { return t.V }
func (t PolicyRule) DeepCopy() boxed         { return PolicyRule{V: t.V.DeepCopy()} }
func (t PolicyRule) Package() util.Package   { return util.Rbac }
func (t PolicyRule) Type() string            { return "k8s_rbac_PolicyRule" }
func (t PolicyRule) String() string          { return t.V.String() }
func (t PolicyRule) Freeze()                 {} // TODO
func (t PolicyRule) Truth() skylark.Bool     { return skylark.True }
func (t PolicyRule) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t PolicyRule) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*PolicyRule)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t PolicyRule) AttrNames() []string { return PolicyRule_attrs }
func (t PolicyRule) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, PolicyRule_fields, PolicyRule_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t PolicyRule) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, PolicyRule_fields, PolicyRule_inline)
}

type Role struct {
	V *rbac.Role
}

var (
	_ boxed = (*Role)(nil)

	Role_fields = map[string]util.FieldSpec{}
	Role_inline = map[string]util.FieldSpec{}
	Role_attrs  []string
)

func init() {
	t := reflect.TypeOf((*rbac.Role)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *rbac.Role:
			return Role{V: v}
		case rbac.Role:
			return Role{V: &v}
		default:
			return skylark.None
		}
	}
	Role_attrs = setFieldTypes(t, Role_fields, Role_inline)
	Library["Role"] = skylark.NewBuiltin("Role", createRole)
}

func createRole(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := Role{V: &rbac.Role{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t Role) Underlying() interface{} { return t.V }
func (t Role) DeepCopy() boxed         { return Role{V: t.V.DeepCopy()} }
func (t Role) Package() util.Package   { return util.Rbac }
func (t Role) Type() string            { return "k8s_rbac_Role" }
func (t Role) String() string          { return t.V.String() }
func (t Role) Freeze()                 {} // TODO
func (t Role) Truth() skylark.Bool     { return skylark.True }
func (t Role) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t Role) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*Role)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t Role) AttrNames() []string { return Role_attrs }
func (t Role) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, Role_fields, Role_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t Role) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, Role_fields, Role_inline)
}

type RoleBinding struct {
	V *rbac.RoleBinding
}

var (
	_ boxed = (*RoleBinding)(nil)

	RoleBinding_fields = map[string]util.FieldSpec{}
	RoleBinding_inline = map[string]util.FieldSpec{}
	RoleBinding_attrs  []string
)

func init() {
	t := reflect.TypeOf((*rbac.RoleBinding)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *rbac.RoleBinding:
			return RoleBinding{V: v}
		case rbac.RoleBinding:
			return RoleBinding{V: &v}
		default:
			return skylark.None
		}
	}
	RoleBinding_attrs = setFieldTypes(t, RoleBinding_fields, RoleBinding_inline)
	Library["RoleBinding"] = skylark.NewBuiltin("RoleBinding", createRoleBinding)
}

func createRoleBinding(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := RoleBinding{V: &rbac.RoleBinding{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t RoleBinding) Underlying() interface{} { return t.V }
func (t RoleBinding) DeepCopy() boxed         { return RoleBinding{V: t.V.DeepCopy()} }
func (t RoleBinding) Package() util.Package   { return util.Rbac }
func (t RoleBinding) Type() string            { return "k8s_rbac_RoleBinding" }
func (t RoleBinding) String() string          { return t.V.String() }
func (t RoleBinding) Freeze()                 {} // TODO
func (t RoleBinding) Truth() skylark.Bool     { return skylark.True }
func (t RoleBinding) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t RoleBinding) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*RoleBinding)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t RoleBinding) AttrNames() []string { return RoleBinding_attrs }
func (t RoleBinding) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, RoleBinding_fields, RoleBinding_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t RoleBinding) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, RoleBinding_fields, RoleBinding_inline)
}

type RoleBindingList struct {
	V *rbac.RoleBindingList
}

var (
	_ boxed = (*RoleBindingList)(nil)

	RoleBindingList_fields = map[string]util.FieldSpec{}
	RoleBindingList_inline = map[string]util.FieldSpec{}
	RoleBindingList_attrs  []string
)

func init() {
	t := reflect.TypeOf((*rbac.RoleBindingList)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *rbac.RoleBindingList:
			return RoleBindingList{V: v}
		case rbac.RoleBindingList:
			return RoleBindingList{V: &v}
		default:
			return skylark.None
		}
	}
	RoleBindingList_attrs = setFieldTypes(t, RoleBindingList_fields, RoleBindingList_inline)
	Library["RoleBindingList"] = skylark.NewBuiltin("RoleBindingList", createRoleBindingList)
}

func createRoleBindingList(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := RoleBindingList{V: &rbac.RoleBindingList{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t RoleBindingList) Underlying() interface{} { return t.V }
func (t RoleBindingList) DeepCopy() boxed         { return RoleBindingList{V: t.V.DeepCopy()} }
func (t RoleBindingList) Package() util.Package   { return util.Rbac }
func (t RoleBindingList) Type() string            { return "k8s_rbac_RoleBindingList" }
func (t RoleBindingList) String() string          { return t.V.String() }
func (t RoleBindingList) Freeze()                 {} // TODO
func (t RoleBindingList) Truth() skylark.Bool     { return skylark.True }
func (t RoleBindingList) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t RoleBindingList) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*RoleBindingList)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t RoleBindingList) AttrNames() []string { return RoleBindingList_attrs }
func (t RoleBindingList) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, RoleBindingList_fields, RoleBindingList_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t RoleBindingList) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, RoleBindingList_fields, RoleBindingList_inline)
}

type RoleList struct {
	V *rbac.RoleList
}

var (
	_ boxed = (*RoleList)(nil)

	RoleList_fields = map[string]util.FieldSpec{}
	RoleList_inline = map[string]util.FieldSpec{}
	RoleList_attrs  []string
)

func init() {
	t := reflect.TypeOf((*rbac.RoleList)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *rbac.RoleList:
			return RoleList{V: v}
		case rbac.RoleList:
			return RoleList{V: &v}
		default:
			return skylark.None
		}
	}
	RoleList_attrs = setFieldTypes(t, RoleList_fields, RoleList_inline)
	Library["RoleList"] = skylark.NewBuiltin("RoleList", createRoleList)
}

func createRoleList(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := RoleList{V: &rbac.RoleList{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t RoleList) Underlying() interface{} { return t.V }
func (t RoleList) DeepCopy() boxed         { return RoleList{V: t.V.DeepCopy()} }
func (t RoleList) Package() util.Package   { return util.Rbac }
func (t RoleList) Type() string            { return "k8s_rbac_RoleList" }
func (t RoleList) String() string          { return t.V.String() }
func (t RoleList) Freeze()                 {} // TODO
func (t RoleList) Truth() skylark.Bool     { return skylark.True }
func (t RoleList) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t RoleList) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*RoleList)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t RoleList) AttrNames() []string { return RoleList_attrs }
func (t RoleList) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, RoleList_fields, RoleList_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t RoleList) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, RoleList_fields, RoleList_inline)
}

type RoleRef struct {
	V *rbac.RoleRef
}

var (
	_ boxed = (*RoleRef)(nil)

	RoleRef_fields = map[string]util.FieldSpec{}
	RoleRef_inline = map[string]util.FieldSpec{}
	RoleRef_attrs  []string
)

func init() {
	t := reflect.TypeOf((*rbac.RoleRef)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *rbac.RoleRef:
			return RoleRef{V: v}
		case rbac.RoleRef:
			return RoleRef{V: &v}
		default:
			return skylark.None
		}
	}
	RoleRef_attrs = setFieldTypes(t, RoleRef_fields, RoleRef_inline)
	Library["RoleRef"] = skylark.NewBuiltin("RoleRef", createRoleRef)
}

func createRoleRef(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := RoleRef{V: &rbac.RoleRef{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t RoleRef) Underlying() interface{} { return t.V }
func (t RoleRef) DeepCopy() boxed         { return RoleRef{V: t.V.DeepCopy()} }
func (t RoleRef) Package() util.Package   { return util.Rbac }
func (t RoleRef) Type() string            { return "k8s_rbac_RoleRef" }
func (t RoleRef) String() string          { return t.V.String() }
func (t RoleRef) Freeze()                 {} // TODO
func (t RoleRef) Truth() skylark.Bool     { return skylark.True }
func (t RoleRef) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t RoleRef) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*RoleRef)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t RoleRef) AttrNames() []string { return RoleRef_attrs }
func (t RoleRef) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, RoleRef_fields, RoleRef_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t RoleRef) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, RoleRef_fields, RoleRef_inline)
}

type Subject struct {
	V *rbac.Subject
}

var (
	_ boxed = (*Subject)(nil)

	Subject_fields = map[string]util.FieldSpec{}
	Subject_inline = map[string]util.FieldSpec{}
	Subject_attrs  []string
)

func init() {
	t := reflect.TypeOf((*rbac.Subject)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *rbac.Subject:
			return Subject{V: v}
		case rbac.Subject:
			return Subject{V: &v}
		default:
			return skylark.None
		}
	}
	Subject_attrs = setFieldTypes(t, Subject_fields, Subject_inline)
	Library["Subject"] = skylark.NewBuiltin("Subject", createSubject)
}

func createSubject(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := Subject{V: &rbac.Subject{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t Subject) Underlying() interface{} { return t.V }
func (t Subject) DeepCopy() boxed         { return Subject{V: t.V.DeepCopy()} }
func (t Subject) Package() util.Package   { return util.Rbac }
func (t Subject) Type() string            { return "k8s_rbac_Subject" }
func (t Subject) String() string          { return t.V.String() }
func (t Subject) Freeze()                 {} // TODO
func (t Subject) Truth() skylark.Bool     { return skylark.True }
func (t Subject) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t Subject) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*Subject)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t Subject) AttrNames() []string { return Subject_attrs }
func (t Subject) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, Subject_fields, Subject_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t Subject) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, Subject_fields, Subject_inline)
}

type StorageClass struct {
	V *storage.StorageClass
}

var (
	_ boxed = (*StorageClass)(nil)

	StorageClass_fields = map[string]util.FieldSpec{}
	StorageClass_inline = map[string]util.FieldSpec{}
	StorageClass_attrs  []string
)

func init() {
	t := reflect.TypeOf((*storage.StorageClass)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *storage.StorageClass:
			return StorageClass{V: v}
		case storage.StorageClass:
			return StorageClass{V: &v}
		default:
			return skylark.None
		}
	}
	StorageClass_attrs = setFieldTypes(t, StorageClass_fields, StorageClass_inline)
	Library["StorageClass"] = skylark.NewBuiltin("StorageClass", createStorageClass)
}

func createStorageClass(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := StorageClass{V: &storage.StorageClass{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t StorageClass) Underlying() interface{} { return t.V }
func (t StorageClass) DeepCopy() boxed         { return StorageClass{V: t.V.DeepCopy()} }
func (t StorageClass) Package() util.Package   { return util.Storage }
func (t StorageClass) Type() string            { return "k8s_storage_StorageClass" }
func (t StorageClass) String() string          { return t.V.String() }
func (t StorageClass) Freeze()                 {} // TODO
func (t StorageClass) Truth() skylark.Bool     { return skylark.True }
func (t StorageClass) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t StorageClass) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*StorageClass)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t StorageClass) AttrNames() []string { return StorageClass_attrs }
func (t StorageClass) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, StorageClass_fields, StorageClass_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t StorageClass) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, StorageClass_fields, StorageClass_inline)
}

type StorageClassList struct {
	V *storage.StorageClassList
}

var (
	_ boxed = (*StorageClassList)(nil)

	StorageClassList_fields = map[string]util.FieldSpec{}
	StorageClassList_inline = map[string]util.FieldSpec{}
	StorageClassList_attrs  []string
)

func init() {
	t := reflect.TypeOf((*storage.StorageClassList)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *storage.StorageClassList:
			return StorageClassList{V: v}
		case storage.StorageClassList:
			return StorageClassList{V: &v}
		default:
			return skylark.None
		}
	}
	StorageClassList_attrs = setFieldTypes(t, StorageClassList_fields, StorageClassList_inline)
	Library["StorageClassList"] = skylark.NewBuiltin("StorageClassList", createStorageClassList)
}

func createStorageClassList(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := StorageClassList{V: &storage.StorageClassList{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t StorageClassList) Underlying() interface{} { return t.V }
func (t StorageClassList) DeepCopy() boxed         { return StorageClassList{V: t.V.DeepCopy()} }
func (t StorageClassList) Package() util.Package   { return util.Storage }
func (t StorageClassList) Type() string            { return "k8s_storage_StorageClassList" }
func (t StorageClassList) String() string          { return t.V.String() }
func (t StorageClassList) Freeze()                 {} // TODO
func (t StorageClassList) Truth() skylark.Bool     { return skylark.True }
func (t StorageClassList) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t StorageClassList) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*StorageClassList)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t StorageClassList) AttrNames() []string { return StorageClassList_attrs }
func (t StorageClassList) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, StorageClassList_fields, StorageClassList_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t StorageClassList) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, StorageClassList_fields, StorageClassList_inline)
}

type APIGroup struct {
	V *meta.APIGroup
}

var (
	_ boxed = (*APIGroup)(nil)

	APIGroup_fields = map[string]util.FieldSpec{}
	APIGroup_inline = map[string]util.FieldSpec{}
	APIGroup_attrs  []string
)

func init() {
	t := reflect.TypeOf((*meta.APIGroup)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *meta.APIGroup:
			return APIGroup{V: v}
		case meta.APIGroup:
			return APIGroup{V: &v}
		default:
			return skylark.None
		}
	}
	APIGroup_attrs = setFieldTypes(t, APIGroup_fields, APIGroup_inline)
	Library["APIGroup"] = skylark.NewBuiltin("APIGroup", createAPIGroup)
}

func createAPIGroup(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := APIGroup{V: &meta.APIGroup{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t APIGroup) Underlying() interface{} { return t.V }
func (t APIGroup) DeepCopy() boxed         { return APIGroup{V: t.V.DeepCopy()} }
func (t APIGroup) Package() util.Package   { return util.Meta }
func (t APIGroup) Type() string            { return "k8s_meta_APIGroup" }
func (t APIGroup) String() string          { return t.V.String() }
func (t APIGroup) Freeze()                 {} // TODO
func (t APIGroup) Truth() skylark.Bool     { return skylark.True }
func (t APIGroup) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t APIGroup) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*APIGroup)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t APIGroup) AttrNames() []string { return APIGroup_attrs }
func (t APIGroup) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, APIGroup_fields, APIGroup_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t APIGroup) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, APIGroup_fields, APIGroup_inline)
}

type APIGroupList struct {
	V *meta.APIGroupList
}

var (
	_ boxed = (*APIGroupList)(nil)

	APIGroupList_fields = map[string]util.FieldSpec{}
	APIGroupList_inline = map[string]util.FieldSpec{}
	APIGroupList_attrs  []string
)

func init() {
	t := reflect.TypeOf((*meta.APIGroupList)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *meta.APIGroupList:
			return APIGroupList{V: v}
		case meta.APIGroupList:
			return APIGroupList{V: &v}
		default:
			return skylark.None
		}
	}
	APIGroupList_attrs = setFieldTypes(t, APIGroupList_fields, APIGroupList_inline)
	Library["APIGroupList"] = skylark.NewBuiltin("APIGroupList", createAPIGroupList)
}

func createAPIGroupList(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := APIGroupList{V: &meta.APIGroupList{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t APIGroupList) Underlying() interface{} { return t.V }
func (t APIGroupList) DeepCopy() boxed         { return APIGroupList{V: t.V.DeepCopy()} }
func (t APIGroupList) Package() util.Package   { return util.Meta }
func (t APIGroupList) Type() string            { return "k8s_meta_APIGroupList" }
func (t APIGroupList) String() string          { return t.V.String() }
func (t APIGroupList) Freeze()                 {} // TODO
func (t APIGroupList) Truth() skylark.Bool     { return skylark.True }
func (t APIGroupList) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t APIGroupList) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*APIGroupList)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t APIGroupList) AttrNames() []string { return APIGroupList_attrs }
func (t APIGroupList) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, APIGroupList_fields, APIGroupList_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t APIGroupList) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, APIGroupList_fields, APIGroupList_inline)
}

type APIResource struct {
	V *meta.APIResource
}

var (
	_ boxed = (*APIResource)(nil)

	APIResource_fields = map[string]util.FieldSpec{}
	APIResource_inline = map[string]util.FieldSpec{}
	APIResource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*meta.APIResource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *meta.APIResource:
			return APIResource{V: v}
		case meta.APIResource:
			return APIResource{V: &v}
		default:
			return skylark.None
		}
	}
	APIResource_attrs = setFieldTypes(t, APIResource_fields, APIResource_inline)
	Library["APIResource"] = skylark.NewBuiltin("APIResource", createAPIResource)
}

func createAPIResource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := APIResource{V: &meta.APIResource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t APIResource) Underlying() interface{} { return t.V }
func (t APIResource) DeepCopy() boxed         { return APIResource{V: t.V.DeepCopy()} }
func (t APIResource) Package() util.Package   { return util.Meta }
func (t APIResource) Type() string            { return "k8s_meta_APIResource" }
func (t APIResource) String() string          { return t.V.String() }
func (t APIResource) Freeze()                 {} // TODO
func (t APIResource) Truth() skylark.Bool     { return skylark.True }
func (t APIResource) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t APIResource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*APIResource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t APIResource) AttrNames() []string { return APIResource_attrs }
func (t APIResource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, APIResource_fields, APIResource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t APIResource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, APIResource_fields, APIResource_inline)
}

type APIResourceList struct {
	V *meta.APIResourceList
}

var (
	_ boxed = (*APIResourceList)(nil)

	APIResourceList_fields = map[string]util.FieldSpec{}
	APIResourceList_inline = map[string]util.FieldSpec{}
	APIResourceList_attrs  []string
)

func init() {
	t := reflect.TypeOf((*meta.APIResourceList)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *meta.APIResourceList:
			return APIResourceList{V: v}
		case meta.APIResourceList:
			return APIResourceList{V: &v}
		default:
			return skylark.None
		}
	}
	APIResourceList_attrs = setFieldTypes(t, APIResourceList_fields, APIResourceList_inline)
	Library["APIResourceList"] = skylark.NewBuiltin("APIResourceList", createAPIResourceList)
}

func createAPIResourceList(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := APIResourceList{V: &meta.APIResourceList{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t APIResourceList) Underlying() interface{} { return t.V }
func (t APIResourceList) DeepCopy() boxed         { return APIResourceList{V: t.V.DeepCopy()} }
func (t APIResourceList) Package() util.Package   { return util.Meta }
func (t APIResourceList) Type() string            { return "k8s_meta_APIResourceList" }
func (t APIResourceList) String() string          { return t.V.String() }
func (t APIResourceList) Freeze()                 {} // TODO
func (t APIResourceList) Truth() skylark.Bool     { return skylark.True }
func (t APIResourceList) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t APIResourceList) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*APIResourceList)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t APIResourceList) AttrNames() []string { return APIResourceList_attrs }
func (t APIResourceList) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, APIResourceList_fields, APIResourceList_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t APIResourceList) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, APIResourceList_fields, APIResourceList_inline)
}

type APIVersions struct {
	V *meta.APIVersions
}

var (
	_ boxed = (*APIVersions)(nil)

	APIVersions_fields = map[string]util.FieldSpec{}
	APIVersions_inline = map[string]util.FieldSpec{}
	APIVersions_attrs  []string
)

func init() {
	t := reflect.TypeOf((*meta.APIVersions)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *meta.APIVersions:
			return APIVersions{V: v}
		case meta.APIVersions:
			return APIVersions{V: &v}
		default:
			return skylark.None
		}
	}
	APIVersions_attrs = setFieldTypes(t, APIVersions_fields, APIVersions_inline)
	Library["APIVersions"] = skylark.NewBuiltin("APIVersions", createAPIVersions)
}

func createAPIVersions(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := APIVersions{V: &meta.APIVersions{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t APIVersions) Underlying() interface{} { return t.V }
func (t APIVersions) DeepCopy() boxed         { return APIVersions{V: t.V.DeepCopy()} }
func (t APIVersions) Package() util.Package   { return util.Meta }
func (t APIVersions) Type() string            { return "k8s_meta_APIVersions" }
func (t APIVersions) String() string          { return t.V.String() }
func (t APIVersions) Freeze()                 {} // TODO
func (t APIVersions) Truth() skylark.Bool     { return skylark.True }
func (t APIVersions) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t APIVersions) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*APIVersions)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t APIVersions) AttrNames() []string { return APIVersions_attrs }
func (t APIVersions) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, APIVersions_fields, APIVersions_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t APIVersions) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, APIVersions_fields, APIVersions_inline)
}

type CreateOptions struct {
	V *meta.CreateOptions
}

var (
	_ boxed = (*CreateOptions)(nil)

	CreateOptions_fields = map[string]util.FieldSpec{}
	CreateOptions_inline = map[string]util.FieldSpec{}
	CreateOptions_attrs  []string
)

func init() {
	t := reflect.TypeOf((*meta.CreateOptions)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *meta.CreateOptions:
			return CreateOptions{V: v}
		case meta.CreateOptions:
			return CreateOptions{V: &v}
		default:
			return skylark.None
		}
	}
	CreateOptions_attrs = setFieldTypes(t, CreateOptions_fields, CreateOptions_inline)
	Library["CreateOptions"] = skylark.NewBuiltin("CreateOptions", createCreateOptions)
}

func createCreateOptions(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := CreateOptions{V: &meta.CreateOptions{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t CreateOptions) Underlying() interface{} { return t.V }
func (t CreateOptions) DeepCopy() boxed         { return CreateOptions{V: t.V.DeepCopy()} }
func (t CreateOptions) Package() util.Package   { return util.Meta }
func (t CreateOptions) Type() string            { return "k8s_meta_CreateOptions" }
func (t CreateOptions) String() string          { return t.V.String() }
func (t CreateOptions) Freeze()                 {} // TODO
func (t CreateOptions) Truth() skylark.Bool     { return skylark.True }
func (t CreateOptions) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t CreateOptions) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*CreateOptions)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t CreateOptions) AttrNames() []string { return CreateOptions_attrs }
func (t CreateOptions) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, CreateOptions_fields, CreateOptions_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t CreateOptions) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, CreateOptions_fields, CreateOptions_inline)
}

type DeleteOptions struct {
	V *meta.DeleteOptions
}

var (
	_ boxed = (*DeleteOptions)(nil)

	DeleteOptions_fields = map[string]util.FieldSpec{}
	DeleteOptions_inline = map[string]util.FieldSpec{}
	DeleteOptions_attrs  []string
)

func init() {
	t := reflect.TypeOf((*meta.DeleteOptions)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *meta.DeleteOptions:
			return DeleteOptions{V: v}
		case meta.DeleteOptions:
			return DeleteOptions{V: &v}
		default:
			return skylark.None
		}
	}
	DeleteOptions_attrs = setFieldTypes(t, DeleteOptions_fields, DeleteOptions_inline)
	Library["DeleteOptions"] = skylark.NewBuiltin("DeleteOptions", createDeleteOptions)
}

func createDeleteOptions(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := DeleteOptions{V: &meta.DeleteOptions{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t DeleteOptions) Underlying() interface{} { return t.V }
func (t DeleteOptions) DeepCopy() boxed         { return DeleteOptions{V: t.V.DeepCopy()} }
func (t DeleteOptions) Package() util.Package   { return util.Meta }
func (t DeleteOptions) Type() string            { return "k8s_meta_DeleteOptions" }
func (t DeleteOptions) String() string          { return t.V.String() }
func (t DeleteOptions) Freeze()                 {} // TODO
func (t DeleteOptions) Truth() skylark.Bool     { return skylark.True }
func (t DeleteOptions) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t DeleteOptions) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*DeleteOptions)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t DeleteOptions) AttrNames() []string { return DeleteOptions_attrs }
func (t DeleteOptions) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, DeleteOptions_fields, DeleteOptions_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t DeleteOptions) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, DeleteOptions_fields, DeleteOptions_inline)
}

type ExportOptions struct {
	V *meta.ExportOptions
}

var (
	_ boxed = (*ExportOptions)(nil)

	ExportOptions_fields = map[string]util.FieldSpec{}
	ExportOptions_inline = map[string]util.FieldSpec{}
	ExportOptions_attrs  []string
)

func init() {
	t := reflect.TypeOf((*meta.ExportOptions)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *meta.ExportOptions:
			return ExportOptions{V: v}
		case meta.ExportOptions:
			return ExportOptions{V: &v}
		default:
			return skylark.None
		}
	}
	ExportOptions_attrs = setFieldTypes(t, ExportOptions_fields, ExportOptions_inline)
	Library["ExportOptions"] = skylark.NewBuiltin("ExportOptions", createExportOptions)
}

func createExportOptions(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ExportOptions{V: &meta.ExportOptions{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ExportOptions) Underlying() interface{} { return t.V }
func (t ExportOptions) DeepCopy() boxed         { return ExportOptions{V: t.V.DeepCopy()} }
func (t ExportOptions) Package() util.Package   { return util.Meta }
func (t ExportOptions) Type() string            { return "k8s_meta_ExportOptions" }
func (t ExportOptions) String() string          { return t.V.String() }
func (t ExportOptions) Freeze()                 {} // TODO
func (t ExportOptions) Truth() skylark.Bool     { return skylark.True }
func (t ExportOptions) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ExportOptions) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ExportOptions)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ExportOptions) AttrNames() []string { return ExportOptions_attrs }
func (t ExportOptions) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ExportOptions_fields, ExportOptions_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ExportOptions) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ExportOptions_fields, ExportOptions_inline)
}

type GetOptions struct {
	V *meta.GetOptions
}

var (
	_ boxed = (*GetOptions)(nil)

	GetOptions_fields = map[string]util.FieldSpec{}
	GetOptions_inline = map[string]util.FieldSpec{}
	GetOptions_attrs  []string
)

func init() {
	t := reflect.TypeOf((*meta.GetOptions)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *meta.GetOptions:
			return GetOptions{V: v}
		case meta.GetOptions:
			return GetOptions{V: &v}
		default:
			return skylark.None
		}
	}
	GetOptions_attrs = setFieldTypes(t, GetOptions_fields, GetOptions_inline)
	Library["GetOptions"] = skylark.NewBuiltin("GetOptions", createGetOptions)
}

func createGetOptions(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := GetOptions{V: &meta.GetOptions{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t GetOptions) Underlying() interface{} { return t.V }
func (t GetOptions) DeepCopy() boxed         { return GetOptions{V: t.V.DeepCopy()} }
func (t GetOptions) Package() util.Package   { return util.Meta }
func (t GetOptions) Type() string            { return "k8s_meta_GetOptions" }
func (t GetOptions) String() string          { return t.V.String() }
func (t GetOptions) Freeze()                 {} // TODO
func (t GetOptions) Truth() skylark.Bool     { return skylark.True }
func (t GetOptions) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t GetOptions) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*GetOptions)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t GetOptions) AttrNames() []string { return GetOptions_attrs }
func (t GetOptions) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, GetOptions_fields, GetOptions_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t GetOptions) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, GetOptions_fields, GetOptions_inline)
}

type GroupKind struct {
	V *meta.GroupKind
}

var (
	_ boxed = (*GroupKind)(nil)

	GroupKind_fields = map[string]util.FieldSpec{}
	GroupKind_inline = map[string]util.FieldSpec{}
	GroupKind_attrs  []string
)

func init() {
	t := reflect.TypeOf((*meta.GroupKind)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *meta.GroupKind:
			return GroupKind{V: v}
		case meta.GroupKind:
			return GroupKind{V: &v}
		default:
			return skylark.None
		}
	}
	GroupKind_attrs = setFieldTypes(t, GroupKind_fields, GroupKind_inline)
	Library["GroupKind"] = skylark.NewBuiltin("GroupKind", createGroupKind)
}

func createGroupKind(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := GroupKind{V: &meta.GroupKind{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t GroupKind) Underlying() interface{} { return t.V }
func (t GroupKind) DeepCopy() boxed         { return GroupKind{V: t.V.DeepCopy()} }
func (t GroupKind) Package() util.Package   { return util.Meta }
func (t GroupKind) Type() string            { return "k8s_meta_GroupKind" }
func (t GroupKind) String() string          { return t.V.String() }
func (t GroupKind) Freeze()                 {} // TODO
func (t GroupKind) Truth() skylark.Bool     { return skylark.True }
func (t GroupKind) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t GroupKind) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*GroupKind)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t GroupKind) AttrNames() []string { return GroupKind_attrs }
func (t GroupKind) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, GroupKind_fields, GroupKind_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t GroupKind) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, GroupKind_fields, GroupKind_inline)
}

type GroupResource struct {
	V *meta.GroupResource
}

var (
	_ boxed = (*GroupResource)(nil)

	GroupResource_fields = map[string]util.FieldSpec{}
	GroupResource_inline = map[string]util.FieldSpec{}
	GroupResource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*meta.GroupResource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *meta.GroupResource:
			return GroupResource{V: v}
		case meta.GroupResource:
			return GroupResource{V: &v}
		default:
			return skylark.None
		}
	}
	GroupResource_attrs = setFieldTypes(t, GroupResource_fields, GroupResource_inline)
	Library["GroupResource"] = skylark.NewBuiltin("GroupResource", createGroupResource)
}

func createGroupResource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := GroupResource{V: &meta.GroupResource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t GroupResource) Underlying() interface{} { return t.V }
func (t GroupResource) DeepCopy() boxed         { return GroupResource{V: t.V.DeepCopy()} }
func (t GroupResource) Package() util.Package   { return util.Meta }
func (t GroupResource) Type() string            { return "k8s_meta_GroupResource" }
func (t GroupResource) String() string          { return t.V.String() }
func (t GroupResource) Freeze()                 {} // TODO
func (t GroupResource) Truth() skylark.Bool     { return skylark.True }
func (t GroupResource) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t GroupResource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*GroupResource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t GroupResource) AttrNames() []string { return GroupResource_attrs }
func (t GroupResource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, GroupResource_fields, GroupResource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t GroupResource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, GroupResource_fields, GroupResource_inline)
}

type GroupVersion struct {
	V *meta.GroupVersion
}

var (
	_ boxed = (*GroupVersion)(nil)

	GroupVersion_fields = map[string]util.FieldSpec{}
	GroupVersion_inline = map[string]util.FieldSpec{}
	GroupVersion_attrs  []string
)

func init() {
	t := reflect.TypeOf((*meta.GroupVersion)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *meta.GroupVersion:
			return GroupVersion{V: v}
		case meta.GroupVersion:
			return GroupVersion{V: &v}
		default:
			return skylark.None
		}
	}
	GroupVersion_attrs = setFieldTypes(t, GroupVersion_fields, GroupVersion_inline)
	Library["GroupVersion"] = skylark.NewBuiltin("GroupVersion", createGroupVersion)
}

func createGroupVersion(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := GroupVersion{V: &meta.GroupVersion{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t GroupVersion) Underlying() interface{} { return t.V }
func (t GroupVersion) DeepCopy() boxed         { return GroupVersion{V: t.V.DeepCopy()} }
func (t GroupVersion) Package() util.Package   { return util.Meta }
func (t GroupVersion) Type() string            { return "k8s_meta_GroupVersion" }
func (t GroupVersion) String() string          { return t.V.String() }
func (t GroupVersion) Freeze()                 {} // TODO
func (t GroupVersion) Truth() skylark.Bool     { return skylark.True }
func (t GroupVersion) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t GroupVersion) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*GroupVersion)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t GroupVersion) AttrNames() []string { return GroupVersion_attrs }
func (t GroupVersion) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, GroupVersion_fields, GroupVersion_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t GroupVersion) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, GroupVersion_fields, GroupVersion_inline)
}

type GroupVersionForDiscovery struct {
	V *meta.GroupVersionForDiscovery
}

var (
	_ boxed = (*GroupVersionForDiscovery)(nil)

	GroupVersionForDiscovery_fields = map[string]util.FieldSpec{}
	GroupVersionForDiscovery_inline = map[string]util.FieldSpec{}
	GroupVersionForDiscovery_attrs  []string
)

func init() {
	t := reflect.TypeOf((*meta.GroupVersionForDiscovery)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *meta.GroupVersionForDiscovery:
			return GroupVersionForDiscovery{V: v}
		case meta.GroupVersionForDiscovery:
			return GroupVersionForDiscovery{V: &v}
		default:
			return skylark.None
		}
	}
	GroupVersionForDiscovery_attrs = setFieldTypes(t, GroupVersionForDiscovery_fields, GroupVersionForDiscovery_inline)
	Library["GroupVersionForDiscovery"] = skylark.NewBuiltin("GroupVersionForDiscovery", createGroupVersionForDiscovery)
}

func createGroupVersionForDiscovery(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := GroupVersionForDiscovery{V: &meta.GroupVersionForDiscovery{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t GroupVersionForDiscovery) Underlying() interface{} { return t.V }
func (t GroupVersionForDiscovery) DeepCopy() boxed         { return GroupVersionForDiscovery{V: t.V.DeepCopy()} }
func (t GroupVersionForDiscovery) Package() util.Package   { return util.Meta }
func (t GroupVersionForDiscovery) Type() string            { return "k8s_meta_GroupVersionForDiscovery" }
func (t GroupVersionForDiscovery) String() string          { return t.V.String() }
func (t GroupVersionForDiscovery) Freeze()                 {} // TODO
func (t GroupVersionForDiscovery) Truth() skylark.Bool     { return skylark.True }
func (t GroupVersionForDiscovery) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t GroupVersionForDiscovery) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*GroupVersionForDiscovery)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t GroupVersionForDiscovery) AttrNames() []string { return GroupVersionForDiscovery_attrs }
func (t GroupVersionForDiscovery) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, GroupVersionForDiscovery_fields, GroupVersionForDiscovery_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t GroupVersionForDiscovery) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, GroupVersionForDiscovery_fields, GroupVersionForDiscovery_inline)
}

type GroupVersionKind struct {
	V *meta.GroupVersionKind
}

var (
	_ boxed = (*GroupVersionKind)(nil)

	GroupVersionKind_fields = map[string]util.FieldSpec{}
	GroupVersionKind_inline = map[string]util.FieldSpec{}
	GroupVersionKind_attrs  []string
)

func init() {
	t := reflect.TypeOf((*meta.GroupVersionKind)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *meta.GroupVersionKind:
			return GroupVersionKind{V: v}
		case meta.GroupVersionKind:
			return GroupVersionKind{V: &v}
		default:
			return skylark.None
		}
	}
	GroupVersionKind_attrs = setFieldTypes(t, GroupVersionKind_fields, GroupVersionKind_inline)
	Library["GroupVersionKind"] = skylark.NewBuiltin("GroupVersionKind", createGroupVersionKind)
}

func createGroupVersionKind(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := GroupVersionKind{V: &meta.GroupVersionKind{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t GroupVersionKind) Underlying() interface{} { return t.V }
func (t GroupVersionKind) DeepCopy() boxed         { return GroupVersionKind{V: t.V.DeepCopy()} }
func (t GroupVersionKind) Package() util.Package   { return util.Meta }
func (t GroupVersionKind) Type() string            { return "k8s_meta_GroupVersionKind" }
func (t GroupVersionKind) String() string          { return t.V.String() }
func (t GroupVersionKind) Freeze()                 {} // TODO
func (t GroupVersionKind) Truth() skylark.Bool     { return skylark.True }
func (t GroupVersionKind) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t GroupVersionKind) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*GroupVersionKind)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t GroupVersionKind) AttrNames() []string { return GroupVersionKind_attrs }
func (t GroupVersionKind) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, GroupVersionKind_fields, GroupVersionKind_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t GroupVersionKind) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, GroupVersionKind_fields, GroupVersionKind_inline)
}

type GroupVersionResource struct {
	V *meta.GroupVersionResource
}

var (
	_ boxed = (*GroupVersionResource)(nil)

	GroupVersionResource_fields = map[string]util.FieldSpec{}
	GroupVersionResource_inline = map[string]util.FieldSpec{}
	GroupVersionResource_attrs  []string
)

func init() {
	t := reflect.TypeOf((*meta.GroupVersionResource)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *meta.GroupVersionResource:
			return GroupVersionResource{V: v}
		case meta.GroupVersionResource:
			return GroupVersionResource{V: &v}
		default:
			return skylark.None
		}
	}
	GroupVersionResource_attrs = setFieldTypes(t, GroupVersionResource_fields, GroupVersionResource_inline)
	Library["GroupVersionResource"] = skylark.NewBuiltin("GroupVersionResource", createGroupVersionResource)
}

func createGroupVersionResource(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := GroupVersionResource{V: &meta.GroupVersionResource{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t GroupVersionResource) Underlying() interface{} { return t.V }
func (t GroupVersionResource) DeepCopy() boxed         { return GroupVersionResource{V: t.V.DeepCopy()} }
func (t GroupVersionResource) Package() util.Package   { return util.Meta }
func (t GroupVersionResource) Type() string            { return "k8s_meta_GroupVersionResource" }
func (t GroupVersionResource) String() string          { return t.V.String() }
func (t GroupVersionResource) Freeze()                 {} // TODO
func (t GroupVersionResource) Truth() skylark.Bool     { return skylark.True }
func (t GroupVersionResource) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t GroupVersionResource) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*GroupVersionResource)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t GroupVersionResource) AttrNames() []string { return GroupVersionResource_attrs }
func (t GroupVersionResource) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, GroupVersionResource_fields, GroupVersionResource_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t GroupVersionResource) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, GroupVersionResource_fields, GroupVersionResource_inline)
}

type Initializer struct {
	V *meta.Initializer
}

var (
	_ boxed = (*Initializer)(nil)

	Initializer_fields = map[string]util.FieldSpec{}
	Initializer_inline = map[string]util.FieldSpec{}
	Initializer_attrs  []string
)

func init() {
	t := reflect.TypeOf((*meta.Initializer)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *meta.Initializer:
			return Initializer{V: v}
		case meta.Initializer:
			return Initializer{V: &v}
		default:
			return skylark.None
		}
	}
	Initializer_attrs = setFieldTypes(t, Initializer_fields, Initializer_inline)
	Library["Initializer"] = skylark.NewBuiltin("Initializer", createInitializer)
}

func createInitializer(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := Initializer{V: &meta.Initializer{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t Initializer) Underlying() interface{} { return t.V }
func (t Initializer) DeepCopy() boxed         { return Initializer{V: t.V.DeepCopy()} }
func (t Initializer) Package() util.Package   { return util.Meta }
func (t Initializer) Type() string            { return "k8s_meta_Initializer" }
func (t Initializer) String() string          { return t.V.String() }
func (t Initializer) Freeze()                 {} // TODO
func (t Initializer) Truth() skylark.Bool     { return skylark.True }
func (t Initializer) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t Initializer) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*Initializer)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t Initializer) AttrNames() []string { return Initializer_attrs }
func (t Initializer) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, Initializer_fields, Initializer_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t Initializer) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, Initializer_fields, Initializer_inline)
}

type Initializers struct {
	V *meta.Initializers
}

var (
	_ boxed = (*Initializers)(nil)

	Initializers_fields = map[string]util.FieldSpec{}
	Initializers_inline = map[string]util.FieldSpec{}
	Initializers_attrs  []string
)

func init() {
	t := reflect.TypeOf((*meta.Initializers)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *meta.Initializers:
			return Initializers{V: v}
		case meta.Initializers:
			return Initializers{V: &v}
		default:
			return skylark.None
		}
	}
	Initializers_attrs = setFieldTypes(t, Initializers_fields, Initializers_inline)
	Library["Initializers"] = skylark.NewBuiltin("Initializers", createInitializers)
}

func createInitializers(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := Initializers{V: &meta.Initializers{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t Initializers) Underlying() interface{} { return t.V }
func (t Initializers) DeepCopy() boxed         { return Initializers{V: t.V.DeepCopy()} }
func (t Initializers) Package() util.Package   { return util.Meta }
func (t Initializers) Type() string            { return "k8s_meta_Initializers" }
func (t Initializers) String() string          { return t.V.String() }
func (t Initializers) Freeze()                 {} // TODO
func (t Initializers) Truth() skylark.Bool     { return skylark.True }
func (t Initializers) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t Initializers) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*Initializers)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t Initializers) AttrNames() []string { return Initializers_attrs }
func (t Initializers) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, Initializers_fields, Initializers_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t Initializers) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, Initializers_fields, Initializers_inline)
}

type InternalEvent struct {
	V *meta.InternalEvent
}

var (
	_ boxed = (*InternalEvent)(nil)

	InternalEvent_fields = map[string]util.FieldSpec{}
	InternalEvent_inline = map[string]util.FieldSpec{}
	InternalEvent_attrs  []string
)

func init() {
	t := reflect.TypeOf((*meta.InternalEvent)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *meta.InternalEvent:
			return InternalEvent{V: v}
		case meta.InternalEvent:
			return InternalEvent{V: &v}
		default:
			return skylark.None
		}
	}
	InternalEvent_attrs = setFieldTypes(t, InternalEvent_fields, InternalEvent_inline)
	Library["InternalEvent"] = skylark.NewBuiltin("InternalEvent", createInternalEvent)
}

func createInternalEvent(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := InternalEvent{V: &meta.InternalEvent{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t InternalEvent) Underlying() interface{} { return t.V }
func (t InternalEvent) DeepCopy() boxed         { return InternalEvent{V: t.V.DeepCopy()} }
func (t InternalEvent) Package() util.Package   { return util.Meta }
func (t InternalEvent) Type() string            { return "k8s_meta_InternalEvent" }
func (t InternalEvent) String() string          { return genericStringMethod(t.V) }
func (t InternalEvent) Freeze()                 {} // TODO
func (t InternalEvent) Truth() skylark.Bool     { return skylark.True }
func (t InternalEvent) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t InternalEvent) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*InternalEvent)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t InternalEvent) AttrNames() []string { return InternalEvent_attrs }
func (t InternalEvent) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, InternalEvent_fields, InternalEvent_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t InternalEvent) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, InternalEvent_fields, InternalEvent_inline)
}

type LabelSelector struct {
	V *meta.LabelSelector
}

var (
	_ boxed = (*LabelSelector)(nil)

	LabelSelector_fields = map[string]util.FieldSpec{}
	LabelSelector_inline = map[string]util.FieldSpec{}
	LabelSelector_attrs  []string
)

func init() {
	t := reflect.TypeOf((*meta.LabelSelector)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *meta.LabelSelector:
			return LabelSelector{V: v}
		case meta.LabelSelector:
			return LabelSelector{V: &v}
		default:
			return skylark.None
		}
	}
	LabelSelector_attrs = setFieldTypes(t, LabelSelector_fields, LabelSelector_inline)
	Library["LabelSelector"] = skylark.NewBuiltin("LabelSelector", createLabelSelector)
}

func createLabelSelector(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := LabelSelector{V: &meta.LabelSelector{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t LabelSelector) Underlying() interface{} { return t.V }
func (t LabelSelector) DeepCopy() boxed         { return LabelSelector{V: t.V.DeepCopy()} }
func (t LabelSelector) Package() util.Package   { return util.Meta }
func (t LabelSelector) Type() string            { return "k8s_meta_LabelSelector" }
func (t LabelSelector) String() string          { return t.V.String() }
func (t LabelSelector) Freeze()                 {} // TODO
func (t LabelSelector) Truth() skylark.Bool     { return skylark.True }
func (t LabelSelector) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t LabelSelector) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*LabelSelector)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t LabelSelector) AttrNames() []string { return LabelSelector_attrs }
func (t LabelSelector) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, LabelSelector_fields, LabelSelector_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t LabelSelector) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, LabelSelector_fields, LabelSelector_inline)
}

type LabelSelectorRequirement struct {
	V *meta.LabelSelectorRequirement
}

var (
	_ boxed = (*LabelSelectorRequirement)(nil)

	LabelSelectorRequirement_fields = map[string]util.FieldSpec{}
	LabelSelectorRequirement_inline = map[string]util.FieldSpec{}
	LabelSelectorRequirement_attrs  []string
)

func init() {
	t := reflect.TypeOf((*meta.LabelSelectorRequirement)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *meta.LabelSelectorRequirement:
			return LabelSelectorRequirement{V: v}
		case meta.LabelSelectorRequirement:
			return LabelSelectorRequirement{V: &v}
		default:
			return skylark.None
		}
	}
	LabelSelectorRequirement_attrs = setFieldTypes(t, LabelSelectorRequirement_fields, LabelSelectorRequirement_inline)
	Library["LabelSelectorRequirement"] = skylark.NewBuiltin("LabelSelectorRequirement", createLabelSelectorRequirement)
}

func createLabelSelectorRequirement(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := LabelSelectorRequirement{V: &meta.LabelSelectorRequirement{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t LabelSelectorRequirement) Underlying() interface{} { return t.V }
func (t LabelSelectorRequirement) DeepCopy() boxed         { return LabelSelectorRequirement{V: t.V.DeepCopy()} }
func (t LabelSelectorRequirement) Package() util.Package   { return util.Meta }
func (t LabelSelectorRequirement) Type() string            { return "k8s_meta_LabelSelectorRequirement" }
func (t LabelSelectorRequirement) String() string          { return t.V.String() }
func (t LabelSelectorRequirement) Freeze()                 {} // TODO
func (t LabelSelectorRequirement) Truth() skylark.Bool     { return skylark.True }
func (t LabelSelectorRequirement) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t LabelSelectorRequirement) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*LabelSelectorRequirement)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t LabelSelectorRequirement) AttrNames() []string { return LabelSelectorRequirement_attrs }
func (t LabelSelectorRequirement) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, LabelSelectorRequirement_fields, LabelSelectorRequirement_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t LabelSelectorRequirement) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, LabelSelectorRequirement_fields, LabelSelectorRequirement_inline)
}

type ListMeta struct {
	V *meta.ListMeta
}

var (
	_ boxed = (*ListMeta)(nil)

	ListMeta_fields = map[string]util.FieldSpec{}
	ListMeta_inline = map[string]util.FieldSpec{}
	ListMeta_attrs  []string
)

func init() {
	t := reflect.TypeOf((*meta.ListMeta)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *meta.ListMeta:
			return ListMeta{V: v}
		case meta.ListMeta:
			return ListMeta{V: &v}
		default:
			return skylark.None
		}
	}
	ListMeta_attrs = setFieldTypes(t, ListMeta_fields, ListMeta_inline)
	Library["ListMeta"] = skylark.NewBuiltin("ListMeta", createListMeta)
}

func createListMeta(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ListMeta{V: &meta.ListMeta{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ListMeta) Underlying() interface{} { return t.V }
func (t ListMeta) DeepCopy() boxed         { return ListMeta{V: t.V.DeepCopy()} }
func (t ListMeta) Package() util.Package   { return util.Meta }
func (t ListMeta) Type() string            { return "k8s_meta_ListMeta" }
func (t ListMeta) String() string          { return t.V.String() }
func (t ListMeta) Freeze()                 {} // TODO
func (t ListMeta) Truth() skylark.Bool     { return skylark.True }
func (t ListMeta) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ListMeta) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ListMeta)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ListMeta) AttrNames() []string { return ListMeta_attrs }
func (t ListMeta) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ListMeta_fields, ListMeta_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ListMeta) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ListMeta_fields, ListMeta_inline)
}

type ListOptions struct {
	V *meta.ListOptions
}

var (
	_ boxed = (*ListOptions)(nil)

	ListOptions_fields = map[string]util.FieldSpec{}
	ListOptions_inline = map[string]util.FieldSpec{}
	ListOptions_attrs  []string
)

func init() {
	t := reflect.TypeOf((*meta.ListOptions)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *meta.ListOptions:
			return ListOptions{V: v}
		case meta.ListOptions:
			return ListOptions{V: &v}
		default:
			return skylark.None
		}
	}
	ListOptions_attrs = setFieldTypes(t, ListOptions_fields, ListOptions_inline)
	Library["ListOptions"] = skylark.NewBuiltin("ListOptions", createListOptions)
}

func createListOptions(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ListOptions{V: &meta.ListOptions{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ListOptions) Underlying() interface{} { return t.V }
func (t ListOptions) DeepCopy() boxed         { return ListOptions{V: t.V.DeepCopy()} }
func (t ListOptions) Package() util.Package   { return util.Meta }
func (t ListOptions) Type() string            { return "k8s_meta_ListOptions" }
func (t ListOptions) String() string          { return t.V.String() }
func (t ListOptions) Freeze()                 {} // TODO
func (t ListOptions) Truth() skylark.Bool     { return skylark.True }
func (t ListOptions) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ListOptions) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ListOptions)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ListOptions) AttrNames() []string { return ListOptions_attrs }
func (t ListOptions) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ListOptions_fields, ListOptions_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ListOptions) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ListOptions_fields, ListOptions_inline)
}

type ObjectMeta struct {
	V *meta.ObjectMeta
}

var (
	_ boxed = (*ObjectMeta)(nil)

	ObjectMeta_fields = map[string]util.FieldSpec{}
	ObjectMeta_inline = map[string]util.FieldSpec{}
	ObjectMeta_attrs  []string
)

func init() {
	t := reflect.TypeOf((*meta.ObjectMeta)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *meta.ObjectMeta:
			return ObjectMeta{V: v}
		case meta.ObjectMeta:
			return ObjectMeta{V: &v}
		default:
			return skylark.None
		}
	}
	ObjectMeta_attrs = setFieldTypes(t, ObjectMeta_fields, ObjectMeta_inline)
	Library["ObjectMeta"] = skylark.NewBuiltin("ObjectMeta", createObjectMeta)
}

func createObjectMeta(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ObjectMeta{V: &meta.ObjectMeta{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ObjectMeta) Underlying() interface{} { return t.V }
func (t ObjectMeta) DeepCopy() boxed         { return ObjectMeta{V: t.V.DeepCopy()} }
func (t ObjectMeta) Package() util.Package   { return util.Meta }
func (t ObjectMeta) Type() string            { return "k8s_meta_ObjectMeta" }
func (t ObjectMeta) String() string          { return t.V.String() }
func (t ObjectMeta) Freeze()                 {} // TODO
func (t ObjectMeta) Truth() skylark.Bool     { return skylark.True }
func (t ObjectMeta) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t ObjectMeta) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ObjectMeta)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ObjectMeta) AttrNames() []string { return ObjectMeta_attrs }
func (t ObjectMeta) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ObjectMeta_fields, ObjectMeta_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ObjectMeta) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ObjectMeta_fields, ObjectMeta_inline)
}

type OwnerReference struct {
	V *meta.OwnerReference
}

var (
	_ boxed = (*OwnerReference)(nil)

	OwnerReference_fields = map[string]util.FieldSpec{}
	OwnerReference_inline = map[string]util.FieldSpec{}
	OwnerReference_attrs  []string
)

func init() {
	t := reflect.TypeOf((*meta.OwnerReference)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *meta.OwnerReference:
			return OwnerReference{V: v}
		case meta.OwnerReference:
			return OwnerReference{V: &v}
		default:
			return skylark.None
		}
	}
	OwnerReference_attrs = setFieldTypes(t, OwnerReference_fields, OwnerReference_inline)
	Library["OwnerReference"] = skylark.NewBuiltin("OwnerReference", createOwnerReference)
}

func createOwnerReference(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := OwnerReference{V: &meta.OwnerReference{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t OwnerReference) Underlying() interface{} { return t.V }
func (t OwnerReference) DeepCopy() boxed         { return OwnerReference{V: t.V.DeepCopy()} }
func (t OwnerReference) Package() util.Package   { return util.Meta }
func (t OwnerReference) Type() string            { return "k8s_meta_OwnerReference" }
func (t OwnerReference) String() string          { return t.V.String() }
func (t OwnerReference) Freeze()                 {} // TODO
func (t OwnerReference) Truth() skylark.Bool     { return skylark.True }
func (t OwnerReference) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t OwnerReference) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*OwnerReference)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t OwnerReference) AttrNames() []string { return OwnerReference_attrs }
func (t OwnerReference) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, OwnerReference_fields, OwnerReference_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t OwnerReference) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, OwnerReference_fields, OwnerReference_inline)
}

type Patch struct {
	V *meta.Patch
}

var (
	_ boxed = (*Patch)(nil)

	Patch_fields = map[string]util.FieldSpec{}
	Patch_inline = map[string]util.FieldSpec{}
	Patch_attrs  []string
)

func init() {
	t := reflect.TypeOf((*meta.Patch)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *meta.Patch:
			return Patch{V: v}
		case meta.Patch:
			return Patch{V: &v}
		default:
			return skylark.None
		}
	}
	Patch_attrs = setFieldTypes(t, Patch_fields, Patch_inline)
	Library["Patch"] = skylark.NewBuiltin("Patch", createPatch)
}

func createPatch(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := Patch{V: &meta.Patch{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t Patch) Underlying() interface{} { return t.V }
func (t Patch) DeepCopy() boxed         { return Patch{V: t.V.DeepCopy()} }
func (t Patch) Package() util.Package   { return util.Meta }
func (t Patch) Type() string            { return "k8s_meta_Patch" }
func (t Patch) String() string          { return t.V.String() }
func (t Patch) Freeze()                 {} // TODO
func (t Patch) Truth() skylark.Bool     { return skylark.True }
func (t Patch) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t Patch) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*Patch)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t Patch) AttrNames() []string { return Patch_attrs }
func (t Patch) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, Patch_fields, Patch_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t Patch) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, Patch_fields, Patch_inline)
}

type RootPaths struct {
	V *meta.RootPaths
}

var (
	_ boxed = (*RootPaths)(nil)

	RootPaths_fields = map[string]util.FieldSpec{}
	RootPaths_inline = map[string]util.FieldSpec{}
	RootPaths_attrs  []string
)

func init() {
	t := reflect.TypeOf((*meta.RootPaths)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *meta.RootPaths:
			return RootPaths{V: v}
		case meta.RootPaths:
			return RootPaths{V: &v}
		default:
			return skylark.None
		}
	}
	RootPaths_attrs = setFieldTypes(t, RootPaths_fields, RootPaths_inline)
	Library["RootPaths"] = skylark.NewBuiltin("RootPaths", createRootPaths)
}

func createRootPaths(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := RootPaths{V: &meta.RootPaths{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t RootPaths) Underlying() interface{} { return t.V }
func (t RootPaths) DeepCopy() boxed         { return RootPaths{V: t.V.DeepCopy()} }
func (t RootPaths) Package() util.Package   { return util.Meta }
func (t RootPaths) Type() string            { return "k8s_meta_RootPaths" }
func (t RootPaths) String() string          { return t.V.String() }
func (t RootPaths) Freeze()                 {} // TODO
func (t RootPaths) Truth() skylark.Bool     { return skylark.True }
func (t RootPaths) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t RootPaths) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*RootPaths)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t RootPaths) AttrNames() []string { return RootPaths_attrs }
func (t RootPaths) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, RootPaths_fields, RootPaths_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t RootPaths) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, RootPaths_fields, RootPaths_inline)
}

type ServerAddressByClientCIDR struct {
	V *meta.ServerAddressByClientCIDR
}

var (
	_ boxed = (*ServerAddressByClientCIDR)(nil)

	ServerAddressByClientCIDR_fields = map[string]util.FieldSpec{}
	ServerAddressByClientCIDR_inline = map[string]util.FieldSpec{}
	ServerAddressByClientCIDR_attrs  []string
)

func init() {
	t := reflect.TypeOf((*meta.ServerAddressByClientCIDR)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *meta.ServerAddressByClientCIDR:
			return ServerAddressByClientCIDR{V: v}
		case meta.ServerAddressByClientCIDR:
			return ServerAddressByClientCIDR{V: &v}
		default:
			return skylark.None
		}
	}
	ServerAddressByClientCIDR_attrs = setFieldTypes(t, ServerAddressByClientCIDR_fields, ServerAddressByClientCIDR_inline)
	Library["ServerAddressByClientCIDR"] = skylark.NewBuiltin("ServerAddressByClientCIDR", createServerAddressByClientCIDR)
}

func createServerAddressByClientCIDR(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := ServerAddressByClientCIDR{V: &meta.ServerAddressByClientCIDR{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t ServerAddressByClientCIDR) Underlying() interface{} { return t.V }
func (t ServerAddressByClientCIDR) DeepCopy() boxed {
	return ServerAddressByClientCIDR{V: t.V.DeepCopy()}
}
func (t ServerAddressByClientCIDR) Package() util.Package { return util.Meta }
func (t ServerAddressByClientCIDR) Type() string          { return "k8s_meta_ServerAddressByClientCIDR" }
func (t ServerAddressByClientCIDR) String() string        { return t.V.String() }
func (t ServerAddressByClientCIDR) Freeze()               {} // TODO
func (t ServerAddressByClientCIDR) Truth() skylark.Bool   { return skylark.True }
func (t ServerAddressByClientCIDR) Hash() (uint32, error) { return 0, unhashable(t.Type()) }
func (t ServerAddressByClientCIDR) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*ServerAddressByClientCIDR)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t ServerAddressByClientCIDR) AttrNames() []string { return ServerAddressByClientCIDR_attrs }
func (t ServerAddressByClientCIDR) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, ServerAddressByClientCIDR_fields, ServerAddressByClientCIDR_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t ServerAddressByClientCIDR) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, ServerAddressByClientCIDR_fields, ServerAddressByClientCIDR_inline)
}

type Status struct {
	V *meta.Status
}

var (
	_ boxed = (*Status)(nil)

	Status_fields = map[string]util.FieldSpec{}
	Status_inline = map[string]util.FieldSpec{}
	Status_attrs  []string
)

func init() {
	t := reflect.TypeOf((*meta.Status)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *meta.Status:
			return Status{V: v}
		case meta.Status:
			return Status{V: &v}
		default:
			return skylark.None
		}
	}
	Status_attrs = setFieldTypes(t, Status_fields, Status_inline)
	Library["Status"] = skylark.NewBuiltin("Status", createStatus)
}

func createStatus(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := Status{V: &meta.Status{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t Status) Underlying() interface{} { return t.V }
func (t Status) DeepCopy() boxed         { return Status{V: t.V.DeepCopy()} }
func (t Status) Package() util.Package   { return util.Meta }
func (t Status) Type() string            { return "k8s_meta_Status" }
func (t Status) String() string          { return t.V.String() }
func (t Status) Freeze()                 {} // TODO
func (t Status) Truth() skylark.Bool     { return skylark.True }
func (t Status) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t Status) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*Status)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t Status) AttrNames() []string { return Status_attrs }
func (t Status) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, Status_fields, Status_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t Status) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, Status_fields, Status_inline)
}

type StatusCause struct {
	V *meta.StatusCause
}

var (
	_ boxed = (*StatusCause)(nil)

	StatusCause_fields = map[string]util.FieldSpec{}
	StatusCause_inline = map[string]util.FieldSpec{}
	StatusCause_attrs  []string
)

func init() {
	t := reflect.TypeOf((*meta.StatusCause)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *meta.StatusCause:
			return StatusCause{V: v}
		case meta.StatusCause:
			return StatusCause{V: &v}
		default:
			return skylark.None
		}
	}
	StatusCause_attrs = setFieldTypes(t, StatusCause_fields, StatusCause_inline)
	Library["StatusCause"] = skylark.NewBuiltin("StatusCause", createStatusCause)
}

func createStatusCause(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := StatusCause{V: &meta.StatusCause{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t StatusCause) Underlying() interface{} { return t.V }
func (t StatusCause) DeepCopy() boxed         { return StatusCause{V: t.V.DeepCopy()} }
func (t StatusCause) Package() util.Package   { return util.Meta }
func (t StatusCause) Type() string            { return "k8s_meta_StatusCause" }
func (t StatusCause) String() string          { return t.V.String() }
func (t StatusCause) Freeze()                 {} // TODO
func (t StatusCause) Truth() skylark.Bool     { return skylark.True }
func (t StatusCause) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t StatusCause) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*StatusCause)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t StatusCause) AttrNames() []string { return StatusCause_attrs }
func (t StatusCause) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, StatusCause_fields, StatusCause_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t StatusCause) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, StatusCause_fields, StatusCause_inline)
}

type StatusDetails struct {
	V *meta.StatusDetails
}

var (
	_ boxed = (*StatusDetails)(nil)

	StatusDetails_fields = map[string]util.FieldSpec{}
	StatusDetails_inline = map[string]util.FieldSpec{}
	StatusDetails_attrs  []string
)

func init() {
	t := reflect.TypeOf((*meta.StatusDetails)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *meta.StatusDetails:
			return StatusDetails{V: v}
		case meta.StatusDetails:
			return StatusDetails{V: &v}
		default:
			return skylark.None
		}
	}
	StatusDetails_attrs = setFieldTypes(t, StatusDetails_fields, StatusDetails_inline)
	Library["StatusDetails"] = skylark.NewBuiltin("StatusDetails", createStatusDetails)
}

func createStatusDetails(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := StatusDetails{V: &meta.StatusDetails{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t StatusDetails) Underlying() interface{} { return t.V }
func (t StatusDetails) DeepCopy() boxed         { return StatusDetails{V: t.V.DeepCopy()} }
func (t StatusDetails) Package() util.Package   { return util.Meta }
func (t StatusDetails) Type() string            { return "k8s_meta_StatusDetails" }
func (t StatusDetails) String() string          { return t.V.String() }
func (t StatusDetails) Freeze()                 {} // TODO
func (t StatusDetails) Truth() skylark.Bool     { return skylark.True }
func (t StatusDetails) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t StatusDetails) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*StatusDetails)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t StatusDetails) AttrNames() []string { return StatusDetails_attrs }
func (t StatusDetails) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, StatusDetails_fields, StatusDetails_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t StatusDetails) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, StatusDetails_fields, StatusDetails_inline)
}

type TypeMeta struct {
	V *meta.TypeMeta
}

var (
	_ boxed = (*TypeMeta)(nil)

	TypeMeta_fields = map[string]util.FieldSpec{}
	TypeMeta_inline = map[string]util.FieldSpec{}
	TypeMeta_attrs  []string
)

func init() {
	t := reflect.TypeOf((*meta.TypeMeta)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *meta.TypeMeta:
			return TypeMeta{V: v}
		case meta.TypeMeta:
			return TypeMeta{V: &v}
		default:
			return skylark.None
		}
	}
	TypeMeta_attrs = setFieldTypes(t, TypeMeta_fields, TypeMeta_inline)
	Library["TypeMeta"] = skylark.NewBuiltin("TypeMeta", createTypeMeta)
}

func createTypeMeta(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := TypeMeta{V: &meta.TypeMeta{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t TypeMeta) Underlying() interface{} { return t.V }
func (t TypeMeta) DeepCopy() boxed {
	if t.V == nil {
		return TypeMeta{}
	}
	v := *t.V
	return TypeMeta{V: &v}
}
func (t TypeMeta) Package() util.Package { return util.Meta }
func (t TypeMeta) Type() string          { return "k8s_meta_TypeMeta" }
func (t TypeMeta) String() string        { return t.V.String() }
func (t TypeMeta) Freeze()               {} // TODO
func (t TypeMeta) Truth() skylark.Bool   { return skylark.True }
func (t TypeMeta) Hash() (uint32, error) { return 0, unhashable(t.Type()) }
func (t TypeMeta) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*TypeMeta)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t TypeMeta) AttrNames() []string { return TypeMeta_attrs }
func (t TypeMeta) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, TypeMeta_fields, TypeMeta_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t TypeMeta) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, TypeMeta_fields, TypeMeta_inline)
}

type UpdateOptions struct {
	V *meta.UpdateOptions
}

var (
	_ boxed = (*UpdateOptions)(nil)

	UpdateOptions_fields = map[string]util.FieldSpec{}
	UpdateOptions_inline = map[string]util.FieldSpec{}
	UpdateOptions_attrs  []string
)

func init() {
	t := reflect.TypeOf((*meta.UpdateOptions)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *meta.UpdateOptions:
			return UpdateOptions{V: v}
		case meta.UpdateOptions:
			return UpdateOptions{V: &v}
		default:
			return skylark.None
		}
	}
	UpdateOptions_attrs = setFieldTypes(t, UpdateOptions_fields, UpdateOptions_inline)
	Library["UpdateOptions"] = skylark.NewBuiltin("UpdateOptions", createUpdateOptions)
}

func createUpdateOptions(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := UpdateOptions{V: &meta.UpdateOptions{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t UpdateOptions) Underlying() interface{} { return t.V }
func (t UpdateOptions) DeepCopy() boxed         { return UpdateOptions{V: t.V.DeepCopy()} }
func (t UpdateOptions) Package() util.Package   { return util.Meta }
func (t UpdateOptions) Type() string            { return "k8s_meta_UpdateOptions" }
func (t UpdateOptions) String() string          { return t.V.String() }
func (t UpdateOptions) Freeze()                 {} // TODO
func (t UpdateOptions) Truth() skylark.Bool     { return skylark.True }
func (t UpdateOptions) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t UpdateOptions) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*UpdateOptions)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t UpdateOptions) AttrNames() []string { return UpdateOptions_attrs }
func (t UpdateOptions) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, UpdateOptions_fields, UpdateOptions_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t UpdateOptions) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, UpdateOptions_fields, UpdateOptions_inline)
}

type WatchEvent struct {
	V *meta.WatchEvent
}

var (
	_ boxed = (*WatchEvent)(nil)

	WatchEvent_fields = map[string]util.FieldSpec{}
	WatchEvent_inline = map[string]util.FieldSpec{}
	WatchEvent_attrs  []string
)

func init() {
	t := reflect.TypeOf((*meta.WatchEvent)(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *meta.WatchEvent:
			return WatchEvent{V: v}
		case meta.WatchEvent:
			return WatchEvent{V: &v}
		default:
			return skylark.None
		}
	}
	WatchEvent_attrs = setFieldTypes(t, WatchEvent_fields, WatchEvent_inline)
	Library["WatchEvent"] = skylark.NewBuiltin("WatchEvent", createWatchEvent)
}

func createWatchEvent(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := WatchEvent{V: &meta.WatchEvent{}}
	err := construct(box, args, kwargs)
	return box, err
}
func (t WatchEvent) Underlying() interface{} { return t.V }
func (t WatchEvent) DeepCopy() boxed         { return WatchEvent{V: t.V.DeepCopy()} }
func (t WatchEvent) Package() util.Package   { return util.Meta }
func (t WatchEvent) Type() string            { return "k8s_meta_WatchEvent" }
func (t WatchEvent) String() string          { return t.V.String() }
func (t WatchEvent) Freeze()                 {} // TODO
func (t WatchEvent) Truth() skylark.Bool     { return skylark.True }
func (t WatchEvent) Hash() (uint32, error)   { return 0, unhashable(t.Type()) }
func (t WatchEvent) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*WatchEvent)
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t WatchEvent) AttrNames() []string { return WatchEvent_attrs }
func (t WatchEvent) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, WatchEvent_fields, WatchEvent_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t WatchEvent) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, WatchEvent_fields, WatchEvent_inline)
}
