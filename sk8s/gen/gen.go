// Copyright 2018 West Damron. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package main

import (
	"bytes"
	"fmt"
	"go/importer"
	"go/types"
	"log"
	"strings"
	"text/template"

	"github.com/google/skylark/sk8s/util"
)

var includedPackages = []string{
	"k8s.io/api/core/v1",
	"k8s.io/api/apps/v1",
	"k8s.io/api/autoscaling/v1",
	"k8s.io/api/batch/v1",
	"k8s.io/api/authentication/v1",
	"k8s.io/api/authorization/v1",
	"k8s.io/api/networking/v1",
	"k8s.io/api/rbac/v1",
	"k8s.io/api/storage/v1",
	"k8s.io/apimachinery/pkg/apis/meta/v1",
	// "k8s.io/apiextensions-apiserver/pkg/apis/apiextensions",
}

var packageAliases = map[string]string{
	"k8s.io/api/core/v1":                                    "core",
	"k8s.io/api/apps/v1":                                    "apps",
	"k8s.io/api/autoscaling/v1":                             "autoscaling",
	"k8s.io/api/batch/v1":                                   "batch",
	"k8s.io/api/authentication/v1":                          "authentication",
	"k8s.io/api/authorization/v1":                           "authorization",
	"k8s.io/api/networking/v1":                              "networking",
	"k8s.io/api/rbac/v1":                                    "rbac",
	"k8s.io/api/storage/v1":                                 "storage",
	"k8s.io/apimachinery/pkg/apis/meta/v1":                  "meta",
	"k8s.io/apimachinery/pkg/api/resource":                  "resource",
	"k8s.io/apimachinery/pkg/util/intstr":                   "intstr",
	"k8s.io/apiextensions-apiserver/pkg/apis/apiextensions": "apiextensions",
}

var primitives = map[string]bool{
	"Time":      true,
	"Timestamp": true,
	"MicroTime": true,
	"Duration":  true,
}

func main() {

	out := &bytes.Buffer{}
	// out.WriteString(header)

	imported := make(map[util.Package]*types.Package)
	for _, path := range includedPackages {
		p, err := importer.Default().Import(path)
		if err != nil {
			log.Fatal(err)
		}
		imported[util.PackageForPath(path)] = p
	}

	type aliasedImports []struct {
		Alias string
		Path  string
	}
	aliased := make(aliasedImports, len(includedPackages))
	for i, path := range includedPackages {
		aliased[i].Alias, aliased[i].Path = packageAliases[path], path
	}
	if err := header.Execute(out, aliased); err != nil {
		log.Fatal(err)
	}

	written := make(map[string]bool)
	for _, path := range includedPackages {
		if err := writeTypes(out, util.PackageForPath(path), imported, written); err != nil {
			log.Fatal(err)
		}
	}

	fmt.Println(string(out.Bytes()))
}

func writeTypes(out *bytes.Buffer, pkg util.Package, imported map[util.Package]*types.Package, written map[string]bool) error {

	type Data struct {
		TypeName                *types.TypeName
		Pkg                     util.Package
		PkgName, PkgAlias, Name string
		Type                    *types.Struct
		Imports                 map[util.Package]*types.Package
	}

	scope := imported[pkg].Scope()

	for _, name := range scope.Names() {
		if written[name] || primitives[name] {
			continue
		}

		obj := scope.Lookup(name)
		if !obj.Exported() {
			continue
		}

		typeName, ok := obj.(*types.TypeName)
		if !ok {
			continue
		}

		path := typeName.Pkg().Path()
		pkgAlias := packageAliases[path]

		if stype, ok := obj.Type().Underlying().(*types.Struct); ok {
			data := Data{
				TypeName: typeName,
				Pkg:      util.PackageForPath(path),
				PkgName:  path,
				PkgAlias: pkgAlias,
				Name:     name,
				Type:     stype,
				Imports:  imported,
			}

			if err := body.Execute(out, data); err != nil {
				return err
			}

			written[name] = true
		}
	}

	return nil
}

func hasstringmethod(tn *types.TypeName) bool {
	n := tn.Type().(*types.Named)
	nm := n.NumMethods()
	for i := 0; i < nm; i++ {
		m := n.Method(i)
		if m.Name() == "String" {
			return true
		}
	}
	return false
}

func hasdeepcopymethod(tn *types.TypeName) bool {
	n := tn.Type().(*types.Named)
	nm := n.NumMethods()
	for i := 0; i < nm; i++ {
		m := n.Method(i)
		if m.Name() == "DeepCopy" {
			return true
		}
	}
	return false
}

var funcs = template.FuncMap{
	"titlecase":         strings.Title,
	"hasstringmethod":   hasstringmethod,
	"hasdeepcopymethod": hasdeepcopymethod,
}

var header = template.Must(template.New("sk8s_generated_head").Parse(`// Copyright 2018 West Damron. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package kinds

// Code generated by sk8s/gen. DO NOT EDIT

import (
	"reflect"

	"github.com/google/skylark"
	"github.com/google/skylark/sk8s/util"
	"github.com/google/skylark/syntax"

{{- range $i, $import := . }}
	{{ $import.Alias }} "{{ $import.Path }}"
{{- end}}

)
`))

var body = template.Must(template.New("sk8s_generated_body").Funcs(funcs).Parse(`
{{ $pkg := .PkgAlias }}
{{ $name := .Name }}
{{ $t := .Type }}
{{ $tn := .TypeName }}
{{ $imports := .Imports }}

type {{ $name }} struct {
	V *{{ $pkg }}.{{ $name }}
}

var (
	_ boxed = (*{{ $name }})(nil)

	{{ $name }}_fields = map[string]util.FieldSpec{}
	{{ $name }}_inline = map[string]util.FieldSpec{}
	{{ $name }}_attrs []string
)

func init() {
	t := reflect.TypeOf((*{{ $pkg }}.{{ $name }})(nil)).Elem()
	g2s[t] = func(iface interface{}) skylark.Value {
		switch v := iface.(type) {
		case *{{ $pkg }}.{{ $name }}:
			return {{ $name }}{V: v}
		case {{ $pkg }}.{{ $name }}:
			return {{ $name }}{V: &v}
		default:
			return skylark.None
		}
	}
	{{ $name }}_attrs = setFieldTypes(t, {{ $name }}_fields, {{ $name }}_inline)
	Library["{{ $name }}"] = skylark.NewBuiltin("{{ $name }}", create{{ $name }})
}

func create{{ $name }}(thread *skylark.Thread, fn *skylark.Builtin, args skylark.Tuple, kwargs []skylark.Tuple) (skylark.Value, error) {
	box := {{ $name }}{ V: &{{ $pkg }}.{{ $name }}{} }
	err := construct(box, args, kwargs)
	return box, err
}
func (t {{ $name }}) Underlying() interface{} { return t.V }
func (t {{ $name }}) DeepCopy() boxed {{ if ( hasdeepcopymethod $tn ) }} { return {{ $name }}{V: t.V.DeepCopy()} } {{ else}} {
	if t.V == nil {
		return {{ $name }}{}
	}
	v := *t.V
	return {{ $name }}{V: &v}
} {{ end}}
func (t {{ $name }}) Package() util.Package  { return util.{{ $pkg | titlecase }} }
func (t {{ $name }}) Type() string        { return "k8s_{{ $pkg }}_{{ $name }}" }
func (t {{ $name }}) String() string { return {{ if ( hasstringmethod $tn ) }} t.V.String() {{ else }} genericStringMethod(t.V) {{ end }} }
func (t {{ $name }}) Freeze()             { } // TODO
func (t {{ $name }}) Truth() skylark.Bool { return skylark.True }
func (t {{ $name }}) Hash() (uint32, error) { return 0, unhashable(t.Type()) }
func (t {{ $name }}) CompareSameType(op syntax.Token, y_ skylark.Value, depth int) (bool, error) {
	y := y_.(*{{ $name }})
	return compareSameType(t, op, y, t.Type(), depth)
}
func (t {{ $name }}) AttrNames() []string { return {{ $name }}_attrs }
func (t {{ $name }}) Attr(name string) (skylark.Value, error) {
	if t.V != nil {
		return getAttr(reflect.ValueOf(t.V), name, {{ $name }}_fields, {{ $name }}_inline)
	}
	return skylark.None, uninitialized(t.Type(), name)
}
func (t {{ $name }}) SetField(name string, value skylark.Value) error {
	return setAttr(t, name, value, {{ $name }}_fields, {{ $name }}_inline)
}`))
